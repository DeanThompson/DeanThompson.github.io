<!DOCTYPE HTML>

<html lang="zh-CN">

<head>
	<meta charset="utf-8">
	<title>【翻译】理解 Python 装饰器 - 李林克斯</title>
	<meta name="author" content="map[email:yanglianglee@gmail.com name:Yangliang Li]">

	
	
	<meta name="description" content="">
	

	
	<meta name="HandheldFriendly" content="True">
	<meta name="MobileOptimized" content="320">
	<meta name="viewport" content="width=device-width, initial-scale=1">
    
	<link href='/index.xml' rel="alternate" title="李林克斯" type="application/atom+xml">
	
	<link rel="canonical" href="https://liyangliang.me/posts/2013/03/understand-python-decorators/">
	<link href="https://liyangliang.me/favicon.jpeg" rel="shortcut icon">
	<link href="https://liyangliang.me/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="https://liyangliang.me/css/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	
	<link href='https://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'>
	
	
	<script type="text/javascript" src="https://tajs.qq.com/stats?sId=57832219" charset="UTF-8"></script>
	<script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
	
    <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.2.0/languages/go.min.js"></script>
<link href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css" rel="stylesheet">
<script>hljs.initHighlightingOnLoad();</script>

    
	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-45384257-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



	<style media="screen">
	article pre, article code {border-radius: 3px 3px 3px 3px; -moz-border-radius: 3px 3px 3px 3px; -webkit-border-radius: 3px 3px 3px 3px; border: 0px solid #000000;}
	article code {background: #f8f8f8;}
	</style>
</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<img src='https://www.gravatar.com/avatar/fe812f189c0479f8cc24d7bd3b76e46d?s=160' alt="Profile Picture" style="width: 160px;" />
	
</div>

<nav id="main-nav"><ul class="main">
    <li><a href="/">Blog</a></li>
    <li><a href="/about">About</a></li>
    <li><a href="/post/">Archives</a></li>
</ul>


<section class="aboutme">
  <p>
    
  </p>
</section>
</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="email" href='mailto:yanglianglee@gmail.com' title="Email">Email</a>
		
		
		
		
		
			<a class="github" href='https://github.com/DeanThompson' title="GitHub">GitHub</a>
		
		
		
		  <a class="stackoverflow" href='https://stackoverflow.com/users/1461780/leon-young' title="StackOverflow"></a>
		
		
		
		
		
		
			<a class="douban" href='https://www.douban.com/people/Touchthesky' title="Douban">Douban</a>
		
		
		
    	
    	
			<a class="rss" href='/index.xml' title="RSS">RSS</a>
		
	</div>
</nav>
</header>
			</div>
		</div>
		<div class="mid-col">
			
			<div class="mid-col-container">
				<div id="content" class="inner">
					<div itemscope itemtype="https://schema.org/Blog">
					<article class="post" itemscope itemtype="https://schema.org/BlogPosting">
						<div class="meta">
							<div class="date"><time datetime='Wed, Mar 13, 2013' data-updated="true" itemprop="datePublished">Wed, Mar 13, 2013</time>
</div>
							<div class="tags">


	
	
	    <a href="https://liyangliang.me/categories/python"> python </a>
	


</div>
							
								<span class="comments"><a href="https://liyangliang.me/posts/2013/03/understand-python-decorators/#disqus_thread">Comments</a></span>
							
						</div>
						
    <h1 class="title" itemprop="name">【翻译】理解 Python 装饰器</h1>
	<div class="entry-content" itemprop="articleBody"><h2 id="note">Note</h2>
<p>前段时间在 stack overflow 上看到一个关于 python decorator（装饰器）的问题，有一个人很耐心的写了一篇很长的教程。我也很耐心的看完了，获益匪浅。现在尝试翻译过来，尽量追求准确和尊重原文。不明白的地方，或翻译不好的地方，请参照原文，地址：</p>
<blockquote>
<p><a href="http://stackoverflow.com/questions/739654/understanding-python-decorators#answer-1594484">Understanding Python decorators</a></p>
</blockquote>
<hr>
<h1 id="1-python的函数是对象pythons-functions-are-objects">1. python的函数是对象（Python&rsquo;s functions are objects）</h1>
<p>要理解装饰器，就必须先知道，在python里，函数也是对象（functions are objects）。明白这一点非常重要，让我们通过一个例子来看看为什么。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">shout</span>(word<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;yes&#34;</span>):
    <span style="color:#66d9ef">return</span> word<span style="color:#f92672">.</span>capitalize()<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;!&#34;</span>
 
<span style="color:#66d9ef">print</span> shout()
<span style="color:#75715e"># outputs : &#39;Yes!&#39;</span>
 
<span style="color:#75715e"># 作为一个对象，你可以像其他对象一样把函数赋值给其他变量</span>
 
scream <span style="color:#f92672">=</span> shout
 
<span style="color:#75715e"># 注意我们没有用括号：我们不是在调用函数，</span>
<span style="color:#75715e"># 而是把函数&#39;shout&#39;的值绑定到&#39;scream&#39;这个变量上</span>
<span style="color:#75715e"># 这也意味着你可以通过&#39;scream&#39;这个变量来调用&#39;shout&#39;函数</span>
 
<span style="color:#66d9ef">print</span> scream()
<span style="color:#75715e"># outputs : &#39;Yes!&#39;</span>
 
<span style="color:#75715e"># 不仅如此，这也还意味着你可以把原来的名字&#39;shout&#39;删掉，</span>
<span style="color:#75715e"># 而这个函数仍然可以通过&#39;scream&#39;来访问</span>
<span style="color:#66d9ef">del</span> shout
<span style="color:#66d9ef">try</span>:
    <span style="color:#66d9ef">print</span> shout()
<span style="color:#66d9ef">except</span> <span style="color:#a6e22e">NameError</span>, e:
    <span style="color:#66d9ef">print</span> e
    <span style="color:#75715e">#outputs: &#34;name &#39;shout&#39; is not defined&#34;</span>
 
<span style="color:#66d9ef">print</span> scream()
outputs: <span style="color:#e6db74">&#39;Yes!&#39;</span>
</code></pre></div><p>OK，先记住这点，我们马上会用到。python 函数的另一个有趣的特性是，它们可以在另一个函数体内定义。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">talk</span>():
 
    <span style="color:#75715e"># 你可以在 &#39;talk&#39; 里动态的(on the fly)定义一个函数...</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">whisper</span>(word<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;yes&#34;</span>):
        <span style="color:#66d9ef">return</span> word<span style="color:#f92672">.</span>lower()<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;...&#34;</span>
 
    <span style="color:#75715e"># ... 然后马上调用它！</span>
 
    <span style="color:#66d9ef">print</span> whisper()
 
<span style="color:#75715e"># 每当调用&#39;talk&#39;，都会定义一次&#39;whisper&#39;，然后&#39;whisper&#39;在&#39;talk&#39;里被调用</span>
talk()
<span style="color:#75715e"># outputs:</span>
<span style="color:#75715e"># &#34;yes...&#34;</span>
 
<span style="color:#75715e"># 但是&#34;whisper&#34; 在 &#34;talk&#34;外并不存在:</span>
 
<span style="color:#66d9ef">try</span>:
    <span style="color:#66d9ef">print</span> whisper()
<span style="color:#66d9ef">except</span> <span style="color:#a6e22e">NameError</span>, e:
    <span style="color:#66d9ef">print</span> e
    <span style="color:#75715e">#outputs : &#34;name &#39;whisper&#39; is not defined&#34;*</span>
</code></pre></div><h1 id="2-函数引用functions-references">2. 函数引用（Functions references）</h1>
<p>OK，还在吧？！现在到了有趣的部分，你刚刚已经知道了，python的函数也是对象，因此：</p>
<ul>
<li>可以被赋值给变量</li>
<li>可以在另一个函数体内定义</li>
</ul>
<p>那么，这样就意味着一个函数可以返回另一个函数 :-)，来看个例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">getTalk</span>(type<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;shout&#34;</span>):
 
    <span style="color:#75715e"># 我们先动态定义一些函数</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">shout</span>(word<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;yes&#34;</span>):
        <span style="color:#66d9ef">return</span> word<span style="color:#f92672">.</span>capitalize()<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;!&#34;</span>
 
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">whisper</span>(word<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;yes&#34;</span>) :
        <span style="color:#66d9ef">return</span> word<span style="color:#f92672">.</span>lower()<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;...&#34;</span>;
 
    <span style="color:#75715e"># 然后返回其中一个</span>
    <span style="color:#66d9ef">if</span> type <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;shout&#34;</span>:
        <span style="color:#75715e"># 注意：我们是在返回函数对象，而不是调用函数，</span>
        <span style="color:#75715e"># 所以不要用到括号 &#34;()&#34;</span>
        <span style="color:#66d9ef">return</span> shout 
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">return</span> whisper
 
<span style="color:#75715e"># 那你改如何使用这个怪兽呢？(How do you use this strange beast?)</span>
 
<span style="color:#75715e"># 先把函数赋值给一个变量</span>
talk <span style="color:#f92672">=</span> getTalk()     
 
<span style="color:#75715e"># 你可以发现 &#34;talk&#34; 其实是一个函数对象:</span>
<span style="color:#66d9ef">print</span> talk
<span style="color:#75715e">#outputs : &lt;function shout at 0xb7ea817c&gt;</span>
 
<span style="color:#75715e"># 这个对象就是 getTalk 函数返回的:</span>
<span style="color:#66d9ef">print</span> talk()
<span style="color:#75715e">#outputs : Yes!</span>
 
<span style="color:#75715e"># 你甚至还可以直接这样使用(if you feel wild):</span>
<span style="color:#66d9ef">print</span> getTalk(<span style="color:#e6db74">&#34;whisper&#34;</span>)()
<span style="color:#75715e">#outputs : yes...</span>
</code></pre></div><p>但是等等，还有呢。既然可以返回一个函数，那么也就可以像参数一样传递：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">doSomethingBefore</span>(func):
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;I do something before then I call the function you gave me&#34;</span>
    <span style="color:#66d9ef">print</span> func()
 
doSomethingBefore(scream)
<span style="color:#75715e">#outputs:</span>
<span style="color:#75715e">#I do something before then I call the function you gave me</span>
<span style="color:#75715e">#Yes!</span>
</code></pre></div><p>那好，你现在已经具备了理解装饰器的所有基础知识了。你看，装饰器也就是一种包装材料，<strong>它们可以让你在执行被装饰的函数之前或之后执行其他代码，而且不需要修改函数本身</strong>。（原句比较长：You see, decorators are wrappers which means that they let you execute code before and after the function they decorate without the need to modify the function itself.）</p>
<h1 id="3-手工制作装饰器handcrafted-decorators">3. 手工制作装饰器（Handcrafted decorators）</h1>
<p>你可以像这样来定制：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># 一个装饰器是一个需要另一个函数作为参数的函数</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">my_shiny_new_decorator</span>(a_function_to_decorate):
 
    <span style="color:#75715e"># 在装饰器内部动态定义一个函数：wrapper(原意：包装纸).</span>
    <span style="color:#75715e"># 这个函数将被包装在原始函数的四周</span>
    <span style="color:#75715e"># 因此就可以在原始函数之前和之后执行一些代码.</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">the_wrapper_around_the_original_function</span>():
 
        <span style="color:#75715e"># 把想要在调用原始函数前运行的代码放这里</span>
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Before the function runs&#34;</span>
 
        <span style="color:#75715e"># 调用原始函数（需要带括号）</span>
        a_function_to_decorate()
 
        <span style="color:#75715e"># 把想要在调用原始函数后运行的代码放这里</span>
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;After the function runs&#34;</span>
 
    <span style="color:#75715e"># 直到现在，&#34;a_function_to_decorate&#34;还没有执行过 (HAS NEVER BEEN EXECUTED).</span>
    <span style="color:#75715e"># 我们把刚刚创建的 wrapper 函数返回.</span>
    <span style="color:#75715e"># wrapper 函数包含了这个函数，还有一些需要提前后之后执行的代码，</span>
    <span style="color:#75715e"># 可以直接使用了（It&#39;s ready to use!）</span>
    <span style="color:#66d9ef">return</span> the_wrapper_around_the_original_function
 
<span style="color:#75715e"># Now imagine you create a function you don&#39;t want to ever touch again.</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">a_stand_alone_function</span>():
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;I am a stand alone function, don&#39;t you dare modify me&#34;</span>
 
a_stand_alone_function()
<span style="color:#75715e">#outputs: I am a stand alone function, don&#39;t you dare modify me</span>
 
<span style="color:#75715e"># 现在，你可以装饰一下来修改它的行为.</span>
<span style="color:#75715e"># 只要简单的把它传递给装饰器，后者能用任何你想要的代码动态的包装</span>
<span style="color:#75715e"># 而且返回一个可以直接使用的新函数:</span>
 
a_stand_alone_function_decorated <span style="color:#f92672">=</span> my_shiny_new_decorator(a_stand_alone_function)
a_stand_alone_function_decorated()
<span style="color:#75715e">#outputs:</span>
<span style="color:#75715e">#Before the function runs</span>
<span style="color:#75715e">#I am a stand alone function, don&#39;t you dare modify me</span>
<span style="color:#75715e">#After the function runs</span>
</code></pre></div><p>现在你大概希望，每次调用 <code>a_stand_alone_function</code> 时，实际调用的是 <code>a_stand_alone_function_decorated</code> 。这很容易，只要把 <code>my_shiny_new_decorator</code> 返回的函数覆盖 <code>a_stand_alone_function</code> 就可以了：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">a_stand_alone_function <span style="color:#f92672">=</span> my_shiny_new_decorator(a_stand_alone_function)
a_stand_alone_function()
<span style="color:#75715e">#outputs:</span>
<span style="color:#75715e">#Before the function runs</span>
<span style="color:#75715e">#I am a stand alone function, don&#39;t you dare modify me</span>
<span style="color:#75715e">#After the function runs</span>
 
<span style="color:#75715e"># And guess what? That&#39;s EXACTLY what decorators do!</span>
</code></pre></div><h1 id="4-揭秘装饰器decorators-demystified">4. 揭秘装饰器(Decorators demystified)</h1>
<p>我们用装饰器的语法来重写一下前面的例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a6e22e">@my_shiny_new_decorator</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">another_stand_alone_function</span>():
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Leave me alone&#34;</span>
 
another_stand_alone_function() 
<span style="color:#75715e">#outputs: </span>
<span style="color:#75715e">#Before the function runs</span>
<span style="color:#75715e">#Leave me alone</span>
<span style="color:#75715e">#After the function runs</span>
</code></pre></div><p>是的，这就完了，就这么简单。<code>@decorator</code> 只是下面这条语句的简写(shortcut)：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">another_stand_alone_function <span style="color:#f92672">=</span> my_shiny_new_decorator(another_stand_alone_function)
</code></pre></div><p>装饰器其实就是装饰器模式的一个python化的变体（pythonic variant）。为了方便开发，python已经内置了好几种经典的设计模式，比如迭代器（iterators）。
当然，你还可以堆积使用装饰器(you can cumulate decorators)：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bread</span>(func):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>():
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;&lt;/&#39;&#39;&#39;&#39;&#39;&#39;\&gt;&#34;</span>
        func()
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;&lt;\______/&gt;&#34;</span>
    <span style="color:#66d9ef">return</span> wrapper
 
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ingredients</span>(func):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>():
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;#tomatoes#&#34;</span>
        func()
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;~salad~&#34;</span>
    <span style="color:#66d9ef">return</span> wrapper
 
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sandwich</span>(food<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;--ham--&#34;</span>):
    <span style="color:#66d9ef">print</span> food
 
sandwich()
<span style="color:#75715e">#outputs: --ham--</span>
sandwich <span style="color:#f92672">=</span> bread(ingredients(sandwich))
sandwich()
<span style="color:#75715e">#outputs:</span>
<span style="color:#75715e">#&lt;/&#39;&#39;&#39;&#39;&#39;&#39;\&gt;</span>
<span style="color:#75715e"># #tomatoes#</span>
<span style="color:#75715e"># --ham--</span>
<span style="color:#75715e"># ~salad~</span>
<span style="color:#75715e">#&lt;\______/&gt;</span>
</code></pre></div><p>用python的装饰器语法表示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a6e22e">@bread</span>
<span style="color:#a6e22e">@ingredients</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sandwich</span>(food<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;--ham--&#34;</span>):
    <span style="color:#66d9ef">print</span> food
 
sandwich()
<span style="color:#75715e">#outputs:</span>
<span style="color:#75715e">#&lt;/&#39;&#39;&#39;&#39;&#39;&#39;\&gt;</span>
<span style="color:#75715e"># #tomatoes#</span>
<span style="color:#75715e"># --ham--</span>
<span style="color:#75715e"># ~salad~</span>
<span style="color:#75715e">#&lt;\______/&gt;</span>
</code></pre></div><p>装饰器放置的顺序 <strong>很重要</strong>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a6e22e">@ingredients</span>
<span style="color:#a6e22e">@bread</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">strange_sandwich</span>(food<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;--ham--&#34;</span>):
    <span style="color:#66d9ef">print</span> food
 
strange_sandwich()
<span style="color:#75715e">#outputs:</span>
<span style="color:#75715e">##tomatoes#</span>
<span style="color:#75715e">#&lt;/&#39;&#39;&#39;&#39;&#39;&#39;\&gt;</span>
<span style="color:#75715e"># --ham--</span>
<span style="color:#75715e">#&lt;\______/&gt;</span>
<span style="color:#75715e"># ~salad~</span>
</code></pre></div><h1 id="5-回答题主问题略">5. 回答题主问题，略</h1>
<h1 id="6-给装饰器函数传参passing-arguments-to-the-decorated-function">6. 给装饰器函数传参（Passing arguments to the decorated function）</h1>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># 这不是什么黑色魔法(black magic)，你只是必须让wrapper传递参数:</span>
 
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">a_decorator_passing_arguments</span>(function_to_decorate):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">a_wrapper_accepting_arguments</span>(arg1, arg2):
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;I got args! Look:&#34;</span>, arg1, arg2
        function_to_decorate(arg1, arg2)
    <span style="color:#66d9ef">return</span> a_wrapper_accepting_arguments
 
<span style="color:#75715e"># 当你调用装饰器返回的函数式，你就在调用wrapper，而给wrapper的</span>
<span style="color:#75715e"># 参数传递将会让它把参数传递给要装饰的函数</span>
 
<span style="color:#a6e22e">@a_decorator_passing_arguments</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">print_full_name</span>(first_name, last_name):
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;My name is&#34;</span>, first_name, last_name
 
print_full_name(<span style="color:#e6db74">&#34;Peter&#34;</span>, <span style="color:#e6db74">&#34;Venkman&#34;</span>)
<span style="color:#75715e"># outputs:</span>
<span style="color:#75715e">#I got args! Look: Peter Venkman</span>
<span style="color:#75715e">#My name is Peter </span>
</code></pre></div><h1 id="7-装饰方法decorating-methods">7. 装饰方法（Decorating methods）</h1>
<p>Python的一个伟大之处在于：方法和函数几乎是一样的(methods and functions are really the same)，除了方法的第一个参数应该是当前对象的引用(也就是 self)。这也就意味着只要记住把 self 考虑在内，你就可以用同样的方法给方法创建装饰器了：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">method_friendly_decorator</span>(method_to_decorate):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>(self, lie):
        lie <span style="color:#f92672">=</span> lie <span style="color:#f92672">-</span> <span style="color:#ae81ff">3</span> <span style="color:#75715e"># very friendly, decrease age even more :-)</span>
        <span style="color:#66d9ef">return</span> method_to_decorate(self, lie)
    <span style="color:#66d9ef">return</span> wrapper
 
 
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Lucy</span>(object):
 
    <span style="color:#66d9ef">def</span> __init__(self):
        self<span style="color:#f92672">.</span>age <span style="color:#f92672">=</span> <span style="color:#ae81ff">32</span>
 
    <span style="color:#a6e22e">@method_friendly_decorator</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sayYourAge</span>(self, lie):
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;I am </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">, what did you think?&#34;</span> <span style="color:#f92672">%</span> (self<span style="color:#f92672">.</span>age <span style="color:#f92672">+</span> lie)
 
l <span style="color:#f92672">=</span> Lucy()
l<span style="color:#f92672">.</span>sayYourAge(<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>)
<span style="color:#75715e">#outputs: I am 26, what did you think?</span>
</code></pre></div><p>当然，如果你想编写一个非常通用的装饰器，可以用来装饰任意函数和方法，你就可以无视具体参数了，直接使用 <code>*args</code>, <code>**kwargs</code> 就行：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">a_decorator_passing_arbitrary_arguments</span>(function_to_decorate):
    <span style="color:#75715e"># The wrapper accepts any arguments</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">a_wrapper_accepting_arbitrary_arguments</span>(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Do I have args?:&#34;</span>
        <span style="color:#66d9ef">print</span> args
        <span style="color:#66d9ef">print</span> kwargs
        <span style="color:#75715e"># Then you unpack the arguments, here *args, **kwargs</span>
        <span style="color:#75715e"># If you are not familiar with unpacking, check:</span>
        <span style="color:#75715e"># http://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/</span>
        function_to_decorate(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
    <span style="color:#66d9ef">return</span> a_wrapper_accepting_arbitrary_arguments
 
<span style="color:#a6e22e">@a_decorator_passing_arbitrary_arguments</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">function_with_no_argument</span>():
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Python is cool, no argument here.&#34;</span>
 
function_with_no_argument()
<span style="color:#75715e">#outputs</span>
<span style="color:#75715e">#Do I have args?:</span>
<span style="color:#75715e">#()</span>
<span style="color:#75715e">#{}</span>
<span style="color:#75715e">#Python is cool, no argument here.</span>
 
<span style="color:#a6e22e">@a_decorator_passing_arbitrary_arguments</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">function_with_arguments</span>(a, b, c):
    <span style="color:#66d9ef">print</span> a, b, c
 
function_with_arguments(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>)
<span style="color:#75715e">#outputs</span>
<span style="color:#75715e">#Do I have args?:</span>
<span style="color:#75715e">#(1, 2, 3)</span>
<span style="color:#75715e">#{}</span>
<span style="color:#75715e">#1 2 3</span>
 
<span style="color:#a6e22e">@a_decorator_passing_arbitrary_arguments</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">function_with_named_arguments</span>(a, b, c, platypus<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Why not ?&#34;</span>):
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Do </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">, </span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> and </span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> like platypus? </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span>\
    (a, b, c, platypus)
 
function_with_named_arguments(<span style="color:#e6db74">&#34;Bill&#34;</span>, <span style="color:#e6db74">&#34;Linus&#34;</span>, <span style="color:#e6db74">&#34;Steve&#34;</span>, platypus<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Indeed!&#34;</span>)
<span style="color:#75715e">#outputs</span>
<span style="color:#75715e">#Do I have args ? :</span>
<span style="color:#75715e">#(&#39;Bill&#39;, &#39;Linus&#39;, &#39;Steve&#39;)</span>
<span style="color:#75715e">#{&#39;platypus&#39;: &#39;Indeed!&#39;}</span>
<span style="color:#75715e">#Do Bill, Linus and Steve like platypus? Indeed!</span>
 
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Mary</span>(object):
 
    <span style="color:#66d9ef">def</span> __init__(self):
        self<span style="color:#f92672">.</span>age <span style="color:#f92672">=</span> <span style="color:#ae81ff">31</span>
 
    <span style="color:#a6e22e">@a_decorator_passing_arbitrary_arguments</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sayYourAge</span>(self, lie<span style="color:#f92672">=-</span><span style="color:#ae81ff">3</span>): <span style="color:#75715e"># You can now add a default value</span>
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;I am </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">, what did you think ?&#34;</span> <span style="color:#f92672">%</span> (self<span style="color:#f92672">.</span>age <span style="color:#f92672">+</span> lie)
 
m <span style="color:#f92672">=</span> Mary()
m<span style="color:#f92672">.</span>sayYourAge()
<span style="color:#75715e">#outputs</span>
<span style="color:#75715e"># Do I have args?:</span>
<span style="color:#75715e">#(&lt;__main__.Mary object at 0xb7d303ac&gt;,)</span>
<span style="color:#75715e">#{}</span>
<span style="color:#75715e">#I am 28, what did you think?</span>
</code></pre></div><h1 id="8-给装饰器传参passing-arguments-to-the-decorator">8. 给装饰器传参（Passing arguments to the decorator）</h1>
<p>太棒了，那么现在对于给装饰器本身传参数，你有什么看法呢？好吧，这样说有点绕，因为装饰器必须接受一个函数作为参数，所以就不能把被装饰的函数的参数，直接传给装饰器（you cannot pass the decorated function arguments directly to the decorator.）</p>
<p>在直奔答案之前，我们先写一个小提示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Decorators are ORDINARY functions</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">my_decorator</span>(func):
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;I am a ordinary function&#34;</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>():
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;I am function returned by the decorator&#34;</span>
        func()
    <span style="color:#66d9ef">return</span> wrapper
 
<span style="color:#75715e"># Therefore, you can call it without any &#34;@&#34;</span>
 
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lazy_function</span>():
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;zzzzzzzz&#34;</span>
 
decorated_function <span style="color:#f92672">=</span> my_decorator(lazy_function)
<span style="color:#75715e">#outputs: I am a ordinary function</span>
 
<span style="color:#75715e"># It outputs &#34;I am a ordinary function&#34;, because that&#39;s just what you do:</span>
<span style="color:#75715e"># calling a function. Nothing magic.</span>
 
<span style="color:#a6e22e">@my_decorator</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lazy_function</span>():
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;zzzzzzzz&#34;</span>
 
<span style="color:#75715e">#outputs: I am a ordinary function</span>
</code></pre></div><p>这完全一样，都是 <code>my_decorator</code> 被调用。所以当你使用 <code>@my_decorator</code> 时，你在告诉 python 去调用 “被变量 <code>my_decorator</code> 标记的” 函数（the function &lsquo;labeled by the variable &ldquo;my_decorator&rdquo;'）。这很重要，因为你给的这个标签能直接指向装饰器。。。或者其他！让我们开始变得邪恶！（Let&rsquo;s start to be evil!）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decorator_maker</span>():
 
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;I make decorators! I am executed only once: &#34;</span><span style="color:#f92672">+</span>\
          <span style="color:#e6db74">&#34;when you make me create a decorator.&#34;</span>
 
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">my_decorator</span>(func):
 
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;I am a decorator! I am executed only when you decorate a function.&#34;</span>
 
        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapped</span>():
            <span style="color:#66d9ef">print</span> (<span style="color:#e6db74">&#34;I am the wrapper around the decorated function. &#34;</span>
                  <span style="color:#e6db74">&#34;I am called when you call the decorated function. &#34;</span>
                  <span style="color:#e6db74">&#34;As the wrapper, I return the RESULT of the decorated function.&#34;</span>)
            <span style="color:#66d9ef">return</span> func()
 
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;As the decorator, I return the wrapped function.&#34;</span>
 
        <span style="color:#66d9ef">return</span> wrapped
 
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;As a decorator maker, I return a decorator&#34;</span>
    <span style="color:#66d9ef">return</span> my_decorator
 
<span style="color:#75715e"># Let&#39;s create a decorator. It&#39;s just a new function after all.</span>
new_decorator <span style="color:#f92672">=</span> decorator_maker()      
<span style="color:#75715e">#outputs:</span>
<span style="color:#75715e">#I make decorators! I am executed only once: when you make me create a decorator.</span>
<span style="color:#75715e">#As a decorator maker, I return a decorator</span>
 
<span style="color:#75715e"># Then we decorate the function</span>
 
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decorated_function</span>():
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;I am the decorated function.&#34;</span>
 
decorated_function <span style="color:#f92672">=</span> new_decorator(decorated_function)
<span style="color:#75715e">#outputs:</span>
<span style="color:#75715e">#I am a decorator! I am executed only when you decorate a function.</span>
<span style="color:#75715e">#As the decorator, I return the wrapped function</span>
 
<span style="color:#75715e"># Let&#39;s call the function:</span>
decorated_function()
<span style="color:#75715e">#outputs:</span>
<span style="color:#75715e">#I am the wrapper around the decorated function. I am called when you call the decorated function.</span>
<span style="color:#75715e">#As the wrapper, I return the RESULT of the decorated function.</span>
<span style="color:#75715e">#I am the decorated function.</span>
</code></pre></div><p>不要感到惊讶，让我们做一件完全一样的事情，只不过跳过了中间变量：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decorated_function</span>():
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;I am the decorated function.&#34;</span>
decorated_function <span style="color:#f92672">=</span> decorator_maker()(decorated_function)
<span style="color:#75715e">#outputs:</span>
<span style="color:#75715e">#I make decorators! I am executed only once: when you make me create a decorator.</span>
<span style="color:#75715e">#As a decorator maker, I return a decorator</span>
<span style="color:#75715e">#I am a decorator! I am executed only when you decorate a function.</span>
<span style="color:#75715e">#As the decorator, I return the wrapped function.</span>
 
<span style="color:#75715e"># Finally:</span>
decorated_function()   
<span style="color:#75715e">#outputs:</span>
<span style="color:#75715e">#I am the wrapper around the decorated function. I am called when you call the decorated function.</span>
<span style="color:#75715e">#As the wrapper, I return the RESULT of the decorated function.</span>
<span style="color:#75715e">#I am the decorated function.</span>
</code></pre></div><p>再做一次，代码甚至更短：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a6e22e">@decorator_maker</span>()
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decorated_function</span>():
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;I am the decorated function.&#34;</span>
<span style="color:#75715e">#outputs:</span>
<span style="color:#75715e">#I make decorators! I am executed only once: when you make me create a decorator.</span>
<span style="color:#75715e">#As a decorator maker, I return a decorator</span>
<span style="color:#75715e">#I am a decorator! I am executed only when you decorate a function.</span>
<span style="color:#75715e">#As the decorator, I return the wrapped function.</span>
 
<span style="color:#75715e">#Eventually:</span>
decorated_function()   
<span style="color:#75715e">#outputs:</span>
<span style="color:#75715e">#I am the wrapper around the decorated function. I am called when you call the decorated function.</span>
<span style="color:#75715e">#As the wrapper, I return the RESULT of the decorated function.</span>
<span style="color:#75715e">#I am the decorated function.</span>
</code></pre></div><p>嘿，看到了吗？我们在用 <code>@</code> 语法调用了函数 ：-）
那么回到带参数的装饰器。如果我们能够使用一个函数动态（on the fly）的生成装饰器，那么我们就能把参数传递给那个函数，对吗？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decorator_maker_with_arguments</span>(decorator_arg1, decorator_arg2):
 
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;I make decorators! And I accept arguments:&#34;</span>, decorator_arg1, decorator_arg2
 
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">my_decorator</span>(func):
        <span style="color:#75715e"># 在这里能传参数是一个来自闭包的馈赠.</span>
        <span style="color:#75715e"># 如果你对闭包感到不舒服，你可以直接忽略（you can assume it&#39;s ok）,</span>
        <span style="color:#75715e"># 或者看看这里: http://stackoverflow.com/questions/13857/can-you-explain-closures-as-they-relate-to-python</span>
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;I am the decorator. Somehow you passed me arguments:&#34;</span>, decorator_arg1, decorator_arg2
 
        <span style="color:#75715e"># 不要把装饰器参数和函数参数搞混了！</span>
        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapped</span>(function_arg1, function_arg2) :
            <span style="color:#66d9ef">print</span> (<span style="color:#e6db74">&#34;I am the wrapper around the decorated function.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
                  <span style="color:#e6db74">&#34;I can access all the variables</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
                  <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">- from the decorator: {0} {1}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
                  <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">- from the function call: {2} {3}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
                  <span style="color:#e6db74">&#34;Then I can pass them to the decorated function&#34;</span>
                  <span style="color:#f92672">.</span>format(decorator_arg1, decorator_arg2,
                          function_arg1, function_arg2))
            <span style="color:#66d9ef">return</span> func(function_arg1, function_arg2)
 
        <span style="color:#66d9ef">return</span> wrapped
 
    <span style="color:#66d9ef">return</span> my_decorator
 
<span style="color:#a6e22e">@decorator_maker_with_arguments</span>(<span style="color:#e6db74">&#34;Leonard&#34;</span>, <span style="color:#e6db74">&#34;Sheldon&#34;</span>)
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decorated_function_with_arguments</span>(function_arg1, function_arg2):
    <span style="color:#66d9ef">print</span> (<span style="color:#e6db74">&#34;I am the decorated function and only knows about my arguments: {0}&#34;</span>
           <span style="color:#e6db74">&#34; {1}&#34;</span><span style="color:#f92672">.</span>format(function_arg1, function_arg2))
 
decorated_function_with_arguments(<span style="color:#e6db74">&#34;Rajesh&#34;</span>, <span style="color:#e6db74">&#34;Howard&#34;</span>)
<span style="color:#75715e">#outputs:</span>
<span style="color:#75715e">#I make decorators! And I accept arguments: Leonard Sheldon</span>
<span style="color:#75715e">#I am the decorator. Somehow you passed me arguments: Leonard Sheldon</span>
<span style="color:#75715e">#I am the wrapper around the decorated function.</span>
<span style="color:#75715e">#I can access all the variables</span>
<span style="color:#75715e">#   - from the decorator: Leonard Sheldon</span>
<span style="color:#75715e">#   - from the function call: Rajesh Howard</span>
<span style="color:#75715e">#Then I can pass them to the decorated function</span>
<span style="color:#75715e">#I am the decorated function and only knows about my arguments: Rajesh Howard</span>
</code></pre></div><p>这就是了，带参数的装饰器。参数也可以设置为变量：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">c1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Penny&#34;</span>
c2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Leslie&#34;</span>
 
<span style="color:#a6e22e">@decorator_maker_with_arguments</span>(<span style="color:#e6db74">&#34;Leonard&#34;</span>, c1)
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decorated_function_with_arguments</span>(function_arg1, function_arg2):
    <span style="color:#66d9ef">print</span> (<span style="color:#e6db74">&#34;I am the decorated function and only knows about my arguments:&#34;</span>
           <span style="color:#e6db74">&#34; {0} {1}&#34;</span><span style="color:#f92672">.</span>format(function_arg1, function_arg2))
 
decorated_function_with_arguments(c2, <span style="color:#e6db74">&#34;Howard&#34;</span>)
<span style="color:#75715e">#outputs:</span>
<span style="color:#75715e">#I make decorators! And I accept arguments: Leonard Penny</span>
<span style="color:#75715e">#I am the decorator. Somehow you passed me arguments: Leonard Penny</span>
<span style="color:#75715e">#I am the wrapper around the decorated function.</span>
<span style="color:#75715e">#I can access all the variables</span>
<span style="color:#75715e">#   - from the decorator: Leonard Penny</span>
<span style="color:#75715e">#   - from the function call: Leslie Howard</span>
<span style="color:#75715e">#Then I can pass them to the decorated function</span>
<span style="color:#75715e">#I am the decorated function and only knows about my arguments: Leslie Howard</span>
</code></pre></div><p>如你所见，你可以给装饰器传递参数，就好像其他任意一个使用了这种把戏的函数一样（you can pass arguments to the decorator like any function using this trick. ）。如果你愿意，甚至可以使用 <code>*args</code>, <code>**kwargs</code>。但是，记住，装置器只调用一次，仅当python导入这个脚本时。你不能在之后动态的设置参数（You can&rsquo;t dynamically set the arguments afterwards.）。当你执行 <code>import x</code> 时，这个函数已经被装饰了，因此你不能修改任何东西。</p>
<h1 id="9-实践装饰器装饰一个装饰器lets-practice-a-decorator-to-decorate-a-decorator">9. 实践：装饰器装饰一个装饰器（Let&rsquo;s practice: a decorator to decorate a decorator）</h1>
<p>OK，作为一个福利，我将展示一段能用来创建能接受通用的任意参数的装饰器的代码（I&rsquo;ll give you a snippet to make any decorator accept generically any argument. ）。毕竟，为了能接受参数，我们用了另一个函数来创建我们的装饰器。我们包装了装饰器。在我们刚刚看到的东西里，还有用来包装函数的吗？是的，就是装饰器。让我们给装饰器写一个装饰器来玩玩：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decorator_with_args</span>(decorator_to_enhance):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    This function is supposed to be used as a decorator.
</span><span style="color:#e6db74">    It must decorate an other function, that is intended to be used as a decorator.
</span><span style="color:#e6db74">    Take a cup of coffee.
</span><span style="color:#e6db74">    It will allow any decorator to accept an arbitrary number of arguments,
</span><span style="color:#e6db74">    saving you the headache to remember how to do that every time.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
 
    <span style="color:#75715e"># We use the same trick we did to pass arguments</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decorator_maker</span>(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
 
        <span style="color:#75715e"># We create on the fly a decorator that accepts only a function</span>
        <span style="color:#75715e"># but keeps the passed arguments from the maker.</span>
        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decorator_wrapper</span>(func):
 
            <span style="color:#75715e"># We return the result of the original decorator, which, after all,</span>
            <span style="color:#75715e"># IS JUST AN ORDINARY FUNCTION (which returns a function).</span>
            <span style="color:#75715e"># Only pitfall: the decorator must have this specific signature or it won&#39;t work:</span>
            <span style="color:#66d9ef">return</span> decorator_to_enhance(func, <span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
 
        <span style="color:#66d9ef">return</span> decorator_wrapper
 
    <span style="color:#66d9ef">return</span> decorator_maker
</code></pre></div><p>它可以像这样使用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># You create the function you will use as a decorator. And stick a decorator on it :-)</span>
<span style="color:#75715e"># Don&#39;t forget, the signature is &#34;decorator(func, *args, **kwargs)&#34;</span>
<span style="color:#a6e22e">@decorator_with_args</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decorated_decorator</span>(func, <span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>(function_arg1, function_arg2):
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Decorated with&#34;</span>, args, kwargs
        <span style="color:#66d9ef">return</span> func(function_arg1, function_arg2)
    <span style="color:#66d9ef">return</span> wrapper
 
<span style="color:#75715e"># Then you decorate the functions you wish with your brand new decorated decorator.</span>
 
<span style="color:#a6e22e">@decorated_decorator</span>(<span style="color:#ae81ff">42</span>, <span style="color:#ae81ff">404</span>, <span style="color:#ae81ff">1024</span>)
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decorated_function</span>(function_arg1, function_arg2):
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Hello&#34;</span>, function_arg1, function_arg2
 
decorated_function(<span style="color:#e6db74">&#34;Universe and&#34;</span>, <span style="color:#e6db74">&#34;everything&#34;</span>)
<span style="color:#75715e">#outputs:</span>
<span style="color:#75715e">#Decorated with (42, 404, 1024) {}</span>
<span style="color:#75715e">#Hello Universe and everything</span>
 
<span style="color:#75715e"># Whoooot!</span>
</code></pre></div><p>我知道，你上一次有这种感觉，是在听一个人说“在理解递归之前，你必须先理解递归”之后。但是现在，掌握之后，你不觉得很爽吗？</p>
<h1 id="10-装饰器最佳实践best-practices-while-using-decorators">10. 装饰器最佳实践（Best practices while using decorators）</h1>
<ul>
<li>装饰器是在 python 2.4 之后才有的，所以先确定你的代码运行时；</li>
<li>记住这点：装饰器降低了函数调用效率；</li>
<li>你不能“解装饰”一个函数（You can not un-decorate a function. ）。有一些能用来创建可以移除的装饰器的方法（There are hacks to create decorators that can be removed），但没人用它们。所以一个函数一旦被装饰了，就结束了（不能改变了）。<strong>For all the code.</strong></li>
<li>装饰器包装了函数，这使得会难以调试。</li>
</ul>
<p>Python 2.5 通过提供了一个 <code>functools</code> 模块解决了最后一个问题。<code>functools.wraps</code> 把任意被包装函数的函数名、模块名和 docstring 拷贝给了 <code>wrapper</code>. 有趣的事是，<code>functools.wraps</code> 也是一个装饰器：-）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># For debugging, the stacktrace prints you the function __name__</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">foo</span>():
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;foo&#34;</span>
 
<span style="color:#66d9ef">print</span> foo<span style="color:#f92672">.</span>__name__
<span style="color:#75715e">#outputs: foo</span>
 
<span style="color:#75715e"># With a decorator, it gets messy   </span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bar</span>(func):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>():
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;bar&#34;</span>
        <span style="color:#66d9ef">return</span> func()
    <span style="color:#66d9ef">return</span> wrapper
 
<span style="color:#a6e22e">@bar</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">foo</span>():
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;foo&#34;</span>
 
<span style="color:#66d9ef">print</span> foo<span style="color:#f92672">.</span>__name__
<span style="color:#75715e">#outputs: wrapper</span>
 
<span style="color:#75715e"># &#34;functools&#34; can help for that</span>
 
<span style="color:#f92672">import</span> functools
 
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bar</span>(func):
    <span style="color:#75715e"># We say that &#34;wrapper&#34;, is wrapping &#34;func&#34;</span>
    <span style="color:#75715e"># and the magic begins</span>
    <span style="color:#a6e22e">@functools.wraps</span>(func)
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>():
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;bar&#34;</span>
        <span style="color:#66d9ef">return</span> func()
    <span style="color:#66d9ef">return</span> wrapper
</code></pre></div><h1 id="11-装饰器如何才能有用how-can-the-decorators-be-useful">11. 装饰器如何才能有用（How can the decorators be useful?）</h1>
<p>现在问题来了：我能用装饰器来干嘛？看起来很酷也很强大，但是来一个实际例子才更好。好吧，有1000中可能性（Well, there are 1000 possibilities.）。一个典型的用途是，用来扩展一个外部导入的函数（你不能修改）的行为，或者为了调试（你不想修改这个函数，因为只是暂时的）。你也可以用装饰器实现只用一段相同的代码来扩展成几个不同的函数，而且你不需要每次都重写这段代码。这样就是常说的 DRY。比如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">benchmark</span>(func):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    A decorator that prints the time a function takes
</span><span style="color:#e6db74">    to execute.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    <span style="color:#f92672">import</span> time
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
        t <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>clock()
        res <span style="color:#f92672">=</span> func(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
        <span style="color:#66d9ef">print</span> func<span style="color:#f92672">.</span>__name__, time<span style="color:#f92672">.</span>clock()<span style="color:#f92672">-</span>t
        <span style="color:#66d9ef">return</span> res
    <span style="color:#66d9ef">return</span> wrapper
 
 
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">logging</span>(func):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    A decorator that logs the activity of the script.
</span><span style="color:#e6db74">    (it actually just prints it, but it could be logging!)
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
        res <span style="color:#f92672">=</span> func(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
        <span style="color:#66d9ef">print</span> func<span style="color:#f92672">.</span>__name__, args, kwargs
        <span style="color:#66d9ef">return</span> res
    <span style="color:#66d9ef">return</span> wrapper
 
 
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">counter</span>(func):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    A decorator that counts and prints the number of times a function has been executed
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
        wrapper<span style="color:#f92672">.</span>count <span style="color:#f92672">=</span> wrapper<span style="color:#f92672">.</span>count <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
        res <span style="color:#f92672">=</span> func(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;{0} has been used: {1}x&#34;</span><span style="color:#f92672">.</span>format(func<span style="color:#f92672">.</span>__name__, wrapper<span style="color:#f92672">.</span>count)
        <span style="color:#66d9ef">return</span> res
    wrapper<span style="color:#f92672">.</span>count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">return</span> wrapper
 
<span style="color:#a6e22e">@counter</span>
<span style="color:#a6e22e">@benchmark</span>
<span style="color:#a6e22e">@logging</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">reverse_string</span>(string):
    <span style="color:#66d9ef">return</span> str(reversed(string))
 
<span style="color:#66d9ef">print</span> reverse_string(<span style="color:#e6db74">&#34;Able was I ere I saw Elba&#34;</span>)
<span style="color:#66d9ef">print</span> reverse_string(<span style="color:#e6db74">&#34;A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!&#34;</span>)
 
<span style="color:#75715e">#outputs:</span>
<span style="color:#75715e">#reverse_string (&#39;Able was I ere I saw Elba&#39;,) {}</span>
<span style="color:#75715e">#wrapper 0.0</span>
<span style="color:#75715e">#wrapper has been used: 1x</span>
<span style="color:#75715e">#ablE was I ere I saw elbA</span>
<span style="color:#75715e">#reverse_string (&#39;A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!&#39;,) {}</span>
<span style="color:#75715e">#wrapper 0.0</span>
<span style="color:#75715e">#wrapper has been used: 2x</span>
<span style="color:#75715e">#!amanaP :lanac a ,noep a ,stah eros ,raj a ,hsac ,oloR a ,tur a ,mapS ,snip ,eperc a ,)lemac a ro( niaga gab ananab a ,gat a ,nat a ,gab ananab a ,gag a ,inoracam ,elacrep ,epins ,spam ,arutaroloc a ,shajar ,soreh ,atsap ,eonac a ,nalp a ,nam A</span>

<span style="color:#960050;background-color:#1e0010">当然，装饰器的好处就是你可以几乎用来装饰所有东西，而且不要重写。也就是我说的</span> DRY<span style="color:#960050;background-color:#1e0010">：（</span>Of course the good thing <span style="color:#66d9ef">with</span> decorators <span style="color:#f92672">is</span> that you can use them right away on almost anything without rewriting<span style="color:#f92672">.</span> DRY, I said:<span style="color:#960050;background-color:#1e0010">）</span>

:::python
<span style="color:#a6e22e">@counter</span>
<span style="color:#a6e22e">@benchmark</span>
<span style="color:#a6e22e">@logging</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_random_futurama_quote</span>():
    <span style="color:#f92672">import</span> httplib
    conn <span style="color:#f92672">=</span> httplib<span style="color:#f92672">.</span>HTTPConnection(<span style="color:#e6db74">&#34;slashdot.org:80&#34;</span>)
    conn<span style="color:#f92672">.</span>request(<span style="color:#e6db74">&#34;HEAD&#34;</span>, <span style="color:#e6db74">&#34;/index.html&#34;</span>)
    <span style="color:#66d9ef">for</span> key, value <span style="color:#f92672">in</span> conn<span style="color:#f92672">.</span>getresponse()<span style="color:#f92672">.</span>getheaders():
        <span style="color:#66d9ef">if</span> key<span style="color:#f92672">.</span>startswith(<span style="color:#e6db74">&#34;x-b&#34;</span>) <span style="color:#f92672">or</span> key<span style="color:#f92672">.</span>startswith(<span style="color:#e6db74">&#34;x-f&#34;</span>):
            <span style="color:#66d9ef">return</span> value
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;No, I&#39;m ... doesn&#39;t!&#34;</span>
 
<span style="color:#66d9ef">print</span> get_random_furturama_quote()
<span style="color:#66d9ef">print</span> get_random_furturama_quote()
 
<span style="color:#75715e">#outputs:</span>
<span style="color:#75715e">#get_random_futurama_quote () {}</span>
<span style="color:#75715e">#wrapper 0.02</span>
<span style="color:#75715e">#wrapper has been used: 1x</span>
<span style="color:#75715e">#The laws of science be a harsh mistress.</span>
<span style="color:#75715e">#get_random_futurama_quote () {}</span>
<span style="color:#75715e">#wrapper 0.01</span>
<span style="color:#75715e">#wrapper has been used: 2x</span>
<span style="color:#75715e">#Curse you, merciful Poseidon!</span>
</code></pre></div><p>Python 语言本身也提供了一些装饰器：<code>property</code>、<code>staticmethod</code> 等。Django 用装饰器来管理换成和视图权限。Twisted 用来伪装 内联异步函数调用（Twisted to fake inlining asynchronous functions calls. ）。这确实是一片广阔的天地。（This really is a large playground.）</p></div>
					</article>
					
					<section id="comment">
					    <h1 class="title">Comments</h1>
					    <div id="disqus_thread" aria-live="polite"><script type="text/javascript">
var disqus_shortname = "liyangliang";
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>
getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
getElementsByTagName('BODY')[0]).appendChild(s); }());
</script>
getElementsByTagName('BODY')[0]).appendChild(s); }());
</script>


<script type="text/javascript">
    var disqus_shortname = "liyangliang";
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
ript">comments powered by Disqus.</a></noscript>
</div>
					</section>
					
				    </div>
				</div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2020

    Yangliang Li

Design credit: <a href="https://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
<script src="https://liyangliang.me/js/slash.js"></script>
<script src="https://liyangliang.me/js/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script>
</footer>
		</div>
	</div>
	
</body>
</html>
