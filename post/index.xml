<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Posts on 李林克斯 </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://deanthompson.github.io/post/</link>
    <language>zh-CN</language>
    <author>Yangliang Li</author>
    
    <updated>Wed, 30 Mar 2016 23:02:51 CST</updated>
    
    <item>
      <title>zhihu-go 源码解析：用 goquery 解析 HTML</title>
      <link>http://deanthompson.github.io/posts/2016/03/zhihu-go-insight-parsing-html-with-goquery</link>
      <pubDate>Wed, 30 Mar 2016 23:02:51 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2016/03/zhihu-go-insight-parsing-html-with-goquery</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://deanthompson.github.io/posts/2016/03/zhihu-go/&#34;&gt;上一篇博客&lt;/a&gt; 简单介绍了 &lt;a href=&#34;https://github.com/DeanThompson/zhihu-go&#34;&gt;zhihu-go&lt;/a&gt; 项目的缘起，本篇简单介绍一下关于处理 HTML 的细节。&lt;/p&gt;

&lt;p&gt;因为知乎没有开发 API，所以只能通过模拟浏览器操作的方式获取数据，这些数据有两种格式：普通的 HTML 文档和某些 Ajax 接口返回的 JSON（返回的数据实际上也是 HTML）。其实也就是爬虫了，抓取网页，然后提取数据。一般来说从 HTML 文档提取数据有这些做法：正则、XPath、CSS 选择器等。对我来说，正则写起来比较复杂，代码可读性差而且维护起来麻烦；XPath 没有详细了解，不过用起来应该不难，而且 Chrome 浏览器可以直接提取 XPath. zhihu-go 里用的是选择器的方式，使用了 &lt;a href=&#34;https://github.com/PuerkitoBio/goquery&#34;&gt;goquery&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;goquery 是 &amp;ldquo;a little like that j-thing, only in Go&amp;rdquo;，也就是用 jQuery 的方式去操作 DOM. jQuery 大家都很熟，API 也很简单明了。本文不详细介绍 goquery，下面选几个场景（API）讲讲在 zhihu-go 里的应用。&lt;/p&gt;

&lt;h3 id=&#34;创建-document-对象:b21917a396369c0669213bf730deae3f&#34;&gt;创建 Document 对象&lt;/h3&gt;

&lt;p&gt;goquery 暴露了两个结构体：&lt;code&gt;Document&lt;/code&gt; 和 &lt;code&gt;Selection&lt;/code&gt;. &lt;code&gt;Document&lt;/code&gt; 表示一个 HTML 文档，&lt;code&gt;Selection&lt;/code&gt; 用于像 jQuery 一样操作，支持链式调用。goquery 需要指定一个 HTML 文档才能继续后续的操作，有以下几个构造方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NewDocumentFromNode(root *html.Node) *Document&lt;/code&gt;: 传入 &lt;code&gt;*html.Node&lt;/code&gt; 对象，也就是根节点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NewDocument(url string) (*Document, error)&lt;/code&gt;: 传入 URL，内部用 &lt;code&gt;http.Get&lt;/code&gt; 获取网页。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NewDocumentFromReader(r io.Reader) (*Document, error)&lt;/code&gt;: 传入 &lt;code&gt;io.Reader&lt;/code&gt;，内部从 reader 中读取内容并解析。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NewDocumentFromResponse(res *http.Response) (*Document, error)&lt;/code&gt;: 传入 HTTP 响应，内部拿到 &lt;code&gt;res.Body&lt;/code&gt;(实现了 &lt;code&gt;io.Reader&lt;/code&gt;) 后的处理方式类似 &lt;code&gt;NewDocumentFromReader&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为知乎的页面需要登录才能访问（还需要伪造请求头），而且我们并不想手动解析 HTML 来获取 &lt;code&gt;*html.Node&lt;/code&gt;，最后用到了另外两个构造方法。大致的使用场景是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;请求 HTML 页面（如问题页面），调用 &lt;code&gt;NewDocumentFromResponse&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;请求 Ajax 接口，返回的 JSON 数据里是一些 HTML 片段，用 &lt;code&gt;NewDocumentFromReader&lt;/code&gt;，其中 &lt;code&gt;r = strings.NewReader(html)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了方便举例说明，下文采用这个定义: &lt;code&gt;var doc *goquery.Document&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;查找到指定节点:b21917a396369c0669213bf730deae3f&#34;&gt;查找到指定节点&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Selection&lt;/code&gt; 有一系列类似 jQuery 的方法，&lt;code&gt;Document&lt;/code&gt; 结构体内嵌了 &lt;code&gt;*Selection&lt;/code&gt;，因此也能直接调用这些方法。主要的方法是 &lt;code&gt;Selection.Find(selector string)&lt;/code&gt;，传入一个选择器，返回一个新的，匹配到的 &lt;code&gt;*Selection&lt;/code&gt;，所以能够链式调用。&lt;/p&gt;

&lt;p&gt;比如在用户主页（如 &lt;a href=&#34;https://www.zhihu.com/people/jixin&#34;&gt;黄继新&lt;/a&gt;），要获取用户的 BIO. 首先用 Chrome 定位到对应的 HTML：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;span class=&amp;quot;bio&amp;quot; title=&amp;quot;和知乎在一起&amp;quot;&amp;gt;和知乎在一起&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的 go 代码就是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;doc.Find(&amp;quot;span.bio&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一个选择器对应多个结果，可以使用 &lt;code&gt;First()&lt;/code&gt;, &lt;code&gt;Last()&lt;/code&gt;, &lt;code&gt;Eq(index int)&lt;/code&gt;, &lt;code&gt;Slice(start, end int)&lt;/code&gt; 这些方法进一步定位。&lt;/p&gt;

&lt;p&gt;还是在用户主页，在用户资料栏的底下，从左往右展示了提问数、回答数、文章数、收藏数和公共编辑的次数。查看 HTML 源码后发现这几项的 class 是一样的，所以只能通过下标索引来区分。&lt;/p&gt;

&lt;p&gt;先看 HTML 源码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;profile-navbar clearfix&amp;quot;&amp;gt;
&amp;lt;a class=&amp;quot;item &amp;quot; href=&amp;quot;/people/jixin/asks&amp;quot;&amp;gt;提问&amp;lt;span class=&amp;quot;num&amp;quot;&amp;gt;1336&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;a class=&amp;quot;item &amp;quot; href=&amp;quot;/people/jixin/answers&amp;quot;&amp;gt;回答&amp;lt;span class=&amp;quot;num&amp;quot;&amp;gt;785&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;a class=&amp;quot;item &amp;quot; href=&amp;quot;/people/jixin/posts&amp;quot;&amp;gt;文章&amp;lt;span class=&amp;quot;num&amp;quot;&amp;gt;91&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;a class=&amp;quot;item &amp;quot; href=&amp;quot;/people/jixin/collections&amp;quot;&amp;gt;收藏&amp;lt;span class=&amp;quot;num&amp;quot;&amp;gt;44&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;a class=&amp;quot;item &amp;quot; href=&amp;quot;/people/jixin/logs&amp;quot;&amp;gt;公共编辑&amp;lt;span class=&amp;quot;num&amp;quot;&amp;gt;51648&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要定位找到回答数，对应的 go 代码是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;doc.Find(&amp;quot;div.profile-navbar&amp;quot;).Find(&amp;quot;span.num&amp;quot;).Eq(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;属性操作:b21917a396369c0669213bf730deae3f&#34;&gt;属性操作&lt;/h3&gt;

&lt;p&gt;经常需要获取一个标签的内容和某些属性值，使用 goquery 可以很容易做到。&lt;/p&gt;

&lt;p&gt;继续上面获取回答数的例子，用 &lt;code&gt;Text() string&lt;/code&gt; 方法可以获取标签内的文本内容，其中包含所有子标签。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;text := doc.Find(&amp;quot;div.profile-navbar&amp;quot;).Find(&amp;quot;span.num&amp;quot;).Eq(1).Text()    // &amp;quot;785&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，&lt;code&gt;Text()&lt;/code&gt; 方法返回的字符串，可能前后有很多空白字符，可以视情况做清除。&lt;/p&gt;

&lt;p&gt;获取属性值也很容易，有两个方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Attr(attrName string) (val string, exists bool)&lt;/code&gt;: 返回属性值和该属性是否存在，类似从 &lt;code&gt;map&lt;/code&gt; 中取值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AttrOr(attrName, defaultValue string) string&lt;/code&gt;: 和上一个方法类似，区别在于如果属性不存在，则返回给定的默认值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;常见的使用场景就是获取一个 a 标签的链接。继续上面获取回答的例子，如果想要得到用户回答的主页，可以这么做：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;href, _ := doc.Find(&amp;quot;div.profile-navbar&amp;quot;).Find(&amp;quot;a.item&amp;quot;).Eq(1).Attr(&amp;quot;href&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有其他设置属性、操作 class 的方法，就不展开讨论了。&lt;/p&gt;

&lt;h3 id=&#34;迭代:b21917a396369c0669213bf730deae3f&#34;&gt;迭代&lt;/h3&gt;

&lt;p&gt;很多场景需要返回列表数据，比如问题的关注者列表、所有回答，某个答案的点赞的用户列表等。这种情况下一般需要用到迭代，遍历所有的同类节点，做某些操作。&lt;/p&gt;

&lt;p&gt;goquery 提供了三个用于迭代的方法，都接受一个匿名函数作为参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Each(f func(int, *Selection)) *Selection&lt;/code&gt;: 其中函数 &lt;code&gt;f&lt;/code&gt; 的第一个参数是当前的下标，第二个参数是当前的节点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EachWithBreak(f func(int, *Selection) bool) *Selection&lt;/code&gt;: 和 &lt;code&gt;Each&lt;/code&gt; 类似，增加了中途跳出循环的能力，当 &lt;code&gt;f&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 时结束迭代&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Map(f func(int, *Selection) string) (result []string)&lt;/code&gt;: &lt;code&gt;f&lt;/code&gt; 的参数与上面一样，返回一个 string 类型，最终返回 []string.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比如获取一个收藏夹（如 &lt;a href=&#34;https://www.zhihu.com/collection/19573315&#34;&gt;黄继新的收藏：关于知乎的思考&lt;/a&gt;）下所有的问题，可以这么做（见 &lt;a href=&#34;https://github.com/DeanThompson/zhihu-go/blob/master/collection.go&#34;&gt;zhihu-go/collections.go&lt;/a&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func getQuestionsFromDoc(doc *goquery.Document) []*Question {
	questions := make([]*Question, 0, pageSize)
	items := doc.Find(&amp;quot;div#zh-list-answer-wrap&amp;quot;).Find(&amp;quot;h2.zm-item-title&amp;quot;)
	items.Each(func(index int, sel *goquery.Selection) {
		a := sel.Find(&amp;quot;a&amp;quot;)
		qTitle := strip(a.Text())
		qHref, _ := a.Attr(&amp;quot;href&amp;quot;)
		thisQuestion := NewQuestion(makeZhihuLink(qHref), qTitle)
		questions = append(questions, thisQuestion)
	})
	return questions
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;EachWithBreak&lt;/code&gt; 在 zhihu-go 中也有用到，可以参见 &lt;code&gt;Answer.GetVotersN 方法&lt;/code&gt;：&lt;a href=&#34;https://github.com/DeanThompson/zhihu-go/blob/master/answer.go&#34;&gt;zhihu-go/answer.go&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;删除节点-插入-html-导出-html:b21917a396369c0669213bf730deae3f&#34;&gt;删除节点、插入 HTML、导出 HTML&lt;/h3&gt;

&lt;p&gt;有一个需求是把回答内容输出到 HTML，说白了其实就是修复和清洗 HTML，具体的细节可以看 &lt;a href=&#34;https://github.com/DeanThompson/zhihu-go/blob/master/answer.go#L222&#34;&gt;answer.go 里的 answerSelectionToHtml 函数&lt;/a&gt;. 其中用到了一些需要修改文档的操作。&lt;/p&gt;

&lt;p&gt;比如，调用 &lt;code&gt;Remove()&lt;/code&gt; 方法把一个节点删掉：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;sel.Find(&amp;quot;noscript&amp;quot;).Each(func(_ int, tag *goquery.Selection) {
    tag.Remove() // 把无用的 noscript 去掉
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在节点后插入一段 HTML:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;sel.Find(&amp;quot;img&amp;quot;).Each(func(_ int, tag *goquery.Selection) {
    var src string
    if tag.HasClass(&amp;quot;origin_image&amp;quot;) {
        src, _ = tag.Attr(&amp;quot;data-original&amp;quot;)
    } else {
        src, _ = tag.Attr(&amp;quot;data-actualsrc&amp;quot;)
    }
    tag.SetAttr(&amp;quot;src&amp;quot;, src)
    if tag.Next().Size() == 0 {
        tag.AfterHtml(&amp;quot;&amp;lt;br&amp;gt;&amp;quot;)   // 在 img 标签后插入一个换行
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在标签尾部 append 一段内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;wrapper := `&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;`
doc, _ := goquery.NewDocumentFromReader(strings.NewReader(wrapper))
doc.Find(&amp;quot;body&amp;quot;).AppendSelection(sel)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终输出为 html 文档：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;html, err := doc.Html()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结:b21917a396369c0669213bf730deae3f&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;上面的例子基本涵盖了 zhihu-go 中关于 HTML 操作的场景，得益于 goquery 和 jQuery 的 API 风格，实现起来还是非常简单的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>zhihu-go: 知乎非官方 API库 with Go</title>
      <link>http://deanthompson.github.io/posts/2016/03/zhihu-go</link>
      <pubDate>Mon, 28 Mar 2016 23:35:58 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2016/03/zhihu-go</guid>
      <description>&lt;p&gt;我是知乎重度用户，每天都会花点时间在知乎上面看点东西。有段时间时间线里经常出现爬虫相关的话题，也看到不少直接爬知乎信息的项目；其中一个就是 &lt;a href=&#34;https://github.com/egrcc/zhihu-python&#34;&gt;zhihu-python&lt;/a&gt;. 实际上 zhihu-python 不是一个完整的爬虫，正如其文档说明的那样，是一个 API 库，可以基于这些 API 实现一个爬虫应用。zhihu-python 实现了用户、问题、答案、收藏夹相关的信息获取类 API，对于大多数信息获取的目的已经足够。这个项目很受欢迎，然而说实话，代码质量一般，不过思路值得借鉴。&lt;/p&gt;

&lt;p&gt;恰巧我也是一个 &lt;a href=&#34;http://golang.org/&#34;&gt;Go 语言&lt;/a&gt; 爱好者，在之前的工作中也用 Go 写过项目。语法简单，开发效率高，性能很好。GitHub 上搜了一下，zhihu-python 或同类项目，并没有一个 Go 实现的版本。于是就想动手造个轮子，把 zhihu-python 移植到 Go，所以就有了标题里提到的 &lt;a href=&#34;https://github.com/DeanThompson/zhihu-go&#34;&gt;zhihu-go&lt;/a&gt;. 主要是出于练手的目的，最近一年都在做 Python 开发，Go 还有点生疏了。因为是移植，最初的设计和实现思路很大程度上参考或模仿了 zhihu-python，后来在开发过程中，新增了一些 API，也删除了少数几个我认为没什么用的 API. 开发过程中又看到了一个 Python 3 版本的实现 &lt;a href=&#34;https://github.com/7sDream/zhihu-py3&#34;&gt;zhihu-py3&lt;/a&gt;，这个库也是受启发于 zhihu-python，代码质量也要更好，而且实现了更丰富的 API，尤其是关于操作类的，如点赞、收藏答案等。zhihu-go 也参考了 zhihu-py3 的一些 API 设计。截止到现在，zhihu-go 的完成度应该和 zhihu-python 差不多，还多了一些 API；比 zhihu-py3 少了活动、评论及操作类的 API，这些在 TODO list 都列了出来。&lt;/p&gt;

&lt;p&gt;前几天在 V2EX 发了一个 &lt;a href=&#34;http://v2ex.com/t/266372&#34;&gt;推广的帖子&lt;/a&gt;，没想到反响还不错，收到不少支持和鼓励，GitHub 也在一两天内收获了 50 来个 star （个人最高）. 其实在这之前，还在 StuduGolang 发了 &lt;a href=&#34;http://studygolang.com/topics/1528&#34;&gt;一个主题&lt;/a&gt;，然而并没有人回复，带到 GitHub 的流量也很少，好像只有 1 个 star. golangtc 也发了，流量就更少了，可以忽略不计。&lt;/p&gt;

&lt;p&gt;后续有时间简单分析一下源码，分享一下开发过程和心得。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>极光推送 Go SDK</title>
      <link>http://deanthompson.github.io/posts/2015/11/jpush-api-go-client</link>
      <pubDate>Sat, 28 Nov 2015 22:32:35 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/11/jpush-api-go-client</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.jpush.cn/&#34;&gt;极光推送&lt;/a&gt; 是国内最早的第三方消息推送服务，官方提供了多种语言的 SDK 和 REST API，详情见 &lt;a href=&#34;http://docs.jpush.io/server/server_overview/&#34;&gt;官方文档&lt;/a&gt;。遗憾的是缺少一个 Go 语言版本的 SDK，于是我就动手造轮子，封装了一个 Go 的版本。&lt;/p&gt;

&lt;p&gt;实际上这个项目在今年 3 月份就完成了主要的推送相关的接口，在 GitHub 上也收获了几个 star 和 fork. 最近今天突然兴起，又翻出来把 device, tag, alias, report 的一些相关接口也封装完成了。&lt;/p&gt;

&lt;p&gt;啰嗦了一大推，差点忘了最重要的东西，下面给出链接：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;源代码和示例：&lt;a href=&#34;https://github.com/DeanThompson/jpush-api-go-client&#34;&gt;https://github.com/DeanThompson/jpush-api-go-client&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;官方文档：&lt;a href=&#34;http://docs.jpush.io/server/rest_api_v3_push/&#34;&gt;http://docs.jpush.io/server/rest_api_v3_push/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;欢迎使用，并 &lt;a href=&#34;https://github.com/DeanThompson/jpush-api-go-client/issues&#34;&gt;反馈 issues&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/DeanThompson/jpush-api-go-client/pulls&#34;&gt;创建 pull request&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在 Flask 项目中使用 Celery</title>
      <link>http://deanthompson.github.io/posts/2015/11/using-celery-with-flask</link>
      <pubDate>Sat, 14 Nov 2015 16:57:03 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/11/using-celery-with-flask</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://deanthompson.github.io/posts/2015/11/a-introduction-to-celery/&#34;&gt;前一篇 Blog&lt;/a&gt; 简单介绍了 Celery 及其用法，现在我们看看在 Flask 项目中如何使用 Celery.&lt;/p&gt;

&lt;p&gt;注意，这篇 Blog 严重参考了这两篇文章：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.miguelgrinberg.com/post/using-celery-with-flask&#34;&gt;Using Celery With Flask&lt;/a&gt;: 写了一个完整而且有意义的例子来展示如何在 Flask 中使用 Celery.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.miguelgrinberg.com/post/celery-and-the-flask-application-factory-pattern&#34;&gt;Celery and the Flask Application Factory Pattern&lt;/a&gt;: 是上文的姊妹篇，描述的是更为真实的场景下，Celery 与 &lt;a href=&#34;http://flask.pocoo.org/docs/0.10/patterns/appfactories/&#34;&gt;Flask Application Factory&lt;/a&gt; 的结合使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;minimum-example:189b2b2b7ede750816eef2f2c404a30a&#34;&gt;Minimum Example&lt;/h2&gt;

&lt;p&gt;Celery 的一些设计和概念，与 Flask 很像，在 Flask 项目中集成 Celery 也很简单，不像 Django 或其他框架需要扩展插件。首先来看个最简单的例子 example.py：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import uuid

from flask import Flask, request, jsonify
from celery import Celery

app = Flask(__name__)
app.config[&#39;CELERY_BROKER_URL&#39;] = &#39;redis://localhost:6379/0&#39;
app.config[&#39;CELERY_RESULT_BACKEND&#39;] = &#39;redis://localhost:6379/0&#39;

celery = Celery(app.name, broker=app.config[&#39;CELERY_BROKER_URL&#39;])
celery.conf.update(app.config)


@celery.task
def send_email(to, subject, content):
    return do_send_email(to, subject, content)


@app.route(&#39;/password/forgot/&#39;, methods=[&#39;POST&#39;])
def reset_password():
    email = request.form[&#39;email&#39;]
    token = str(uuid.uuid4())
    content = u&#39;请点击链接重置密码：http://example.com/password/reset/?token=%s&#39; % token
    send_email.delay(email, content)
    return jsonify(code=0, message=u&#39;发送成功&#39;)


if __name__ == &#39;__main__&#39;:
    app.run()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动 Celery worker:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ celery worker -A example.celery -l INFO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动 Web server:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python example.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，实际应用在生产环境下，不能直接用 Flask 自带的 server，需要使用 Gunicorn 这样的 WSGI 容器，或 uWSGI. 而且 Celery worker 进程和 Web server 进程应该用 supervisord 管理起来。&lt;/p&gt;

&lt;h2 id=&#34;becoming-bigger:189b2b2b7ede750816eef2f2c404a30a&#34;&gt;Becoming Bigger&lt;/h2&gt;

&lt;p&gt;这是个最简单的例子，实际应用会比这个复杂很多：有很多模块，更复杂的配置，更多的 task 等。在这种情况下，Flask 推荐使用 &lt;a href=&#34;http://flask.pocoo.org/docs/0.10/patterns/appfactories/&#34;&gt;Application Factory Pattern&lt;/a&gt;，也就是定义一个 function，在这里创建 Flask app 对象，并且处理注册路由（blueprints）、配置 logging 等一系列初始化操作。&lt;/p&gt;

&lt;p&gt;下面我们看看在更大的 Flask 项目里，应该如何使用 Celery.&lt;/p&gt;

&lt;h3 id=&#34;项目结构:189b2b2b7ede750816eef2f2c404a30a&#34;&gt;项目结构&lt;/h3&gt;

&lt;p&gt;首先来看一下整个项目的结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;.
├── README.md
├── app
│   ├── __init__.py
│   ├── config.py
│   ├── forms
│   ├── models
│   ├── tasks
│   │   ├── __init__.py
│   │   └── email.py
│   └── views
│   │   ├── __init__.py
│   │   └── account.py
├── celery_worker.py
├── manage.py
└── wsgi.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个图里省略了很多细节，简单解释一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;项目的根目录下，有个 &lt;code&gt;celery_worker.py&lt;/code&gt; 的文件，这个文件的作用类似于 &lt;code&gt;wsgi.py&lt;/code&gt;，是启动 Celery worker 的入口。&lt;/li&gt;
&lt;li&gt;app 包里是主要业务代码，其中 tasks 里定义里一系列的 task，提供给其他模块调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;主要代码:189b2b2b7ede750816eef2f2c404a30a&#34;&gt;主要代码。&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;app/config.py&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class BaseConfig(object):
    CELERY_BROKER_URL = &#39;redis://localhost:6379/2&#39;
    CELERY_RESULT_BACKEND = &#39;redis://localhost:6379/2&#39;
    CELERY_TASK_SERIALIZER = &#39;json&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;BaseConfig&lt;/code&gt; 是整个项目用到的配置的基类，实际上还会派生出 &lt;code&gt;DevelopmentConfig&lt;/code&gt;, &lt;code&gt;StagingConfig&lt;/code&gt; 和 &lt;code&gt;ProductionConfig&lt;/code&gt; 等类。这里不讨论配置的细节，也只关心和 Celery 相关的配置项。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;app/__init__.py&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from celery import Celery
from flask import Flask

from app.config import BaseConfig

celery = Celery(__name__, broker=BaseConfig.CELERY_BROKER_URL)


def create_app():
    app = Flask(__name__)
    # ....
    celery.conf.update(app.config)	# 更新 celery 的配置
    # ...
    return app
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;app/tasks/email.py&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from flask import current_app
from celery.util.log import get_task_logger

from app import celery

logger = get_task_logger(__name__)


@celery.task
def send_email(to, subject, content):
    app = current_app._get_current_object()
    subject = app.config[&#39;EMAIL_SUBJECT_PREFIX&#39;] + subject
    logger.info(&#39;send message &amp;quot;%s&amp;quot; to %s&#39;, content, to)
    return do_send_email(to, subject, content)

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;app/views/account.py&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import uuid

from flask import Blueprint, request,jsonify

from app.tasks.email import send_email

bp_account = Blueprint(&#39;account&#39;, __name__)


@bp_account.route(&#39;/password/forgot/&#39;, methods=[&#39;POST&#39;])
def reset_password():
    email = request.form[&#39;email&#39;]
    token = str(uuid.uuid4())
    content = u&#39;请点击链接重置密码：http://example.com/password/reset/?token=%s&#39; % token
    send_email.delay(email, content)
    return jsonify(code=0, message=u&#39;发送成功&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ceelry_worker.py&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from app import create_app, celery

app = create_app()
app.app_context().push()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个 &lt;code&gt;celery_worker.py&lt;/code&gt; 文件有两个操作：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;创建一个 Flask 实例&lt;/li&gt;
&lt;li&gt;推入 Flask application context&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一个操作很简单，其实也是初始化了 celery 实例。&lt;/p&gt;

&lt;p&gt;第二个操作看起来有些奇怪，实际上也很好理解。如果用过 Flask 就应该知道 Flask 的 &lt;a href=&#34;http://flask.pocoo.org/docs/0.10/appcontext/&#34;&gt;Application Context&lt;/a&gt; 和 &lt;a href=&#34;http://flask.pocoo.org/docs/0.10/reqcontext/&#34;&gt;Request Context&lt;/a&gt;. Flask 一个很重要的设计理念是：在一个 Python 进程里可以运行多个应用（application），当存在多个 application 时可以通过 &lt;code&gt;current_app&lt;/code&gt; 获取当前请求所对应的 application. &lt;code&gt;current_app&lt;/code&gt; 绑定的是当前 request 的 application 的引用，在非 request-response 环境里，是没有 request context 的，所以调用 &lt;code&gt;current_app&lt;/code&gt; 就会抛出异常（&lt;code&gt;RuntimeError: working outside of application context&lt;/code&gt;）。创建一个 request context 没有必要，而且消耗资源，所以就引入了 application context.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;app.app_context().push()&lt;/code&gt; 会推入一个 application context，后续所有操作都会在这个环境里执行，直到进程退出。因此，如果在 tasks 里用到了 &lt;code&gt;current_app&lt;/code&gt; 或其它需要 application context 的东西，就一定需要这样做。（默认情况下 Celery 的 pool 是 prefork，也就是多进程，现在这种写法没有问题；但是如果指定使用 gevent，是没用的。这种情况下有别的解决方案，以后会写文章讨论。）&lt;/p&gt;

&lt;h3 id=&#34;运行:189b2b2b7ede750816eef2f2c404a30a&#34;&gt;运行&lt;/h3&gt;

&lt;p&gt;在项目的根路径下启动 Celery worker:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ celery worker -A celery_worker.celery -l INFO
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结:189b2b2b7ede750816eef2f2c404a30a&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;上面两个例子，实际上主要的差别就是初始化方式和模块化，还有需要注意 Flask 的 application context 问题。文章内容比较简单，文中的一些链接是很好的扩展和补充，值得一看。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Celery 使用简介</title>
      <link>http://deanthompson.github.io/posts/2015/11/a-introduction-to-celery</link>
      <pubDate>Sat, 14 Nov 2015 16:44:34 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/11/a-introduction-to-celery</guid>
      <description>

&lt;h2 id=&#34;introduction:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;Introduction&lt;/h2&gt;

&lt;h3 id=&#34;分布式任务队列:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;分布式任务队列&lt;/h3&gt;

&lt;p&gt;Celery 是一个分布式任务队列，下面是 &lt;a href=&#34;http://www.celeryproject.org/&#34;&gt;官网&lt;/a&gt; 的一段描述：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Celery is an asynchronous task queue/job queue based on distributed message passing.  It is focused on real-time operation, but supports scheduling as well.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Celery 简单、灵活、可靠，是一个专注于实时处理的任务队列，同时也支持任务调度。&lt;/p&gt;

&lt;h3 id=&#34;何为任务队列:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;何为任务队列？&lt;/h3&gt;

&lt;p&gt;摘自 Celery 官方文档的 &lt;a href=&#34;http://docs.jinkan.org/docs/celery/getting-started/introduction.html&#34;&gt;中文翻译&lt;/a&gt;：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;任务队列是一种在线程或机器间分发任务的机制。&lt;/p&gt;

&lt;p&gt;消息队列的输入是工作的一个单元，称为任务，独立的职程（Worker）进程持续监视队列中是否有需要处理的新任务。&lt;/p&gt;

&lt;p&gt;Celery 用消息通信，通常使用中间人（Broker）在客户端和职程间斡旋。这个过程从客户端向队列添加消息开始，之后中间人把消息派送给职程。&lt;/p&gt;

&lt;p&gt;Celery 系统可包含多个职程和中间人，以此获得高可用性和横向扩展能力。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;适用场景:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;适用场景&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;可以在 Request-Response 循环之外执行的操作：发送邮件、推送消息&lt;/li&gt;
&lt;li&gt;耗时的操作：调用第三方 API、视频处理（前端通过 AJAX 展示进度和结果）&lt;/li&gt;
&lt;li&gt;周期性任务：取代 crontab&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;simple-tutorial:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;Simple Tutorial&lt;/h2&gt;

&lt;p&gt;主要参考了官网文档：&lt;a href=&#34;http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html&#34;&gt;First Steps with Celery&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;选择-broker:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;选择 Broker&lt;/h3&gt;

&lt;p&gt;下图描述了 Celery 的基本架构和工作流程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;+------+      +--------+      +----------------+      +--------------+
| User | ---&amp;gt; | Broker | ---&amp;gt; | Workers (1..N) | ---&amp;gt; | Result Store |
+------+      +--------+      +----------------+      +--------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如前文所述，Celery 用消息通信。常用的 Broker 有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt;: RabbitMQ 功能完备、稳定，是一个非常可靠的选择，Celery 官网的评价是 &amp;ldquo;excellent choice for a production environment&amp;rdquo;. 缺点是使用起来毕竟有些复杂。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Redis&lt;/strong&gt;: Redis 同样功能完备，与 RabbitMQ 相比，缺点是可能因为掉电或异常退出导致数据丢失，优点是使用简单。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据库&lt;/strong&gt;: 能方便的集成 SQLAlchemy 和 Django ORM，缺点是性能差，但如果项目本来就用到了数据库，使用起来也非常便利，而且不需要再安装 RabbitMQ 或 Redis.&lt;/li&gt;
&lt;li&gt;其它: 比如 MongoDB, Amazon SQS 还有 IronMQ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们在这里选择使用 Reids.&lt;/p&gt;

&lt;h3 id=&#34;安装:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;安装&lt;/h3&gt;

&lt;p&gt;Celery 是一个 Python 的应用，而且已经上传到了 PyPi，所以可以使用 &lt;code&gt;pip&lt;/code&gt; 或 &lt;code&gt;easy_install&lt;/code&gt; 安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pip install celery
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成后会在 PATH （或 virtualenv 的 bin 目录）添加几个命令：celery, celerybeat, celeryd 和 celeryd-multi. 我们这里只使用 celery 命令。&lt;/p&gt;

&lt;h3 id=&#34;创建-application-和-task:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;创建 Application 和 Task&lt;/h3&gt;

&lt;p&gt;Celery 的使用方法和 Flask 很像，实例化一个 Celery 对象 &lt;code&gt;app&lt;/code&gt;，然后通过 &lt;code&gt;@app.task&lt;/code&gt; 装饰器注册一个 task. 下面是一个简单的例子 tasks.py：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from celery import Celery

app = Celery(__name__, broker=&#39;redis://localhost:6379/0&#39;)


@app.task
def add(x, y):
    return x + y
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;运行-worker:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;运行 worker&lt;/h3&gt;

&lt;p&gt;在 tasks.py 文件所在目录运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ celery worker -A tasks.app -l INFO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令会开启一个在前台运行的 worker，解释这个命令的意义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;worker: 运行 worker 模块&lt;/li&gt;
&lt;li&gt;-A: &amp;ndash;app=APP, 指定使用的 Celery 实例，类似 Gunicorn 的用法&lt;/li&gt;
&lt;li&gt;-l: &amp;ndash;loglevel=INFO, 指定日志级别，可选：DEBUG, INFO, WARNING, ERROR, CRITICAL, FATAL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其它常用的选项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-P: &amp;ndash;pool=prefork, 并发模型，可选：prefork (默认，multiprocessing), eventlet, gevent, threads.&lt;/li&gt;
&lt;li&gt;-c: &amp;ndash;concurrency=10, 并发级别，prefork 模型下就是子进程数量，默认等于 CPU 核心数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完整的命令行选项可以这样查看：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ celery worker --help
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;调用-task:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;调用 task&lt;/h3&gt;

&lt;p&gt;有些 Task 可以当作一个普通的函数同步调用，这里讨论异步的方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from tasks import add

add.delay(1, 2)
add.apply_async(1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面两种调用方式等价，&lt;code&gt;delay()&lt;/code&gt; 方法是 &lt;code&gt;apply_async()&lt;/code&gt; 方法的简写。这个调用会把 &lt;code&gt;add&lt;/code&gt; 操作放入到队列里，然后立即返回一个 &lt;code&gt;AsyncResult&lt;/code&gt; 对象。如果关心处理结果，需要给 &lt;code&gt;app&lt;/code&gt; 配置 &lt;code&gt;CELERY_RESULT_BACKEND&lt;/code&gt;，指定一个存储后端保存任务的返回值。&lt;/p&gt;

&lt;h3 id=&#34;配置:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;配置&lt;/h3&gt;

&lt;p&gt;前文说过 Celery 与 Flask 的使用很像，配置也是如此。一般情况下，使用 Celery 的默认配置就已经足够，但 Celery 也提供了很灵活的配置。下面是两种配置方式，&lt;a href=&#34;http://docs.celeryproject.org/en/latest/configuration.html&#34;&gt;官方文档&lt;/a&gt; 可以查看所有的配置项及默认值。&lt;/p&gt;

&lt;h4 id=&#34;直接修改配置:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;直接修改配置&lt;/h4&gt;

&lt;p&gt;单个：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;app.conf.CELERY_TASK_SERIALIZER = &#39;json&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或批量（支持 &lt;code&gt;dict&lt;/code&gt; 语法）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;app.conf.update(
    CELERY_TASK_SERIALIZER=&#39;json&#39;,
    CELERY_ACCEPT_CONTENT=[&#39;json&#39;],  # Ignore other content
    CELERY_RESULT_SERIALIZER=&#39;json&#39;,
    CELERY_TIMEZONE=&#39;Europe/Oslo&#39;,
    CELERY_ENABLE_UTC=True
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;配置模块:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;配置模块&lt;/h4&gt;

&lt;p&gt;类似 Flask，对于比较大的 Celery 项目，配置模块（configuration module）是更好的选择。Celery 对象有个 &lt;code&gt;config_from_object&lt;/code&gt; 方法，读取一个 object (py 文件或 class)来更新配置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;BROKER_URL = &#39;redis://localhost:6379/0&#39;

CELERY_TASK_SERIALIZER = &#39;json&#39;
CELERY_RESULT_SERIALIZER = &#39;json&#39;
CELERY_ACCEPT_CONTENT=[&#39;json&#39;]
CELERY_TIMEZONE = &#39;Europe/Oslo&#39;
CELERY_ENABLE_UTC = True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把上面的内容保存为 &lt;code&gt;celeryconfig.py&lt;/code&gt; 文件，然后：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;app.config_from_object(&#39;celeryconfig&#39;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Tornado 和 Flask 应用缓存响应结果</title>
      <link>http://deanthompson.github.io/posts/2015/11/cache-response-in-tornado-and-flask</link>
      <pubDate>Thu, 05 Nov 2015 16:52:12 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/11/cache-response-in-tornado-and-flask</guid>
      <description>

&lt;p&gt;写 API 的时候，总是会想着如何能提升性能。在一般的 Web 应用里，基本上没什么 CPU 密集型的计算，大部分时间还是消耗在 IO 上面：查询数据库、读写文件、调用第三方 API 等。有些可以异步的操作，比如发送注册邮件、手机验证码等，可以用任务队列来处理。在 Python 的生态里，Celery 就是一个很成熟的解决方案。但是对于很多查询请求，还是需要同步返回的。&lt;/p&gt;

&lt;p&gt;如果真的遇到性能问题，正确的做法是先找出性能瓶颈，然后对症下药。比如优化数据库索引、优化数据库查询语句、优化算法和数据结构，加速查询和计算。但是最快的计算就是不算——或只计算一次，也就是把计算（查询）的结果缓存起来，以后相同条件的计算（查询）直接从缓存里获取，而不需要重新计算（查询）。&lt;/p&gt;

&lt;p&gt;对于耗时的计算，缓存是一种非常有效的优化手段。但缓存也不是万能的，引入缓存的同时，一些其他问题或需要注意的事情也随之而来，比如数据同步、缓存失效、命中率、分布式等。这里不深入探讨这些问题，仅针对下面这种场景，使用缓存来优化 API 性能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GET 查询&lt;/li&gt;
&lt;li&gt;查询很耗时&lt;/li&gt;
&lt;li&gt;相同条件、不同时间（或某段时间内）的查询结果是一致的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比如获取静态页面（也可以通过 Nginx 直接返回），查询某些元数据列表（如国家列表、产品分类等）。&lt;/p&gt;

&lt;h2 id=&#34;基本思想:a2bd452655e299f799e36f1a03619c2b&#34;&gt;基本思想&lt;/h2&gt;

&lt;p&gt;“一码胜千言”，直接上代码描述一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def cachable_get(kwargs, on_cache_missing, timeout=300):
    key = make_key(kwargs)	# 计算出一个 key
    value = cache.get(key)	# 查询缓存
    if not value:
        value = on_cache_missing(kwargs)	# 缓存没有命中，计算一次
        cache.set(key, value, timeout)	# 把计算结果写入缓存
    return value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上也就是：先查缓存，如果有缓存没命中，再计算并把结果写入缓存。这种机制类似于中间件，或 Python 里的装饰器。&lt;/p&gt;

&lt;h2 id=&#34;tornado-的实现:a2bd452655e299f799e36f1a03619c2b&#34;&gt;Tornado 的实现&lt;/h2&gt;

&lt;p&gt;Tornado 的 &lt;code&gt;tornado.web.RequestHandler&lt;/code&gt; 有两个方法：&lt;code&gt;prepare&lt;/code&gt; 和 &lt;code&gt;write&lt;/code&gt;。前者会在执行业务代码前执行，后者用于写入响应结果。所以可以在 &lt;code&gt;prepare&lt;/code&gt; 里查询缓存，如果命中就直接返回。没有命中的请求会执行业务代码，然后在 &lt;code&gt;write&lt;/code&gt; 里顺便写入缓存。&lt;/p&gt;

&lt;p&gt;在 Tornado 项目里，通常的做法是从 &lt;code&gt;tornado.web.RequestHandler&lt;/code&gt; 派生一个 &lt;code&gt;BaseHandler&lt;/code&gt; 用于项目内 Handler 的统一基类，方便在 &lt;code&gt;BaseHandler&lt;/code&gt; 里做一些统一的处理。如果在 &lt;code&gt;BaseHandler&lt;/code&gt; 的 &lt;code&gt;prepare&lt;/code&gt; 和 &lt;code&gt;write&lt;/code&gt; 方法实现缓存机制，会影响到所有子类的表现，这样可控性和扩展性就会差一点。推荐的做法是用 Mixin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# -*- coding: utf-8 -*-

try:
    import cPickle as pickle
except ImportError:
    import pickle

import functools
from hashlib import sha1


class CacheMixin(object):
    @property
    def cache(self):
        return self.application.cache

    def _generate_key(self):
        key = pickle.dumps((self.request.path, self.request.arguments))
        return self._with_prefix(sha1(key).hexdigest())

    def _with_prefix(self, key):
        return &#39;%s:%s&#39; % (self.request.path.strip(&#39;/&#39;), key)

    def write_cache(self, chunk):
        super(CacheMixin, self).write(chunk)

    def prepare(self):
        super(CacheMixin, self).prepare()
        key = self._generate_key()
        cached = self.cache.get(key)
        if cached is not None:
            self.write_cache(pickle.loads(cached))
            self.finish()

    def write(self, chunk):
        key = self._generate_key()
        expiration = getattr(self, &#39;expiration&#39;, 300)
        self.cache.set(key, pickle.dumps(chunk), expiration)
        super(CacheMixin, self).write(chunk)


def set_cache_timeout(expiration=300):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(handler, *args, **kwargs):
            handler.expiration = expiration
            return func(handler, *args, **kwargs)

        return wrapper

    return decorator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;CacheMixin&lt;/code&gt; 在定义 Handler 时作为基类传入，覆盖 &lt;code&gt;tornado.web.RequestHandler&lt;/code&gt; 的 &lt;code&gt;prepare&lt;/code&gt; 和 &lt;code&gt;write&lt;/code&gt;，实现缓存机制。&lt;code&gt;self.application.cache&lt;/code&gt; 意味着初始化 &lt;code&gt;tornado.web.Application&lt;/code&gt; 时需要配置一个 &lt;code&gt;cache&lt;/code&gt; 属性，至少需要实现 &lt;code&gt;get&lt;/code&gt; 和支持超时的 &lt;code&gt;set&lt;/code&gt; 方法。常见的是定义一个 &lt;code&gt;CacheBackend&lt;/code&gt; 和一套 &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt; 接口，然后封装不同的缓存实现，比如 Redis，Memcache 等。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;set_cache_timeout&lt;/code&gt; 提供了自定义缓存失效时间的能力，这个装饰器不是必须的，与之等价的方式是在 Handler 的 &lt;code&gt;get&lt;/code&gt; 方法的第一行（或第一个调用 &lt;code&gt;self.write&lt;/code&gt; 语句前）加上：&lt;code&gt;self.expiration = TIMEOUT_IN_SECONDS&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;一个没什么实际意义的使用示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Class HelloHandler(CacheMixin, tornado.web.RequestHandler):
    
    @set_cache_timeout(86400)
    def get(self):
        self.write(&amp;quot;Hello world!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;flask-的实现:a2bd452655e299f799e36f1a03619c2b&#34;&gt;Flask 的实现&lt;/h2&gt;

&lt;p&gt;Flask 里可以用 &lt;code&gt;before_request&lt;/code&gt; 和 &lt;code&gt;after_request&lt;/code&gt; 这两个 hooks 实现 Tornado 里覆盖 &lt;code&gt;prepare&lt;/code&gt; 和 &lt;code&gt;write&lt;/code&gt; 来缓存所有请求，具体实现大同小异。也可以用装饰器来获得更好的灵活性。&lt;/p&gt;

&lt;p&gt;在看具体实现之前，先推荐一个 Flask 的缓存扩展：&lt;a href=&#34;https://pythonhosted.org/Flask-Cache/&#34;&gt;Flask-Cache&lt;/a&gt;. Flask-Cache 基于 &lt;code&gt;werkzeug.contrib.cache&lt;/code&gt;，后者定义了一套缓存接口和实现了多种不同 Backend 的缓存实现；Flask-Cache 在此基础上针对 Flask 做了一些应用性集成以及提供了一些其他的辅助函数。&lt;/p&gt;

&lt;p&gt;下面的例子用的是 Flask-Cache，后端用 Redis，具体的配置见 Flask-Cache 的官方文档。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;try:
    import cPickle as pickle
except ImportError:
    import pickle

import hashlib
import functools

from flask import g


class cached_response(object):
    def __init__(self, timeout=300):
        self.timeout = timeout or 300

    def _generate_key(self):
        data = pickle.dumps((request.path, request.values))
        key = hashlib.sha1(data).hexdigest()
        return self._with_prefix(key)

    @staticmethod
    def _with_prefix(key):
        return &#39;%s:%s&#39; % (request.path, key)

    def __call__(self, view_func):
        @functools.wraps(view_func)
        def decorator(*args, **kwargs):
            key = self._generate_key()
            response = cache.get(key)
            if response:
                return response

            response = view_func(*args, **kwargs)

            # 允许 view 函数通过设置 g.disable_cache = True 来控制不缓存本次请求的结果
            if getattr(g, &#39;disable_cache&#39;, False):
                return response
            
            # 只缓存 200 的请求结果
            if response.status_code == 200:
                cache.set(key, response, self.timeout)
        
            return response

        return decorator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;cached_response&lt;/code&gt; 是一个基于类的装饰器实现，接受 &lt;code&gt;timeout&lt;/code&gt; 参数指定缓存失效时间。用 &lt;code&gt;request.path&lt;/code&gt; 和 &lt;code&gt;request.values&lt;/code&gt; 序列化后的哈希值来标示相同的参数的请求（与 Tornado 版本类似）。上面的实现还展现出了一些可定制性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只缓存 StatusCode 为 200 的请求结果&lt;/li&gt;
&lt;li&gt;允许 endpoint 通过设置 &lt;code&gt;g.disable_cache = True&lt;/code&gt; 来控制不缓存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了这两点，还可以做其他定制，比如通过请求参数传入 &lt;code&gt;nocache=1&lt;/code&gt; 来控制获取实时结果，通过设置 &lt;code&gt;g.cache_timeout = 100&lt;/code&gt; 来覆盖默认的缓存失效时间。&lt;/p&gt;

&lt;p&gt;使用起来也很简单，只需要注册一个装饰器就可以：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@app.route(&#39;/hello/&#39;)
@cached_response(86400)
def hello():
    return &amp;quot;Hello, world!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结语:a2bd452655e299f799e36f1a03619c2b&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;上面展示了在 Tornado 和 Flask 项目里缓存请求结果的实现方法，实际使用的时候，还是要结合具体情况做定制和调整。缓存也是一把双刃剑，在享受缓存带来性能提升的同时也要注意可能引入的问题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用 WTForms 和装饰器做表单校验</title>
      <link>http://deanthompson.github.io/posts/2015/10/using-wtforms-and-decorator-to-validate-form-in-flask</link>
      <pubDate>Sat, 31 Oct 2015 01:46:10 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/10/using-wtforms-and-decorator-to-validate-form-in-flask</guid>
      <description>&lt;p&gt;在一个 Web 应用里，不管是为了业务逻辑的正确性，还是系统安全性，做好参数（querystring, form, json）验证都是非常必要的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/wtforms/wtforms&#34;&gt;WTForms&lt;/a&gt; 是一个非常好用而且强大的表单校验和渲染的库，提供 Form 基类用于定义表单结构（类似 ORM），内置了丰富的字段类型和校验方法，可以很方便的用来做校验。如果应用需要输出 HTML，集成到模板里也很容易。对于 JSON  API 应用，用不到渲染的功能，但是结构化的表单和校验功能依然非常有用。&lt;/p&gt;

&lt;p&gt;以一个注册的应用场景为例，用户输入用户名、邮箱、密码、确认密码，服务程序先检查参数然后处理登录逻辑。这几个字段都是必填的，此外还有一些额外的限制：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用户名：长度在 3-20 之间&lt;/li&gt;
&lt;li&gt;邮箱：合法的邮箱格式，比如 &amp;ldquo;abc&amp;rdquo; 就不合法&lt;/li&gt;
&lt;li&gt;密码：长度在 8-20 之间，必须同时包含大小写字母&lt;/li&gt;
&lt;li&gt;确认密码：必须与密码一致&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果参数不合法，返回 400；登录逻辑略去不表。&lt;/p&gt;

&lt;p&gt;最原始的做法，就是直接在注册的接口里取出每个参数，逐个手动校验。这种做法可能的代码是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@app.route(&#39;/user/signup/&#39;, methods=[&#39;POST&#39;])
def register():
    username = request.form.get(&#39;username&#39;)
    if not username or not (3 &amp;lt;= len(username) &amp;lt;= 20):
        abort(400)
    
    email = request.form.get(&#39;email&#39;)
    if not email or not re.match(EMAIL_REGEX, email):
        abort(400)
    
    password = request.form.get(&#39;password&#39;)
    if not password:
        abort(400)
    if password == password.lower() or password == password.upper():
        abort(400)
    
    confirm_password = request.form.get(&#39;confirm_password&#39;)
    if not confirm_password or confirm_password != password:
        abort(400)
    
    # 处理注册的逻辑
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有可能是我的写法不太对，但是这样检查参数的合法性，实在不够优雅。检查参数的代码行数甚至超出了注册的逻辑，也有些喧宾夺主的感觉。可以把这些代码移出来，使得业务逻辑代码更加清晰一点。下面先用 WTForms 来改造一下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from wtforms import Form
from wtforms.fields import StringField, PasswordField
from wtforms.validators import DataRequired, Email, Length, EqualTo, ValidationError


class SignupForm(Form):
    username = StringField(validators=[DataRequired(), Length(3, 20)])
    email = StringField(validators=[DataRequired(), Email()])
    password = PasswordField(validators=[DataRequired()])
    confirm_password = PasswordField(validators=[DataRequired(), EqualTo(&#39;password&#39;)])
    
    def validate_password(self, field):
        password = field.data
        if password == password.lower() or password == passowrd.upper():
            raise ValidationError(u&#39;必须同时包含大小写字母&#39;)


@app.route(&#39;/user/signup/&#39;, methods=[&#39;POST&#39;])
def register():
    form = SignupForm(formdata=request.form)
    if not form.validate():
        abort(400)
    
    # 处理注册逻辑，参数从 form 对象获取，比如
    username = form.username.data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个版本带来的好处很明显：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;参数更加结构化了，所有字段名和类型一目了然&lt;/li&gt;
&lt;li&gt;有内置的，语义清晰的校验方法，可以组合使用&lt;/li&gt;
&lt;li&gt;还能自定义额外的校验方法，方法签名是 &lt;code&gt;def validate_xx(self, field)&lt;/code&gt;，其中 &lt;code&gt;xx&lt;/code&gt; 是字段名，通过 &lt;code&gt;field.data&lt;/code&gt; 来获取输入的值&lt;/li&gt;
&lt;li&gt;还有没体现出来的，就是丰富的错误提示信息，既有内置的，也可以自定义&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;再看原来的 &lt;code&gt;register&lt;/code&gt; 方法，代码变得更加简洁和清晰，整体的编码质量也得到了提升。&lt;/p&gt;

&lt;p&gt;那么再考虑一下更复杂的场景，在一个返回 JSON 的 API 应用里，有很多 API，有不同的参数提交方式（GET 方法通过 query string，POST 方法可能有 form 和 JSON），一样的校验错误处理方式（abort(400) 或其他）。我们依然可以像上面那样处理，但如果再借助装饰器改进一下，又能少写几行“重复”的代码。&lt;/p&gt;

&lt;p&gt;需要注意的是，WTForms 的 formdata 支持的是类似 Werkzeug/Django/WebOb 中的 &lt;code&gt;MultiDict&lt;/code&gt; 的数据结构。Flask 中的 &lt;code&gt;request.json&lt;/code&gt; 是一个 &lt;code&gt;dict&lt;/code&gt; 类型，所以需要先包装一下。&lt;/p&gt;

&lt;p&gt;继续改造注册的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import functools

from werkzeug.datastructures import MultiDict


def validate_form(form_class):
    def decorator(view_func):
        @functools.wraps(view_func)
        def inner(*args, **kwargs):
            if request.method == &#39;GET&#39;:
                formdata = request.args
            else:
                if request.json:
                    formdata = MultiDict(request.json)
                else:
                    formdata = request.form
                    
            form = form_class(formdata=formdata)
            if not form.validate():
                return jsonify(code=400, message=form.errors), 400

            g.form = form
            return view_func(*args, **kwargs)

        return inner

    return decorator


@app.route(&#39;/user/signup/&#39;, methods=[&#39;POST&#39;])
@validate_form(form_class=SignupForm)
def register():
    form = g.form   # 运行到这里，说明表单是合法的

    # 处理注册逻辑，参数从 form 对象获取，比如
    username = form.username.data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实现了一个叫 &lt;code&gt;validate_form&lt;/code&gt; 的装饰器，指定一个 Form 类，处理统一的参数获取、校验和错误处理，如果一切正确，再把 Form 对象保存到全局变量 &lt;code&gt;g&lt;/code&gt; 里面，这样就可以在 view 函数里取出来用了。现在的 &lt;code&gt;register&lt;/code&gt; 方法变得更加简洁，甚至都看不到检查参数的那些代码，只需要关心具体的和注册相关的逻辑本身就好。&lt;/p&gt;

&lt;p&gt;这个装饰器的可重用性非常好，其他的接口只要定义一个 Form 类，然后调用一下装饰器，再从 &lt;code&gt;g&lt;/code&gt; 获取 Form 对象。不仅省了很多心思和体力劳动，代码也变得更加清晰优雅和 Pythonic.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python 编码规范</title>
      <link>http://deanthompson.github.io/posts/2015/08/simple-python-style-guide</link>
      <pubDate>Mon, 10 Aug 2015 22:36:42 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/08/simple-python-style-guide</guid>
      <description>

&lt;p&gt;遵循良好的编码风格，可以有效的提高代码的可读性，降低出错几率和维护难度。在团队开发中，使用（尽量）统一的编码风格，还可以降低沟通成本。&lt;/p&gt;

&lt;p&gt;网上有很多版本的编码规范，基本上都是遵循 PEP8 的规范：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0008/&#34;&gt;PEP 0008 &amp;ndash; Style Guide for Python Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://zh-google-styleguide.readthedocs.org/en/latest/google-python-styleguide/contents/&#34;&gt;Google 的 Python 风格指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.python-guide.org/en/latest/writing/style/&#34;&gt;Python Guide - Code Style&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://flask.pocoo.org/docs/0.10/styleguide/&#34;&gt;Pocoo Styleguide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了在编码时主动遵循规范，还有很多有用的工具：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IntelliJ IDEA 和 PyCharm 的格式化代码功能&lt;/li&gt;
&lt;li&gt;Google 开源的 Python 文件格式化工具：&lt;a href=&#34;https://github.com/google/yapf&#34;&gt;github.com/google/yapf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;pyflakes, pylint 等工具及各种编辑器的插件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文的内容主要摘自互联网上各种版本的规范，因为公司有些小伙伴代码风格不太好，所以整理了一份算是团队的编码规范。&lt;/p&gt;

&lt;h2 id=&#34;缩进:ff97f3d358883b516471cd3d03b40704&#34;&gt;缩进&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;不要使用 tab 缩进&lt;/li&gt;
&lt;li&gt;使用任何编辑器写 Python，请把一个 tab 展开为 4 个空格&lt;/li&gt;
&lt;li&gt;绝对不要混用 tab 和空格，否则容易出现 &lt;code&gt;IndentationError&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;空格:ff97f3d358883b516471cd3d03b40704&#34;&gt;空格&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在 list, dict, tuple, set, 参数列表的 &lt;code&gt;,&lt;/code&gt; 后面加一个空格&lt;/li&gt;
&lt;li&gt;在 dict 的 &lt;code&gt;:&lt;/code&gt; 后面加一个空格&lt;/li&gt;
&lt;li&gt;在注释符号 &lt;code&gt;#&lt;/code&gt; 后面加一个空格，但是 &lt;code&gt;#!/usr/bin/python&lt;/code&gt; 的 &lt;code&gt;#&lt;/code&gt; 后不能有空格&lt;/li&gt;
&lt;li&gt;操作符两端加一个空格，如 &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;接上一条，在参数列表里的 &lt;code&gt;=&lt;/code&gt; 两端不需要空格&lt;/li&gt;
&lt;li&gt;括号（&lt;code&gt;()&lt;/code&gt;, &lt;code&gt;{}&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;）内的两端不需要空格&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;空行:ff97f3d358883b516471cd3d03b40704&#34;&gt;空行&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;function 和 class 顶上两个空行&lt;/li&gt;
&lt;li&gt;class 的 method 之间一个空行&lt;/li&gt;
&lt;li&gt;函数内逻辑无关的段落之间空一行，不要过度使用空行&lt;/li&gt;
&lt;li&gt;不要把多个语句写在一行，然后用 &lt;code&gt;;&lt;/code&gt; 隔开&lt;/li&gt;
&lt;li&gt;if/for/while 语句中，即使执行语句只有一句，也要另起一行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;换行:ff97f3d358883b516471cd3d03b40704&#34;&gt;换行&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;每一行代码控制在 80 字符以内&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;\&lt;/code&gt; 或 &lt;code&gt;()&lt;/code&gt; 控制换行，举例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def foo(first, second, third, fourth, fifth,
        sixth, and_some_other_very_long_param):
    user = User.objects.filter_by(first=first, second=second, third=third) \
        .skip(100).limit(100) \
        .all()


text = (&#39;Long strings can be made up &#39;
        &#39;of several shorter strings.&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;命名:ff97f3d358883b516471cd3d03b40704&#34;&gt;命名&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;使用有意义的，英文单词或词组，绝对不要使用汉语拼音&lt;/li&gt;
&lt;li&gt;package/module 名中不要出现 &lt;code&gt;-&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;各种类型的命名规范：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Public&lt;/th&gt;
&lt;th&gt;Internal&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Modules&lt;/td&gt;
&lt;td&gt;&lt;code&gt;lower_with_under&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;_lower_with_under&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Packages&lt;/td&gt;
&lt;td&gt;&lt;code&gt;lower_with_under&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Classes&lt;/td&gt;
&lt;td&gt;&lt;code&gt;CapWords&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;_CapWords&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Exceptions&lt;/td&gt;
&lt;td&gt;&lt;code&gt;CapWords&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Functions&lt;/td&gt;
&lt;td&gt;&lt;code&gt;lower_with_under()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;_lower_with_under()&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Global/Class Constants&lt;/td&gt;
&lt;td&gt;&lt;code&gt;CAPS_WITH_UNDER&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;_CAPS_WITH_UNDER&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Global/Class Variables&lt;/td&gt;
&lt;td&gt;&lt;code&gt;lower_with_under&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;_lower_with_under&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Instance Variables&lt;/td&gt;
&lt;td&gt;&lt;code&gt;lower_with_under&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;_lower_with_under&lt;/code&gt; (protected) or &lt;code&gt;__lower_with_under&lt;/code&gt; (private)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Method Names&lt;/td&gt;
&lt;td&gt;&lt;code&gt;lower_with_under()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;_lower_with_under()&lt;/code&gt; (protected) or &lt;code&gt;__lower_with_under()&lt;/code&gt; (private)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Function/Method Parameters&lt;/td&gt;
&lt;td&gt;&lt;code&gt;lower_with_under&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Local Variables&lt;/td&gt;
&lt;td&gt;&lt;code&gt;lower_with_under&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;import:ff97f3d358883b516471cd3d03b40704&#34;&gt;import&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;所有 import 尽量放在文件开头，在 docstring 下面，其他变量定义的上面&lt;/li&gt;
&lt;li&gt;不要使用 &lt;code&gt;from foo imort *&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;import 需要分组，每组之间一个空行，每个分组内的顺序尽量采用字典序，分组顺序是：

&lt;ol&gt;
&lt;li&gt;标准库&lt;/li&gt;
&lt;li&gt;第三方库&lt;/li&gt;
&lt;li&gt;本项目的 package 和 module&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;不要使用隐式的相对导入（implicit relative imports），可是使用显示的相对导入（explicit relative imports），如 &lt;code&gt;from ..utils import validator&lt;/code&gt;，最好使用全路径导入（absolute imports）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于不同的 package，一个 import 单独一行，同一个 package/module 下的内容可以写一起：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# bad
import sys, os, time

# good
import os
import sys
import time

# ok
from flask import Flask, render_template, jsonify
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为了避免可能出现的命名冲突，可以使用 &lt;code&gt;as&lt;/code&gt; 或导入上一级命名空间&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不要出现循环导入(cyclic import)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;注释:ff97f3d358883b516471cd3d03b40704&#34;&gt;注释&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;文档字符串 &lt;code&gt;docstring&lt;/code&gt;, 是 package, module, class, method, function 级别的注释，可以通过 &lt;code&gt;__doc__&lt;/code&gt; 成员访问到，注释内容在一对 &lt;code&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/code&gt; 符号之间&lt;/li&gt;
&lt;li&gt;function, method 的文档字符串应当描述其功能、输入参数、返回值，如果有复杂的算法和实现，也需要写清楚&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不要写错误的注释，不要无谓的注释&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# bad 无谓的注释
x = x + 1       # increase x by 1

# bad 错误的注释
x = x - 1       # increase x by 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;优先使用英文写注释，英文不好全部写中文，否则更加看不懂&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;异常:ff97f3d358883b516471cd3d03b40704&#34;&gt;异常&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;不要轻易使用 &lt;code&gt;try/except&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;except&lt;/code&gt; 后面需要指定捕捉的异常，裸露的 &lt;code&gt;except&lt;/code&gt; 会捕捉所有异常，意味着会隐藏潜在的问题&lt;/li&gt;
&lt;li&gt;可以有多个 &lt;code&gt;except&lt;/code&gt; 语句，捕捉多种异常，分别做异常处理&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;finally&lt;/code&gt; 子句来处理一些收尾操作&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;try/except&lt;/code&gt; 里的内容不要太多，只在可能抛出异常的地方使用，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# bad
try:
    user = User()
    user.name = &amp;quot;leon&amp;quot;
    user.age = int(age) # 可能抛出异常
    user.created_at = datetime.datetime.utcnow()


    db.session.add(user)
    db.session.commit() # 可能抛出异常
except:
    db.session.rollback()

# better
try:
    age = int(age)
except (TypeError, ValueError):
    return # 或别的操作


user = User()
user.name = &amp;quot;leon&amp;quot;
user.age = age
user.created_at = datetime.datetime.utcnow()
db.session.add(user)


try:
    db.session.commit()
except sqlalchemy.exc.SQLAlchemyError: # 或者更具体的异常
    db.session.rollback()
finally:
    db.session.close()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从 &lt;code&gt;Exception&lt;/code&gt; 而不是 &lt;code&gt;BaseException&lt;/code&gt; 继承自定义的异常类&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;class-类:ff97f3d358883b516471cd3d03b40704&#34;&gt;Class（类）&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;显示的写明父类，如果不是继承自别的类，就继承自 &lt;code&gt;object&lt;/code&gt; 类&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;super&lt;/code&gt; 调用父类的方法&lt;/li&gt;
&lt;li&gt;支持多继承，即同时有多个父类，建议使用 Mixin&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;编码建议:ff97f3d358883b516471cd3d03b40704&#34;&gt;编码建议&lt;/h2&gt;

&lt;h3 id=&#34;字符串:ff97f3d358883b516471cd3d03b40704&#34;&gt;字符串&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用字符串的 &lt;code&gt;join&lt;/code&gt; 方法拼接字符串&lt;/li&gt;
&lt;li&gt;使用字符串类型的方法，而不是 &lt;code&gt;string&lt;/code&gt; 模块的方法&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;startswith&lt;/code&gt; 和 &lt;code&gt;endswith&lt;/code&gt; 方法比较前缀和后缀&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;format&lt;/code&gt; 方法格式化字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;比较:ff97f3d358883b516471cd3d03b40704&#34;&gt;比较&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;空的 &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;str&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;dict&lt;/code&gt; 和 &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0.0&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; 都是 &lt;code&gt;False&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;if some_list&lt;/code&gt; 而不是 &lt;code&gt;if len(some_list)&lt;/code&gt; 判断某个 &lt;code&gt;list&lt;/code&gt; 是否为空，其他类型同理&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;is&lt;/code&gt; 和 &lt;code&gt;is not&lt;/code&gt; 与单例（如 &lt;code&gt;None&lt;/code&gt;）进行比较，而不是用 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;if a is not None&lt;/code&gt; 而不是 &lt;code&gt;if not a is None&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;isinstance&lt;/code&gt; 而不是 &lt;code&gt;type&lt;/code&gt; 判断类型&lt;/li&gt;
&lt;li&gt;不要用 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 与 &lt;code&gt;True&lt;/code&gt; 和 &lt;code&gt;False&lt;/code&gt; 比较（除非有特殊情况，如在 sqlalchemy 中可能用到）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;in&lt;/code&gt; 操作：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;用 &lt;code&gt;key in dict&lt;/code&gt; 而不是 &lt;code&gt;dict.has_key()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# bad
if d.has_key(k):
    do_something()

# good
if k in d:
    do_something()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用 &lt;code&gt;set&lt;/code&gt; 加速 “存在性” 检查，&lt;code&gt;list&lt;/code&gt; 的查找是线性的，复杂度 O(n)，&lt;code&gt;set&lt;/code&gt; 底层是 hash table, 复杂度 O(1)，但用 &lt;code&gt;set&lt;/code&gt; 需要比 &lt;code&gt;list&lt;/code&gt; 更多内存空间&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;其他:ff97f3d358883b516471cd3d03b40704&#34;&gt;其他&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用列表表达式（&lt;a href=&#34;https://www.python.org/dev/peps/pep-0202/&#34;&gt;list comprehension&lt;/a&gt;），字典表达式(&lt;a href=&#34;https://www.python.org/dev/peps/pep-0274/&#34;&gt;dict comprehension&lt;/a&gt;, Python 2.7+) 和生成器(generator)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dict&lt;/code&gt; 的 &lt;code&gt;get&lt;/code&gt; 方法可以指定默认值，但有些时候应该用 &lt;code&gt;[]&lt;/code&gt; 操作，使得可以抛出 &lt;code&gt;KeyError&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;for item in list&lt;/code&gt; 迭代 &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;for index, item in enumerate(list)&lt;/code&gt; 迭代 &lt;code&gt;list&lt;/code&gt; 并获取下标&lt;/li&gt;
&lt;li&gt;使用内建函数 &lt;code&gt;sorted&lt;/code&gt; 和 &lt;code&gt;list.sort&lt;/code&gt; 进行排序&lt;/li&gt;
&lt;li&gt;适量使用 &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt; 和 &lt;code&gt;lambda&lt;/code&gt;，使用内建的 &lt;code&gt;all&lt;/code&gt;, &lt;code&gt;any&lt;/code&gt; 处理多个条件的判断&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;defaultdict&lt;/code&gt; (Python 2.5+), &lt;code&gt;Counter&lt;/code&gt;(Python 2.7+) 等 “冷门” 但好用的标准库算法和数据结构&lt;/li&gt;
&lt;li&gt;使用装饰器(decorator)&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;with&lt;/code&gt; 语句处理上下文&lt;/li&gt;
&lt;li&gt;有些时候不要对类型做太过严格的限制，利用 Python 的鸭子类型（Duck Type）特性&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;logging&lt;/code&gt; 记录日志，配置好格式和级别&lt;/li&gt;
&lt;li&gt;了解 Python 的 Magic Method：&lt;a href=&#34;http://www.rafekettler.com/magicmethods.html&#34;&gt;A Guide to Python&amp;rsquo;s Magic Methods&lt;/a&gt;, &lt;a href=&#34;http://pycoders-weekly-chinese.readthedocs.org/en/latest/issue6/a-guide-to-pythons-magic-methods.html&#34;&gt;Python 魔术方法指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;阅读优秀的开源代码，如 &lt;a href=&#34;https://github.com/mitsuhiko/flask&#34;&gt;Flask 框架&lt;/a&gt;, &lt;a href=&#34;https://github.com/kennethreitz/requests&#34;&gt;Requests for Humans&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;不要重复造轮子，查看标准库、PyPi、Github、Google 等使用现有的优秀的解决方案&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>用 Fabric 实现自动化部署</title>
      <link>http://deanthompson.github.io/posts/2015/06/deploy-applications-using-fabric</link>
      <pubDate>Fri, 12 Jun 2015 14:00:13 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/06/deploy-applications-using-fabric</guid>
      <description>

&lt;p&gt;写完代码测试通过之后，终于松一口气，然后可以愉快的部署上线了。但是问题随之而来：如何部署？或者如何能更自动化的部署？&lt;/p&gt;

&lt;p&gt;部署应用是一系列的操作，就环境而言，分为本地和远程服务器，就操作而言，大概包括提交代码、备份代码、更新代码、安装依赖、迁移数据库、重启服务等流程。其中除了提交代码这一步是在本地完成，其余操作都需要在服务器环境执行。&lt;/p&gt;

&lt;p&gt;上面的流程当中，有一个很重要的，就是如何同步代码（提交、备份、更新）。就我的经验，了解或用过这些方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rsync: rsync 是一个文件同步的工具，如果配置好使用起来体验也不错。但是有很多缺点：

&lt;ul&gt;
&lt;li&gt;配置复杂，命令行参数多&lt;/li&gt;
&lt;li&gt;需要在服务器上运行 rsyncd，默认监听 873 端口（可能会有防火墙）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;scp: scp 底层用的是 SSH 协议，所以只要服务器上运行了 sshd 就可以双向 copy 文件。对于文件传输来说，scp 比 rsync 体验差的地方有：

&lt;ul&gt;
&lt;li&gt;不能增量更新，每次都是全部传输&lt;/li&gt;
&lt;li&gt;不能配置忽略文件（.git 怎么办？）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;git: 就个人而言，git 是最方便的部署方式了，有版本控制，可以增量更新，可以配置忽略文件，使用简单。实际上只要有可能，都推荐用 git 来发布代码。但问题在于，很多公司的 git 服务器都是在内网的，所以在服务器上无法访问。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;很幸运的是，我们有一个公网可以访问的 git 服务器，所以可以用 git 来发布代码。发布完代码后就是后续的一系列操作了，最原始的方式，是登录到服务器，然后一步一步敲命令执行下来。但是如果要频繁部署的话（快速迭代时肯定要经常更新代码），这就变成了繁复的体力劳动，而且容易出错（漏了流程，看花眼了）。于是就想到了脚本，把这些操作写成 shell 脚本，然后执行脚本就好了。这是一个很大的进步，然而仍然存在一个问题：从本地环境到远程环境，需要登录，导致了流程上的阻断。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.fabfile.org/&#34;&gt;Fabric&lt;/a&gt; 是 Python 编写的一个可以实现自动化部署和系统维护的命令行工具，只需要写一些简单的 Python 代码就能轻松解决上面提到的所有问题。Fabric 底层用的是 SSH 协议，提供了一系列语义清晰的 API 来组合实现部署任务。&lt;/p&gt;

&lt;h2 id=&#34;安装:be4f35f0576547f0cd881725d8efc31a&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;Fabric 是 Python 编写的工具，所以可以用 pip 来安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo pip install fabric
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是 Ubuntu 系统，还可以用 apt-get 安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install fabric
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成后，会生成一个 &lt;code&gt;fab&lt;/code&gt; 命令，这个命令会读取当前路径在的 fabfile.py 并执行相应的任务。&lt;/p&gt;

&lt;h2 id=&#34;hello-world:be4f35f0576547f0cd881725d8efc31a&#34;&gt;Hello, world!&lt;/h2&gt;

&lt;p&gt;先来看一个简单的例子，用 &lt;code&gt;fab&lt;/code&gt; 命令执行一个输出 &lt;code&gt;Hello, world!&lt;/code&gt; 的任务。&lt;/p&gt;

&lt;p&gt;新建一个文件，fabfile.py:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def hello():
	print &#39;Hello, world!&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 fabfile.py 所在的路径执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;fab hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到有这样的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Hello, world!

Done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以给任务传递参数，修改 fabfile.py:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def hello(name=&amp;quot;world&amp;quot;):
    print &amp;quot;Hello, %s!&amp;quot; % name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用 &lt;code&gt;fab&lt;/code&gt; 命令执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ fab hello

Hello, world!

Done.

$ fab hello:name=leon

Hello, leon!

Done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子除了展示 fab 运行任务和传递参数之外，没有什么实际意义，接下来用一个接近真实的场景来展示如何用 Fabric 部署。&lt;/p&gt;

&lt;h2 id=&#34;部署应用:be4f35f0576547f0cd881725d8efc31a&#34;&gt;部署应用&lt;/h2&gt;

&lt;p&gt;假设这样一个场景，有个 Python 项目取名 usercenter，用 git 做版本控制，用 supervisor 做进程管理。一次完整的部署过程可能包括这些流程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 本地
$ cd /path/to/userenter
$ git pull
$ git add -A
$ git commit -m &amp;quot;commit message&amp;quot;
$ git push

# 远程
$ cd /path/to/usercenter
$ workon usercenter		# virtualenv
$ git pull				# 更新代码
$ pip install -r requirements.txt		# 安装依赖
$ python manage.py db migrate			# 数据库迁移
$ supervisorctl restart usercenter	# 重启服务
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们现在用 Fabric 来一次性完成上面所有操作（假设第一次部署是手工执行的，现在只处理更新／升级的任务）。在 usercenter 项目的根目录下新建 fabfile.py 文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# -*- coding: utf-8 -*-

from fabric.api import env, local, cd, run
from fabric.context_managers import prefix


def production():
	&amp;quot;&amp;quot;&amp;quot; 设置 production 环境 &amp;quot;&amp;quot;&amp;quot;
	env.hosts = [&amp;quot;production@123.123.123.123:22&amp;quot;]
	env.key_filename = &amp;quot;/path/to/key_file&amp;quot;
	# env.password = &amp;quot;123456&amp;quot;	# password 和 keyfile 两者只需要一个就可以


def staging():
	&amp;quot;&amp;quot;&amp;quot; 设置 staging 环境 &amp;quot;&amp;quot;&amp;quot;
	env.hosts = [&amp;quot;staging@111.111.111.111:22&amp;quot;]
	env.password = &amp;quot;123456&amp;quot;		# 如果不写密码，会在 fab 执行时有交互提示输入密码


def prepare():
    &amp;quot;&amp;quot;&amp;quot; 本地提交代码，准备部署 &amp;quot;&amp;quot;&amp;quot;
	local(&amp;quot;git pull&amp;quot;)	# local 用于执行本地命令
	local(&amp;quot;pip freeze &amp;gt; requirements.txt&amp;quot;)
	local(&amp;quot;git add -p &amp;amp;&amp;amp; git commit&amp;quot;)	＃ 会有交互输入 commit message
	local(&amp;quot;git push&amp;quot;)


def update():
	&amp;quot;&amp;quot;&amp;quot; 服务器上更新代码、依赖和迁移 &amp;quot;&amp;quot;&amp;quot;
	# cd 用于在服务器上执行 cd 命令，本地环境对应的 api 是 lcd (local cd)
	with cd(&amp;quot;/path/to/usercenter&amp;quot;), prefix(&amp;quot;workon usercenter&amp;quot;):
		run(&amp;quot;git pull&amp;quot;)			# run 用于服务器上执行命令
		run(&amp;quot;pip install -r requirements.txt&amp;quot;)
		run(&amp;quot;python manage.py db migrate&amp;quot;)
		run(&amp;quot;supervisorctl restart usercenter&amp;quot;)

def deploy():
	prepare()
	update()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, 完成。具体的意义代码里面都有注释，不赘述。需要注意的是 &lt;code&gt;production&lt;/code&gt; 和 &lt;code&gt;staging&lt;/code&gt; 分别设置了两种不同的环境。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 部署到 production 环境
$ fab production deploy

# 部署到 staging 环境
$ fab staging deploy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行过程中可能会有些交互，按提示输入相应信息，然后等着执行完成就好了。如果一切顺利（应该是这样），就完成了 usercenter 的部署了，整个过程只需要敲一行命令，是不是非常方便？&lt;/p&gt;

&lt;h2 id=&#34;more:be4f35f0576547f0cd881725d8efc31a&#34;&gt;More&amp;hellip;&lt;/h2&gt;

&lt;p&gt;上面的例子基本上是可以在实际环境中使用的，不过还是有很多内容没有覆盖到，比如错误处理，多服务器部署，并行等。Fabric 默认是串行执行的，如果有多个远程服务器，是一个一个顺序执行。执行过程中如果发生异常，任务会直接中断，所以可能需要有错误处理。&lt;/p&gt;

&lt;p&gt;上面这些（还有很多）内容都可以在 Fabric 的文档上（非常详细）找到相应的内容，下面给出一些参考链接，结合文档和自己的实际情况，多用几次就能定制出能满足自己需求的 Fabric 任务：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fabric 官网: &lt;a href=&#34;http://www.fabfile.org/&#34;&gt;http://www.fabfile.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Overview and Tutorial: &lt;a href=&#34;Overview and Tutorial&#34;&gt;http://docs.fabfile.org/en/1.10/tutorial.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Fabric 文档: &lt;a href=&#34;http://docs.fabfile.org/en/1.10/index.html&#34;&gt;http://docs.fabfile.org/en/1.10/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python fabric实现远程操作和部署（By wklken）: &lt;a href=&#34;http://wklken.me/posts/2013/03/25/python-tool-fabric.html&#34;&gt;http://wklken.me/posts/2013/03/25/python-tool-fabric.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>使用 supervisor 管理进程</title>
      <link>http://deanthompson.github.io/posts/2015/06/using-supervisor</link>
      <pubDate>Tue, 09 Jun 2015 17:30:20 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/06/using-supervisor</guid>
      <description>

&lt;p&gt;Supervisor (&lt;a href=&#34;http://supervisord.org&#34;&gt;http://supervisord.org&lt;/a&gt;) 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。&lt;/p&gt;

&lt;h2 id=&#34;安装:0374c09b00e8eddcfa304907db4e0a23&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;Supervisor 可以运行在 Linux、Mac OS X 上。如前所述，supervisor 是 Python 编写的，所以安装起来也很方便，可以直接用 pip :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo pip install supervisor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是 Ubuntu 系统，还可以使用 apt-get 安装。&lt;/p&gt;

&lt;h2 id=&#34;supervisord-配置:0374c09b00e8eddcfa304907db4e0a23&#34;&gt;supervisord 配置&lt;/h2&gt;

&lt;p&gt;Supervisor 相当强大，提供了很丰富的功能，不过我们可能只需要用到其中一小部分。安装完成之后，可以编写配置文件，来满足自己的需求。为了方便，我们把配置分成两部分：supervisord（supervisor 是一个 C/S 模型的程序，这是 server 端，对应的有 client 端：supervisorctl）和应用程序（即我们要管理的程序）。&lt;/p&gt;

&lt;p&gt;首先来看 supervisord 的配置文件。安装完 supervisor 之后，可以运行&lt;code&gt;echo_supervisord_conf&lt;/code&gt; 命令输出默认的配置项，也可以重定向到一个配置文件里：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo_supervisord_conf &amp;gt; /etc/supervisord.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;去除里面大部分注释和“不相关”的部分，我们可以先看这些配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[unix_http_server]
file=/tmp/supervisor.sock   ; UNIX socket 文件，supervisorctl 会使用
;chmod=0700                 ; socket 文件的 mode，默认是 0700
;chown=nobody:nogroup       ; socket 文件的 owner，格式： uid:gid

;[inet_http_server]         ; HTTP 服务器，提供 web 管理界面
;port=127.0.0.1:9001        ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性
;username=user              ; 登录管理后台的用户名
;password=123               ; 登录管理后台的密码

[supervisord]
logfile=/tmp/supervisord.log ; 日志文件，默认是 $CWD/supervisord.log
logfile_maxbytes=50MB        ; 日志文件大小，超出会 rotate，默认 50MB
logfile_backups=10           ; 日志文件保留备份数量默认 10
loglevel=info                ; 日志级别，默认 info，其它: debug,warn,trace
pidfile=/tmp/supervisord.pid ; pid 文件
nodaemon=false               ; 是否在前台启动，默认是 false，即以 daemon 的方式启动
minfds=1024                  ; 可以打开的文件描述符的最小值，默认 1024
minprocs=200                 ; 可以打开的进程数的最小值，默认 200

; the below section must remain in the config file for RPC
; (supervisorctl/web interface) to work, additional interfaces may be
; added by defining them in separate rpcinterface: sections
[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface

[supervisorctl]
serverurl=unix:///tmp/supervisor.sock ; 通过 UNIX socket 连接 supervisord，路径与 unix_http_server 部分的 file 一致
;serverurl=http://127.0.0.1:9001 ; 通过 HTTP 的方式连接 supervisord

; 包含其他的配置文件
[include]
files = relative/directory/*.ini    ; 可以是 *.conf 或 *.ini
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们把上面这部分配置保存到 /etc/supervisord.conf（或其他任意有权限访问的文件），然后启动 supervisord（通过 -c 选项指定配置文件路径，如果不指定会按照这个顺序查找配置文件：$CWD/supervisord.conf, $CWD/etc/supervisord.conf, /etc/supervisord.conf）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;supervisord -c /etc/supervisord.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看 supervisord 是否在运行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ps aux | grep supervisord
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;program-配置:0374c09b00e8eddcfa304907db4e0a23&#34;&gt;program 配置&lt;/h2&gt;

&lt;p&gt;上面我们已经把 supervisrod 运行起来了，现在可以添加我们要管理的进程的配置文件。可以把所有配置项都写到 supervisord.conf 文件里，但并不推荐这样做，而是通过 include 的方式把不同的程序（组）写到不同的配置文件里。&lt;/p&gt;

&lt;p&gt;为了举例，我们新建一个目录 /etc/supervisor/ 用于存放这些配置文件，相应的，把 /etc/supervisord.conf 里 include 部分的的配置修改一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[include]
files = /etc/supervisor/*.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设有个用 Python 和 Flask 框架编写的用户中心系统，取名 usercenter，用 gunicorn (&lt;a href=&#34;http://gunicorn.org/&#34;&gt;http://gunicorn.org/&lt;/a&gt;) 做 web 服务器。项目代码位于 &lt;code&gt;/home/leon/projects/usercenter&lt;/code&gt;，gunicorn 配置文件为 &lt;code&gt;gunicorn.py&lt;/code&gt;，WSGI callable 是 wsgi.py 里的 app 属性。所以直接在命令行启动的方式可能是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd /home/leon/projects/usercenter
gunicorn -c gunicorn.py wsgi:app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在编写一份配置文件来管理这个进程（&lt;strong&gt;需要注意：用 supervisord 管理时，gunicorn 的 daemon 选项需要设置为 False&lt;/strong&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[program:usercenter]
directory = /home/leon/projects/usercenter ; 程序的启动目录
command = gunicorn -c gunicorn.py wsgi:app  ; 启动命令，可以看出与手动在命令行启动的命令是一样的
autostart = true     ; 在 supervisord 启动的时候也自动启动
startsecs = 5        ; 启动 5 秒后没有异常退出，就当作已经正常启动了
autorestart = true   ; 程序异常退出后自动重启
startretries = 3     ; 启动失败自动重试次数，默认是 3
user = leon          ; 用哪个用户启动
redirect_stderr = true  ; 把 stderr 重定向到 stdout，默认 false
stdout_logfile_maxbytes = 20MB  ; stdout 日志文件大小，默认 50MB
stdout_logfile_backups = 20     ; stdout 日志文件备份数
; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）
stdout_logfile = /data/logs/usercenter_stdout.log

; 可以通过 environment 来添加需要的环境变量，一种常见的用法是修改 PYTHONPATH
; environment=PYTHONPATH=$PYTHONPATH:/path/to/somewhere
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一份配置文件至少需要一个 &lt;code&gt;[program:x]&lt;/code&gt; 部分的配置，来告诉 supervisord 需要管理那个进程。&lt;code&gt;[program:x]&lt;/code&gt; 语法中的 &lt;code&gt;x&lt;/code&gt; 表示 program name，会在客户端（supervisorctl 或 web 界面）显示，在 supervisorctl 中通过这个值来对程序进行 start、restart、stop 等操作。&lt;/p&gt;

&lt;h2 id=&#34;使用-supervisorctl:0374c09b00e8eddcfa304907db4e0a23&#34;&gt;使用 supervisorctl&lt;/h2&gt;

&lt;p&gt;Supervisorctl 是 supervisord 的一个命令行客户端工具，启动时需要指定与 supervisord 使用同一份配置文件，否则与 supervisord 一样按照顺序查找配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;supervisorctl -c /etc/supervisord.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个命令会进入 supervisorctl 的 shell 界面，然后可以执行不同的命令了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; status    # 查看程序状态
&amp;gt; stop usercenter   # 关闭 usercenter 程序
&amp;gt; start usercenter  # 启动 usercenter 程序
&amp;gt; restart usercenter    # 重启 usercenter 程序
&amp;gt; reread    ＃ 读取有更新（增加）的配置文件，不会启动新添加的程序
&amp;gt; update    ＃ 重启配置文件修改过的程序
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这些命令都有相应的输出，除了进入 supervisorctl 的 shell 界面，也可以直接在 bash 终端运行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ supervisorctl status
$ supervisorctl stop usercenter
$ supervisorctl start usercenter
$ supervisorctl restart usercenter
$ supervisorctl reread
$ supervisorctl update 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;其它:0374c09b00e8eddcfa304907db4e0a23&#34;&gt;其它&lt;/h2&gt;

&lt;p&gt;除了 supervisorctl 之外，还可以配置 supervisrod 启动 web 管理界面，这个 web 后台使用 Basic Auth 的方式进行身份认证。&lt;/p&gt;

&lt;p&gt;除了单个进程的控制，还可以配置 group，进行分组管理。&lt;/p&gt;

&lt;p&gt;经常查看日志文件，包括 supervisord 的日志和各个 pragram 的日志文件，程序 crash 或抛出异常的信息一半会输出到 stderr，可以查看相应的日志文件来查找问题。&lt;/p&gt;

&lt;p&gt;Supervisor 有很丰富的功能，还有其他很多项配置，可以在官方文档获取更多信息：&lt;a href=&#34;http://supervisord.org/index.html&#34;&gt;http://supervisord.org/index.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 shadowsocks 实现科学上网</title>
      <link>http://deanthompson.github.io/posts/2015/05/bypass-gfw-with-shadowsocks</link>
      <pubDate>Sun, 24 May 2015 22:27:49 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/05/bypass-gfw-with-shadowsocks</guid>
      <description>

&lt;h2 id=&#34;缘起:4855d9d6e5f234c654404b26568913d6&#34;&gt;缘起&lt;/h2&gt;

&lt;p&gt;GFW 早已经是臭名昭著，路人皆知的了，因为它的存在，使得整个大陆的用户都只能在「局域网」里活动。政治敏感的内容就不说了，很多技术性的网站也被墙掉，导致查找问题浏览网页时经常网络被重置。&lt;/p&gt;

&lt;p&gt;我是个重度 Google 用户，虽然经常用到的 Google 的产品基本上只有 Google 搜索和 Gmail，但只需要这两项就让我离不开 Google。此外，还有很多网站使用 Google 的 OpenID 登录，引用 Google 的字体文件和其他资源文件，这些网站也都几乎无法正常访问。我曾经使用过一些手段来实现翻墙，在大学时得益于教育网免费的 IPv6，毕业后使用了很久的 GoAgent，手机上用过 &lt;a href=&#34;http://fqrouter.com/&#34;&gt;fqrouter&lt;/a&gt;，然而都不是很稳定和一劳永逸的解决方案。&lt;/p&gt;

&lt;p&gt;有很多人使用 VPN，有购买的，也有自己搭建的。在 GoAgent 无法使用后，我开始正式考虑使用 VPN 了，但不想买 VPN，主要原因有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;很多人使用的 VPN 容易被盯上而面临被干掉的危险（应该是多虑了）&lt;/li&gt;
&lt;li&gt;出于信息安全和隐私的考虑，不希望自己的信息有被第三方获取的风险（所以也不想用 fqrouter 了）&lt;/li&gt;
&lt;li&gt;想自己折腾&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以就选择了国外 VPS + Shadowsocks 的解决方案。&lt;/p&gt;

&lt;h2 id=&#34;购买-vps:4855d9d6e5f234c654404b26568913d6&#34;&gt;购买 VPS&lt;/h2&gt;

&lt;p&gt;比较熟悉的是 Linode 和 DigitalOcean，两家的最低配置基本上差不多，但是 Linode 的价格（$10 每月）是后者的两倍。本来是想选择 DigitalOcean 的，但是在家折腾的时候，始终打不开 DigialOcean 的网站。。。于是就选择了 Linode 的 VPS。&lt;/p&gt;

&lt;p&gt;注册过程略去不表，选择机房的时候还是需要测试一下的。网上大家都推荐东京的机房，但是我购买的时候没有这个选项，不过亚洲有新加坡的机房。不管怎样，在&lt;a href=&#34;https://www.linode.com/speedtest&#34;&gt;这个页面&lt;/a&gt; 上做一些测速就知道怎么选了。我测试后发现新加坡的速度最好（物理优势），所以就选择了新加坡的机房；不过也不用担心，如果以后想换到别的机房，也是可以迁移的。&lt;/p&gt;

&lt;p&gt;选好机房就可以安装系统了，我选择的是最熟悉方便的 Ubuntu 系统，安装过程非常简单，也很快。启动机器后，可以 SSH 连接上去。&lt;/p&gt;

&lt;p&gt;购买的是最低的配置（&lt;a href=&#34;https://www.linode.com/pricing&#34;&gt;https://www.linode.com/pricing&lt;/a&gt;），不过对于个人应用，尤其是目前只有搭建 VPN 的需求来说，还是很奢侈的了。&lt;/p&gt;

&lt;h2 id=&#34;安装-shadowsocks:4855d9d6e5f234c654404b26568913d6&#34;&gt;安装 Shadowsocks&lt;/h2&gt;

&lt;p&gt;我用的是 Python 实现的版本，安装过程非常简单，文档上也有&lt;a href=&#34;https://github.com/shadowsocks/shadowsocks&#34;&gt;教程&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在 VPS 和本机都安装 shadowsocks：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install shadowsocks
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编写配置文件 shadowsocks.json（把 server 和 password 替换成自己的服务器 IP 和 shadowsocks 服务器的密码）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;server&amp;quot;:&amp;quot;my_server_ip&amp;quot;,
    &amp;quot;server_port&amp;quot;:8388,
    &amp;quot;local_address&amp;quot;: &amp;quot;127.0.0.1&amp;quot;,
    &amp;quot;local_port&amp;quot;:1080,
    &amp;quot;password&amp;quot;:&amp;quot;mypassword&amp;quot;,
    &amp;quot;timeout&amp;quot;:300,
    &amp;quot;method&amp;quot;:&amp;quot;aes-256-cfb&amp;quot;,
    &amp;quot;fast_open&amp;quot;: false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这份配置文件是客户端和服务端通用的，&lt;code&gt;local_address&lt;/code&gt; 和 &lt;code&gt;local_port&lt;/code&gt; 是客户端用的。&lt;/p&gt;

&lt;p&gt;在 VPS 上启动 shadowsocks 服务器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ssserver -c /path/to/shadowsocks.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在本机启动 shadowsocks 客户端：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sslocal -c /path/to/shadowsocks.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终使用的时候，VPN 配置的是本机的 shadowsocks，即 &lt;code&gt;127.0.0.1:1080&lt;/code&gt;，而不是直接连接服务端版本。&lt;/p&gt;

&lt;h2 id=&#34;chrome-使用-socks-代理:4855d9d6e5f234c654404b26568913d6&#34;&gt;Chrome 使用 socks 代理&lt;/h2&gt;

&lt;p&gt;Linux 系统可以配置全局的网络代理，Chrome 可以设置使用系统默认的代理配置，也可以使用 SwitchySharp 做更灵活的配置。&lt;/p&gt;

&lt;p&gt;使用过 GoAgent 的人应该都知道 SwitchySharp 这个 Chrome 插件。SwitchySharp 搭配使用 Shadowsocks 也很简单，只需要几步配置就可以实现：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;打开 SwitchySharp 的配置界面，新建一个情景模式，命名为 Shadowsocks&lt;/li&gt;
&lt;li&gt;详细配置页面，SOCKS 代理一栏，填写 IP &lt;code&gt;127.0.0.1&lt;/code&gt; 和 端口 &lt;code&gt;1080&lt;/code&gt;，选择 &amp;ldquo;SOCKS v5&amp;rdquo;，然后保存&lt;/li&gt;
&lt;li&gt;切换规则页面，把所有规则的情景模式从 GoAgent 改为 Shadowsocks，然后保存&lt;/li&gt;
&lt;li&gt;更新在线规则列表，情景模式选择 Shadowsocks；也可以手动添加规则&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;OK，完成。此后访问规则列表里的网站，都会走 Shadowsocks 的代理。如果使用过 SwitchySharp + GoAgent，即使没有截图，上面的配置很容易理解。&lt;/p&gt;

&lt;h2 id=&#34;命令行使用-socks-代理:4855d9d6e5f234c654404b26568913d6&#34;&gt;命令行使用 socks 代理&lt;/h2&gt;

&lt;p&gt;浏览器可以自由翻墙了，终端却仍然还在墙内，使用 curl，wget 和 go get 访问墙外资源时依然失败。&lt;/p&gt;

&lt;p&gt;Shadowsocks 的 wiki 上提供了&lt;a href=&#34;https://github.com/shadowsocks/shadowsocks/wiki/Using-Shadowsocks-with-Command-Line-Tools&#34;&gt;命令行工具使用代理的教程&lt;/a&gt;，不过我没有配置成功。后来找了另一个工具：&lt;a href=&#34;http://www.privoxy.org/&#34;&gt;Privoxy&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ubuntu 安装 Privoxy 非常简单：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install privoxy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装好后会有一个 privoxy 的命令，配置文件在 /etc/privoxy/ 目录下。Privoxy 是个 web 代理工具，提供了非常复杂的配置可以用来实现很强大的功能；不过对于我来说只需要使用一小部分。&lt;/p&gt;

&lt;p&gt;编辑 /etc/privoxy/config 文件，在最后添加这几行配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;forward-socks5  /               127.0.0.1:1080 .
listen-address  127.0.0.1:8118
# local network do not use proxy
forward         192.168.*.*/    .
forward         10.*.*.*/       .
forward         127.*.*.*/      .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;forward-socks5&lt;/code&gt; 这一行表示所有网络通过 socks5 代理，代理服务器是 &lt;code&gt;127.0.0.1:1080&lt;/code&gt;，即在本机启动的 Shadowsocks 客户端服务。最后三行是本地局域网不使用代理的配置。&lt;/p&gt;

&lt;p&gt;重启一下 privoxy：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo service privoxy restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在就可以在命令行里愉快的上网了，用 go get 安装各种 golang package 都非常顺利。&lt;/p&gt;

&lt;h2 id=&#34;android-手机使用-socks-代理:4855d9d6e5f234c654404b26568913d6&#34;&gt;Android 手机使用 socks 代理&lt;/h2&gt;

&lt;p&gt;Shadowsocks 真心人类的希望，还提供了 Android 的客户端：&lt;a href=&#34;https://github.com/shadowsocks/shadowsocks-android&#34;&gt;https://github.com/shadowsocks/shadowsocks-android&lt;/a&gt;，安装和配置过程都很简单，略去不表。&lt;/p&gt;

&lt;h2 id=&#34;后记:4855d9d6e5f234c654404b26568913d6&#34;&gt;后记&lt;/h2&gt;

&lt;p&gt;经过上面的一番折腾，基本上实现了全平台的翻墙上网，这种自由进出的感觉不是一般的舒畅。同时也感到一丝悲哀，本来很自然的东西，在这里却需要想方设法曲线救国才能得到。&lt;/p&gt;

&lt;p&gt;感谢 Shadowsocks 的作者们，编写了一个简单而强大的代理工具，造福于民。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>重用 SSH 连接</title>
      <link>http://deanthompson.github.io/posts/2015/03/reuse-ssh-connection</link>
      <pubDate>Sun, 15 Mar 2015 13:31:49 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/03/reuse-ssh-connection</guid>
      <description>&lt;p&gt;平时需要经常用到 SSH，比如登录远程服务器，用 Git 推送和更新代码等。建立一次 SSH 连接可能并不需要多久长时间，但是如果要频繁登录同一台服务器，就未免显得有些繁琐和浪费时间。如果是用用户名和密码登录，每次都要输入密码就更加让人崩溃。还有使用 Git 的时候，短时间内可能需要经常 &lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git push&lt;/code&gt;，如果每次操作都需要重新建立连接，等待过程就让人心生厌恶了。&lt;/p&gt;

&lt;p&gt;实际上，SSH 有个「鲜为人知」的特性可以做到重用连接，只有在第一次登录的时候会创建新的连接，后续的会话都可以重用这个已经存在的连接。这样，后续的登录就会非常快，而且不需要输入密码认证。配置也很简单，直接上代码。&lt;/p&gt;

&lt;p&gt;修改 &lt;code&gt;~/.ssh/config&lt;/code&gt; 文件，添加如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sshconfig&#34;&gt;Host *
    ControlMaster auto
    ControlPath /tmp/ssh_mux_%h_%p_%r
    ControlPersist 600
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;意思也很好理解：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Host *&lt;/code&gt; 这一行表示下面这些配置和规则影响到的 host，&lt;code&gt;*&lt;/code&gt; 表示所有的远程 host 都生效。如果要指定某个（些）特定的 host，可以使用类似 &lt;code&gt;Host *.example.com&lt;/code&gt; 的配置。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ControlMaster auto&lt;/code&gt; 这个选项告诉 SSH 客户端尝试重用现有的连接（master connection）。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ControlPath&lt;/code&gt; 指定了这个连接的 socket 保存的路径，这里配置的是在 /tmp 目录，实际上可以在任何有读写权限的路径下。&lt;code&gt;/tmp/ssh_mux_%h_%p_%r&lt;/code&gt; 配置了 socket 文件名，&lt;code&gt;%h&lt;/code&gt; 表示远程主机名（host），&lt;code&gt;%p&lt;/code&gt; 表示远程 SSH 服务器的端口（port），&lt;code&gt;%r&lt;/code&gt; 表示登录的远程用户名（remote user name）。这些 socket 可以随时删掉（&lt;code&gt;rm&lt;/code&gt;），删除后首次会话又会创建新的 master 连接。曾经遇到过这种情况，本地断网了，打开的几个远程终端都卡死，网络恢复后也一直这样，甚至打开新的终端也登录不上。这个时候只需要把之前的 socket 文件都删掉，重新登录就可以了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ControlPersist&lt;/code&gt; 这个选项比较重要，表示在创建首个连接（master connection）的会话退出后，master 连接仍然在后台保留，以便其他复用该连接的会话不会出现问题。这个特性在使用 Git 的时候就非常有用，在频繁提交和拉代码的时候，每次 SSH 会话都是很短暂的，如果 master 连接能保持在后台，后续的操作就会如丝般顺滑。&lt;/p&gt;

&lt;p&gt;只需要添加上面几行配置，SSH 的体验就瞬间上升了好几个档次，简直是懒人必备。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang 并发安全的 map 实现</title>
      <link>http://deanthompson.github.io/posts/2015/01/concurrent-safe-map-in-golang</link>
      <pubDate>Mon, 12 Jan 2015 15:01:15 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/01/concurrent-safe-map-in-golang</guid>
      <description>

&lt;p&gt;Golang 里面 map 不是并发安全的，这一点是众所周知的，而且官方文档也很早就给了解释：&lt;a href=&#34;http://golang.org/doc/faq#atomic_maps&#34;&gt;Why are map operations not defined to be atomic?&lt;/a&gt;. 也正如这个解释说的一样，要实现一个并发安全的 map 其实非常简单。&lt;/p&gt;

&lt;h2 id=&#34;并发安全:743dbbe92226f1ed32f110ba88fc33fe&#34;&gt;并发安全&lt;/h2&gt;

&lt;p&gt;实际上，大多数情况下，对一个 map 的访问都是读操作多于写操作，而且读的时候，是可以共享的。所以这种场景下，用一个 &lt;code&gt;sync.RWMutex&lt;/code&gt; 保护一下就是很好的选择：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type syncMap struct {
    items map[string]interface{}
    sync.RWMutex
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个结构体定义了一个并发安全的 string map，用一个 map 来保存数据，一个读写锁来保护安全。这个 map 可以被任意多的 goroutine 同时读，但是写的时候，会阻塞其他读写操作。添加上 &lt;code&gt;Get&lt;/code&gt;，&lt;code&gt;Set&lt;/code&gt;，&lt;code&gt;Delete&lt;/code&gt; 等方法，这个设计是能够工作的，而且大多数时候能表现不错。&lt;/p&gt;

&lt;p&gt;但是这种设计会有些性能隐患。主要是两个方面：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;读写锁的粒度太大了，保护了整个 map 的访问。写操作是阻塞的，此时其他任何读操作都无法进行。&lt;/li&gt;
&lt;li&gt;如果内部的 map 存储了很多 key，GC 的时候就需要扫描很久。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;分表:743dbbe92226f1ed32f110ba88fc33fe&#34;&gt;「分表」&lt;/h2&gt;

&lt;p&gt;一种解决思路是“分表”存储，具体实现就是，基于上面的 &lt;code&gt;syncMap&lt;/code&gt; 再包装一次，用多个 &lt;code&gt;syncMap&lt;/code&gt; 来模拟实现一个 map：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type SyncMap struct {
    shardCount uint8
    shards     []*syncMap
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这种设计用了一个 &lt;code&gt;*syncMap&lt;/code&gt; 的 slice 来保存数据，&lt;code&gt;shardCount&lt;/code&gt; 提供了分表量的可定制性。实际上 &lt;code&gt;shards&lt;/code&gt; 同样可以实现为 &lt;code&gt;map[string]*syncMap&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在这种设计下，数据（key:value）会被分散到不同的 &lt;code&gt;syncMap&lt;/code&gt;，而每个 &lt;code&gt;syncMap&lt;/code&gt; 又有自己底层的 map。数据分散了，锁也分散了，能够很大程度上提高随机访问性能。而且在数据量大、高并发、写操作频繁的场景下，这种提升会更加明显。&lt;/p&gt;

&lt;p&gt;那么数据如何被分配到指定的分块呢？一种很通用也很简单的方法就是 hash. 字符串的哈希算法有很多，byvoid 大神实现和比较了多种字符串 hash 函数（&lt;a href=&#34;https://www.byvoid.com/blog/string-hash-compare/&#34;&gt;各种字符串Hash函数比较&lt;/a&gt;），得出结论是：“BKDRHash无论是在实际效果还是编码实现中，效果都是最突出的”。这里采用了 BKDRHash 来实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;const seed uint32 = 131 // 31 131 1313 13131 131313 etc..

func bkdrHash(str string) uint32 {
    var h uint32

    for _, c := range str {
        h = h*seed + uint32(c)
    }

    return h
}

// Find the specific shard with the given key
func (m *SyncMap) locate(key string) *syncMap {
    return m.shards[bkdrHash(key)&amp;amp;uint32((m.shardCount-1))]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;locate&lt;/code&gt; 方法调用 &lt;code&gt;bkdrHash&lt;/code&gt; 函数计算一个 &lt;code&gt;key&lt;/code&gt; 的哈希值，然后用该值对分表量取模得到在 slice 的 &lt;code&gt;index&lt;/code&gt;，之后就能定位到对应的 &lt;code&gt;syncMap&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;这种实现足够简单，而且也有不错的性能表现。除了基本的 &lt;code&gt;Get&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt;、&lt;code&gt;Delete&lt;/code&gt; 等基本操作之外，迭代（&lt;code&gt;range&lt;/code&gt;）功能也非常有用。更多的功能和细节，都可以在源码里找到答案： &lt;a href=&#34;https://github.com/DeanThompson/syncmap&#34;&gt;https://github.com/DeanThompson/syncmap&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang 的 defer 语句</title>
      <link>http://deanthompson.github.io/posts/2014/12/defer-in-golang</link>
      <pubDate>Thu, 18 Dec 2014 15:35:38 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2014/12/defer-in-golang</guid>
      <description>&lt;p&gt;Golang 的 &lt;code&gt;defer&lt;/code&gt; 语句是个非常有用的语法，可以把一些函数调用放到一个列表里，在函数返回前延迟执行。这个功能可以很方便的在函数结束前处理一些清理操作。比如关闭打开的文件，关闭一个连接，解锁，捕捉 panic 等。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34;&gt;这篇 Go Blog&lt;/a&gt; 用例子讲解了 &lt;code&gt;defer&lt;/code&gt; 的用途和使用规则。总结一下主要就是三点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;传递给 &lt;code&gt;defer&lt;/code&gt; 语句的参数是在添加时就计算好的。比如下面的函数的输出将会是 &lt;code&gt;0&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func a() {
    i := 0
    defer fmt.Println(i)
    i++
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;多个 &lt;code&gt;defer&lt;/code&gt; 语句的执行顺序类似于 stack，即 Last In First Out. 比如下面的函数的输出将会是 &lt;code&gt;3210&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func b() {
    for i := 0; i &amp;lt; 4; i++ {
        defer fmt.Print(i)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;defer&lt;/code&gt; 语句可能会读取并修改函数的命名返回值（named return values）。比如下面的函数的返回值将会是 &lt;code&gt;2&lt;/code&gt; ，而不是 &lt;code&gt;1&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func c() (i int) {
    defer func() { i++ }()
    return 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;defer&lt;/code&gt; 语句配合 &lt;code&gt;panic&lt;/code&gt; 和 &lt;code&gt;recover&lt;/code&gt; 可以实现其它语言里的捕捉异常（try-catch-finally），在上面给出的链接里也有描述。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;defer&lt;/code&gt; 实在是一个非常好用的语法糖，平时写代码时也经常（几乎不可避免）用到。实际上，&lt;code&gt;defer&lt;/code&gt; 也是有些额外的开销的。&lt;/p&gt;

&lt;p&gt;最近在看 &lt;a href=&#34;https://github.com/revel/revel&#34;&gt;revel 框架&lt;/a&gt; 的一些源代码，其 cache 模块用了 robfig 实现的一个包 go-cache。go-cache 是一个 in-memroy 的 key:value 缓存实现，&lt;a href=&#34;https://github.com/robfig/go-cache/blob/master/cache.go#L65&#34;&gt;其中一个方法源码如下&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// Add an item to the cache, replacing any existing item. If the duration is 0,
// the cache&#39;s default expiration time is used. If it is -1, the item never
// expires.
func (c *cache) Set(k string, x interface{}, d time.Duration) {
    c.Lock()
    c.set(k, x, d)
    // TODO: Calls to mu.Unlock are currently not deferred because defer
    // adds ~200 ns (as of go1.)
    c.Unlock()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里没有用 &lt;code&gt;defer&lt;/code&gt; 来调用 &lt;code&gt;Unlock&lt;/code&gt;，而且在代码里明确注释说 &lt;code&gt;defer&lt;/code&gt; 会增加大约 200ns 的延迟。这是个很有意思的注释，因为平时虽然一直在用 &lt;code&gt;defer&lt;/code&gt;，却从没考虑过这一点。robfig 说 &lt;code&gt;defer&lt;/code&gt; 大概需要 200ns，一时兴起写了个&lt;a href=&#34;https://gist.github.com/DeanThompson/48365dc9472e0a64dba1&#34;&gt;简单的 benchmark 测试&lt;/a&gt;，来看看 Go 1.4 里究竟如何。&lt;/p&gt;

&lt;p&gt;这是某一次测试的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;testing: warning: no tests to run
PASS
BenchmarkDeferredUnlock     10000000            134 ns/op
BenchmarkNotDeferredUnlock  30000000            40.6 ns/op
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，&lt;code&gt;defer&lt;/code&gt; 大概需要 94ns，这对绝大多数应用来说几乎都是无关紧要的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>不要用 fmt.Sprintf 做类型转换</title>
      <link>http://deanthompson.github.io/posts/2014/06/donnot-use-fmt-sprintf-for-type-conversion</link>
      <pubDate>Wed, 11 Jun 2014 15:50:41 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2014/06/donnot-use-fmt-sprintf-for-type-conversion</guid>
      <description>

&lt;p&gt;严格的讲，应该是在把 &lt;code&gt;int&lt;/code&gt;，&lt;code&gt;float&lt;/code&gt;等类型转换为字符串时，不要用 &lt;code&gt;fmt.Sprintf&lt;/code&gt;，更好的做法是用标准库函数。&lt;code&gt;fmt.Sprintf&lt;/code&gt; 的用途是格式化字符串，接受的类型是 interface{}，内部使用了反射。所以，与相应的标准库函数相比，&lt;code&gt;fmt.Sprintf&lt;/code&gt; 需要更大的开销。大多数类型转换的函数都可以在 &lt;code&gt;strconv&lt;/code&gt; 包里找到。&lt;/p&gt;

&lt;h2 id=&#34;int-to-string:fa92a5344b4f2c93ba7190e9f429e269&#34;&gt;int to string&lt;/h2&gt;

&lt;p&gt;整数类型转换为字符串，推荐使用 &lt;code&gt;strconv.FormatInt&lt;/code&gt;（&lt;code&gt;int64&lt;/code&gt;），对于 &lt;code&gt;int&lt;/code&gt; 类型，&lt;code&gt;strconv.Itoa&lt;/code&gt; 对前者做了一个封装。&lt;/p&gt;

&lt;p&gt;比较一下 &lt;code&gt;strconv.FormatInt&lt;/code&gt; 和 &lt;code&gt;fmt.Sprintf&lt;/code&gt; 的时间开销：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;strconv&amp;quot;
    &amp;quot;time&amp;quot;
)

const LOOP = 10000

var num int64 = 10000

func main() {
    startTime := time.Now()
    for i := 0; i &amp;lt; LOOP; i++ {
        fmt.Sprintf(&amp;quot;%d&amp;quot;, num)
    }
    fmt.Printf(&amp;quot;fmt.Sprintf taken: %v\n&amp;quot;, time.Since(startTime))

    startTime = time.Now()
    for i := 0; i &amp;lt; LOOP; i++ {
        strconv.FormatInt(num, 10)
    }
    fmt.Printf(&amp;quot;strconv.FormatInt taken: %v\n&amp;quot;, time.Since(startTime))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中某一次运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;fmt.Sprintf taken: 2.995178ms
strconv.FormatInt taken: 1.057318ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多次运行结果都类似，结论是：&lt;code&gt;fmt.Sprintf&lt;/code&gt; 所需要的时间大约是 &lt;code&gt;strconv.FormatInt&lt;/code&gt; 的 3 倍。&lt;/p&gt;

&lt;p&gt;同理，对于 &lt;code&gt;float64&lt;/code&gt; 类型，推荐使用 &lt;code&gt;strconv.FormatFloat&lt;/code&gt;。测试代码和上面类似，得到的结论是：&lt;code&gt;fmt.Sprintf&lt;/code&gt; 所需要的时间大约是 &lt;code&gt;strconv.FormatFloat&lt;/code&gt; 的 1.1 倍。效果没有整型明显，但依然更高效。&lt;/p&gt;

&lt;h2 id=&#34;hexadecimal-to-string:fa92a5344b4f2c93ba7190e9f429e269&#34;&gt;hexadecimal to string&lt;/h2&gt;

&lt;p&gt;十六进制数到字符串的转换也很常见，尤其是在一些加解密程序中，如获取 md5 值。 &lt;code&gt;encoding/hex&lt;/code&gt; 包提供了十六进制数的编解码函数。&lt;/p&gt;

&lt;p&gt;下面比较一下 &lt;code&gt;fmt.Sprintf&lt;/code&gt; 和 &lt;code&gt;hex.EncodeToString&lt;/code&gt; 的时间开销：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;crypto/md5&amp;quot;
    &amp;quot;encoding/hex&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;io&amp;quot;
    &amp;quot;time&amp;quot;
)

const LOOP = 10000

func makeMd5(data string) []byte {
    h := md5.New()
    io.WriteString(h, data)
    return h.Sum(nil)
}

func main() {
    s := &amp;quot;123456&amp;quot;
    hexBytes := makeMd5(s)
    s1 := fmt.Sprintf(&amp;quot;%x&amp;quot;, hexBytes)
    s2 := hex.EncodeToString(hexBytes)
    fmt.Println(&amp;quot;result of fmt.Sprintf == hex.EncodeToString:&amp;quot;, s1 == s2) // 确保结果一致

    start := time.Now()
    for i := 0; i &amp;lt; LOOP; i++ {
        fmt.Sprintf(&amp;quot;%x&amp;quot;, hexBytes)
    }
    fmt.Printf(&amp;quot;fmt.Sprintf taken: %v\n&amp;quot;, time.Since(start))

    start = time.Now()
    for i := 0; i &amp;lt; LOOP; i++ {
        hex.EncodeToString(hexBytes)
    }
    fmt.Printf(&amp;quot;hex.EncodeToString taken: %v\n&amp;quot;, time.Since(start))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个程序某一次的运行结果是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;result of fmt.Sprintf == hex.EncodeToString: true
fmt.Sprintf taken: 10.285488ms
hex.EncodeToString taken: 2.080457ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多次运行结果都类似，可以得到一个结论：&lt;code&gt;fmt.Sprintf&lt;/code&gt; 所需要的时间大约是 &lt;code&gt;hex.EncodeToString&lt;/code&gt; 的 5 倍。&lt;/p&gt;

&lt;p&gt;这里只讨论了三种数据类型，对于其他类型的数据也是类似的。总之，在需要转换成字符串时，即使对性能要求不高，都尽量不要用 &lt;code&gt;fmt.Sprintf&lt;/code&gt;。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
