<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Posts on 李林克斯 </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://deanthompson.github.io/post/</link>
    <language>zh-CN</language>
    <author>Yangliang Li</author>
    
    <updated>Fri, 20 Mar 2015 11:00:13 CST</updated>
    
    <item>
      <title>用 Fabric 来发布代码</title>
      <link>http://deanthompson.github.io/posts/2015/03/deploy-applications-using-fabric</link>
      <pubDate>Fri, 20 Mar 2015 11:00:13 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/03/deploy-applications-using-fabric</guid>
      <description>&lt;p&gt;写代码的时候很爽，本地开发一下子完成了，等到部署发布代码的时候就有些烦了。开发环境、测试环境、生产环境，有些配置是因环境而异的，在我们的 Python 项目里，一直保留这样的习惯：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用 py 文件做配置文件&lt;/li&gt;
&lt;li&gt;固定的配置，放在 settings.py 里&lt;/li&gt;
&lt;li&gt;不同环境可能要修改的，放在 site_settings.py 里，然后在 settings.py 里全部 import 进去&lt;/li&gt;
&lt;li&gt;需要使用配置的时候，只需要 &lt;code&gt;settings.FOO&lt;/code&gt; 就可以&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实际上，这样的习惯在发布代码时带来了一些小麻烦。曾经用过这些方式发布 Python 代码：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;rsync. 实际上用 rsync 发布的体验还挺好的，每次只会同步更新过的文件，而且可以配置不需要同步的文件。在使用 rsync 时，site_settings.py 是没有同步的。但是个人体验，rsync 也有不好的地方，首先就是需要依赖 rsync 服务，在远程机器和本地都要配置；二是不好做备份。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git. 应该说，git 应该是我最喜欢的发布方式了，本地 push，远程 pull，完事；而且还很好备份和回滚。再有，如果我「作死」在服务器上修改调试代码，能方便的提交到版本库。但是，考虑到安全问题，很多 git 服务器都搭建在内网，服务器上根本就无法访问到。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;scp. 这是很 low 的一种做法，也基本上是我最后的选择。刚入职到现在这家公司，新部门，有点蛮荒时代的感觉。（非常简陋的）git 服务器在内网，所以在服务器上搞了一下 rsync，配置好后发现本地无法连接到服务器的 873 端口（不知道是不是公司配置了防火墙）。一时间就堕落到选择了 scp. 好处几乎没有，不方便的地方倒是一大堆：不方便增量更新，只能全部覆盖，考虑到 site_settings.py 的存在，这个很不方便；不方便设置要排除的文件，如果想省事把整个项目 scp 过去，就会把 .git 目录和 .pyc 文件也拷过去，无用而慢。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但实际上这些天我还使用了好几次 scp 来发布代码，一直在重复体力劳动。终于，想起了 &lt;a href=&#34;http://www.fabfile.org/&#34;&gt;fabric&lt;/a&gt;，带我「脱离苦海」。&lt;/p&gt;

&lt;p&gt;fabric 使用起来非常简单，对我来说，只需要简单几行代码的配置，就能自动完成我之前繁复的体力劳动。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# -*- coding: utf-8 -*-

import os

from fabric.api import env, local, cd, lcd, put, run


def prod():
    env.hosts = [&amp;quot;123.123.123.123&amp;quot;]
    env.user = &amp;quot;test&amp;quot;
    # env.password = &amp;quot;&amp;quot;  # 如果这里写了密码，在发布时就不用输密码了


def pyclean():
    local(&amp;quot;pyclean .&amp;quot;)      # local 函数执行本地命令


def deploy():
    pyclean()

    local_app_dir = &amp;quot;~/workspace/projects/&amp;quot;
    remote_app_dir = &amp;quot;~/projects&amp;quot;

    # lcd 是 「local cd」，cd 是在远程服务器执行 cd
    with lcd(local_app_dir), cd(remote_app_dir):
        # 1. backup
        run(&amp;quot;rm -rf SomeProj.bak&amp;quot;)          # run 是在远程服务器上执行命令
        run(&amp;quot;mv SomeProj SomeProj.bak&amp;quot;)

        # 2. transfer
        d = os.path.join(remote_app_dir, &amp;quot;SomeProj&amp;quot;)
        run(&amp;quot;mkdir -p %s&amp;quot; % d)
        put(&amp;quot;SomeProj/*&amp;quot;, &amp;quot;SomeProj&amp;quot;)   # put 把本地文件传输到远程（看了下源码，是 FTP 协议）

        # 3. replace site_settings.py
        for subdir in [&amp;quot;apps&amp;quot;, &amp;quot;admin&amp;quot;, &amp;quot;core&amp;quot;]:
            src = &amp;quot;SomeProj.bak/%s/configs/site_settings.py&amp;quot; % subdir
            dest = &amp;quot;SomeProj/%s/configs/site_settings.py&amp;quot; % subdir
            cmd = &amp;quot;cp %s %s&amp;quot; % (src, dest)
            run(cmd)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把上面的代码保存为 fabfile.py，要发布的时候，只需在 fabfile.py 所在的路径执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;fab prod deploy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为在 env 配置里没有设置密码，所以执行过程中需要手动输入一下。然后 fabric 就把所有你指定的事情都干了，一次配置，终生享福。&lt;/p&gt;

&lt;p&gt;实际上还可以配置在发布好代码后，重启应用（supervisorctl）。为了避免意外，和某些情况下需要修改 site_settings.py，所以就没有这么干，而是选择每次都手动重启。&lt;/p&gt;

&lt;p&gt;fabric，又是一个懒人必备的神器。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>重用 SSH 连接</title>
      <link>http://deanthompson.github.io/posts/2015/03/reuse-ssh-connection</link>
      <pubDate>Sun, 15 Mar 2015 13:31:49 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/03/reuse-ssh-connection</guid>
      <description>&lt;p&gt;平时需要经常用到 SSH，比如登录远程服务器，用 Git 推送和更新代码等。建立一次 SSH 连接可能并不需要多久长时间，但是如果要频繁登录同一台服务器，就未免显得有些繁琐和浪费时间。如果是用用户名和密码登录，每次都要输入密码就更加让人崩溃。还有使用 Git 的时候，短时间内可能需要经常 &lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git push&lt;/code&gt;，如果每次操作都需要重新建立连接，等待过程就让人心生厌恶了。&lt;/p&gt;

&lt;p&gt;实际上，SSH 有个「鲜为人知」的特性可以做到重用连接，只有在第一次登录的时候会创建新的连接，后续的会话都可以重用这个已经存在的连接。这样，后续的登录就会非常快，而且不需要输入密码认证。配置也很简单，直接上代码。&lt;/p&gt;

&lt;p&gt;修改 &lt;code&gt;~/.ssh/config&lt;/code&gt; 文件，添加如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sshconfig&#34;&gt;Host *
    ControlMaster auto
    ControlPath /tmp/ssh_mux_%h_%p_%r
    ControlPersist 600
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;意思也很好理解：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Host *&lt;/code&gt; 这一行表示下面这些配置和规则影响到的 host，&lt;code&gt;*&lt;/code&gt; 表示所有的远程 host 都生效。如果要指定某个（些）特定的 host，可以使用类似 &lt;code&gt;Host *.example.com&lt;/code&gt; 的配置。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ControlMaster auto&lt;/code&gt; 这个选项告诉 SSH 客户端尝试重用现有的连接（master connection）。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ControlPath&lt;/code&gt; 指定了这个连接的 socket 保存的路径，这里配置的是在 /tmp 目录，实际上可以在任何有读写权限的路径下。&lt;code&gt;/tmp/ssh_mux_%h_%p_%r&lt;/code&gt; 配置了 socket 文件名，&lt;code&gt;%h&lt;/code&gt; 表示远程主机名（host），&lt;code&gt;%p&lt;/code&gt; 表示远程 SSH 服务器的端口（port），&lt;code&gt;%r&lt;/code&gt; 表示登录的远程用户名（remote user name）。这些 socket 可以随时删掉（&lt;code&gt;rm&lt;/code&gt;），删除后首次会话又会创建新的 master 连接。曾经遇到过这种情况，本地断网了，打开的几个远程终端都卡死，网络恢复后也一直这样，甚至打开新的终端也登录不上。这个时候只需要把之前的 socket 文件都删掉，重新登录就可以了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ControlPersist&lt;/code&gt; 这个选项比较重要，表示在创建首个连接（master connection）的会话退出后，master 连接仍然在后台保留，以便其他复用该连接的会话不会出现问题。这个特性在使用 Git 的时候就非常有用，在频繁提交和拉代码的时候，每次 SSH 会话都是很短暂的，如果 master 连接能保持在后台，后续的操作就会如丝般顺滑。&lt;/p&gt;

&lt;p&gt;只需要添加上面几行配置，SSH 的体验就瞬间上升了好几个档次，简直是懒人必备。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang 并发安全的 map 实现</title>
      <link>http://deanthompson.github.io/posts/2015/01/concurrent-safe-map-in-golang</link>
      <pubDate>Mon, 12 Jan 2015 15:01:15 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/01/concurrent-safe-map-in-golang</guid>
      <description>

&lt;p&gt;Golang 里面 map 不是并发安全的，这一点是众所周知的，而且官方文档也很早就给了解释：&lt;a href=&#34;http://golang.org/doc/faq#atomic_maps&#34;&gt;Why are map operations not defined to be atomic?&lt;/a&gt;. 也正如这个解释说的一样，要实现一个并发安全的 map 其实非常简单。&lt;/p&gt;

&lt;h2 id=&#34;并发安全:743dbbe92226f1ed32f110ba88fc33fe&#34;&gt;并发安全&lt;/h2&gt;

&lt;p&gt;实际上，大多数情况下，对一个 map 的访问都是读操作多于写操作，而且读的时候，是可以共享的。所以这种场景下，用一个 &lt;code&gt;sync.RWMutex&lt;/code&gt; 保护一下就是很好的选择：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type syncMap struct {
    items map[string]interface{}
    sync.RWMutex
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个结构体定义了一个并发安全的 string map，用一个 map 来保存数据，一个读写锁来保护安全。这个 map 可以被任意多的 goroutine 同时读，但是写的时候，会阻塞其他读写操作。添加上 &lt;code&gt;Get&lt;/code&gt;，&lt;code&gt;Set&lt;/code&gt;，&lt;code&gt;Delete&lt;/code&gt; 等方法，这个设计是能够工作的，而且大多数时候能表现不错。&lt;/p&gt;

&lt;p&gt;但是这种设计会有些性能隐患。主要是两个方面：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;读写锁的粒度太大了，保护了整个 map 的访问。写操作是阻塞的，此时其他任何读操作都无法进行。&lt;/li&gt;
&lt;li&gt;如果内部的 map 存储了很多 key，GC 的时候就需要扫描很久。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;分表:743dbbe92226f1ed32f110ba88fc33fe&#34;&gt;「分表」&lt;/h2&gt;

&lt;p&gt;一种解决思路是“分表”存储，具体实现就是，基于上面的 &lt;code&gt;syncMap&lt;/code&gt; 再包装一次，用多个 &lt;code&gt;syncMap&lt;/code&gt; 来模拟实现一个 map：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type SyncMap struct {
    shardCount uint8
    shards     []*syncMap
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这种设计用了一个 &lt;code&gt;*syncMap&lt;/code&gt; 的 slice 来保存数据，&lt;code&gt;shardCount&lt;/code&gt; 提供了分表量的可定制性。实际上 &lt;code&gt;shards&lt;/code&gt; 同样可以实现为 &lt;code&gt;map[string]*syncMap&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在这种设计下，数据（key:value）会被分散到不同的 &lt;code&gt;syncMap&lt;/code&gt;，而每个 &lt;code&gt;syncMap&lt;/code&gt; 又有自己底层的 map。数据分散了，锁也分散了，能够很大程度上提高随机访问性能。而且在数据量大、高并发、写操作频繁的场景下，这种提升会更加明显。&lt;/p&gt;

&lt;p&gt;那么数据如何被分配到指定的分块呢？一种很通用也很简单的方法就是 hash. 字符串的哈希算法有很多，byvoid 大神实现和比较了多种字符串 hash 函数（&lt;a href=&#34;https://www.byvoid.com/blog/string-hash-compare/&#34;&gt;各种字符串Hash函数比较&lt;/a&gt;），得出结论是：“BKDRHash无论是在实际效果还是编码实现中，效果都是最突出的”。这里采用了 BKDRHash 来实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;const seed uint32 = 131 // 31 131 1313 13131 131313 etc..

func bkdrHash(str string) uint32 {
    var h uint32

    for _, c := range str {
        h = h*seed + uint32(c)
    }

    return h
}

// Find the specific shard with the given key
func (m *SyncMap) locate(key string) *syncMap {
    return m.shards[bkdrHash(key)&amp;amp;uint32((m.shardCount-1))]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;locate&lt;/code&gt; 方法调用 &lt;code&gt;bkdrHash&lt;/code&gt; 函数计算一个 &lt;code&gt;key&lt;/code&gt; 的哈希值，然后用该值对分表量取模得到在 slice 的 &lt;code&gt;index&lt;/code&gt;，之后就能定位到对应的 &lt;code&gt;syncMap&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;这种实现足够简单，而且也有不错的性能表现。除了基本的 &lt;code&gt;Get&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt;、&lt;code&gt;Delete&lt;/code&gt; 等基本操作之外，迭代（&lt;code&gt;range&lt;/code&gt;）功能也非常有用。更多的功能和细节，都可以在源码里找到答案： &lt;a href=&#34;https://github.com/DeanThompson/syncmap&#34;&gt;https://github.com/DeanThompson/syncmap&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang 的 defer 语句</title>
      <link>http://deanthompson.github.io/posts/2014/12/defer-in-golang</link>
      <pubDate>Thu, 18 Dec 2014 15:35:38 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2014/12/defer-in-golang</guid>
      <description>&lt;p&gt;Golang 的 &lt;code&gt;defer&lt;/code&gt; 语句是个非常有用的语法，可以把一些函数调用放到一个列表里，在函数返回前延迟执行。这个功能可以很方便的在函数结束前处理一些清理操作。比如关闭打开的文件，关闭一个连接，解锁，捕捉 panic 等。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34;&gt;这篇 Go Blog&lt;/a&gt; 用例子讲解了 &lt;code&gt;defer&lt;/code&gt; 的用途和使用规则。总结一下主要就是三点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;传递给 &lt;code&gt;defer&lt;/code&gt; 语句的参数是在添加时就计算好的。比如下面的函数的输出将会是 &lt;code&gt;0&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func a() {
    i := 0
    defer fmt.Println(i)
    i++
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;多个 &lt;code&gt;defer&lt;/code&gt; 语句的执行顺序类似于 stack，即 Last In First Out. 比如下面的函数的输出将会是 &lt;code&gt;3210&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func b() {
    for i := 0; i &amp;lt; 4; i++ {
        defer fmt.Print(i)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;defer&lt;/code&gt; 语句可能会读取并修改函数的命名返回值（named return values）。比如下面的函数的返回值将会是 &lt;code&gt;2&lt;/code&gt; ，而不是 &lt;code&gt;1&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func c() (i int) {
    defer func() { i++ }()
    return 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;defer&lt;/code&gt; 语句配合 &lt;code&gt;panic&lt;/code&gt; 和 &lt;code&gt;recover&lt;/code&gt; 可以实现其它语言里的捕捉异常（try-catch-finally），在上面给出的链接里也有描述。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;defer&lt;/code&gt; 实在是一个非常好用的语法糖，平时写代码时也经常（几乎不可避免）用到。实际上，&lt;code&gt;defer&lt;/code&gt; 也是有些额外的开销的。&lt;/p&gt;

&lt;p&gt;最近在看 &lt;a href=&#34;https://github.com/revel/revel&#34;&gt;revel 框架&lt;/a&gt; 的一些源代码，其 cache 模块用了 robfig 实现的一个包 go-cache。go-cache 是一个 in-memroy 的 key:value 缓存实现，&lt;a href=&#34;https://github.com/robfig/go-cache/blob/master/cache.go#L65&#34;&gt;其中一个方法源码如下&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// Add an item to the cache, replacing any existing item. If the duration is 0,
// the cache&#39;s default expiration time is used. If it is -1, the item never
// expires.
func (c *cache) Set(k string, x interface{}, d time.Duration) {
    c.Lock()
    c.set(k, x, d)
    // TODO: Calls to mu.Unlock are currently not deferred because defer
    // adds ~200 ns (as of go1.)
    c.Unlock()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里没有用 &lt;code&gt;defer&lt;/code&gt; 来调用 &lt;code&gt;Unlock&lt;/code&gt;，而且在代码里明确注释说 &lt;code&gt;defer&lt;/code&gt; 会增加大约 200ns 的延迟。这是个很有意思的注释，因为平时虽然一直在用 &lt;code&gt;defer&lt;/code&gt;，却从没考虑过这一点。robfig 说 &lt;code&gt;defer&lt;/code&gt; 大概需要 200ns，一时兴起写了个&lt;a href=&#34;https://gist.github.com/DeanThompson/48365dc9472e0a64dba1&#34;&gt;简单的 benchmark 测试&lt;/a&gt;，来看看 Go 1.4 里究竟如何。&lt;/p&gt;

&lt;p&gt;这是某一次测试的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;testing: warning: no tests to run
PASS
BenchmarkDeferredUnlock     10000000            134 ns/op
BenchmarkNotDeferredUnlock  30000000            40.6 ns/op
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，&lt;code&gt;defer&lt;/code&gt; 大概需要 94ns，这对绝大多数应用来说几乎都是无关紧要的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>不要用 fmt.Sprintf 做类型转换</title>
      <link>http://deanthompson.github.io/posts/2014/06/donnot-use-fmt-sprintf-for-type-conversion</link>
      <pubDate>Wed, 11 Jun 2014 15:50:41 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2014/06/donnot-use-fmt-sprintf-for-type-conversion</guid>
      <description>

&lt;p&gt;严格的讲，应该是在把 &lt;code&gt;int&lt;/code&gt;，&lt;code&gt;float&lt;/code&gt;等类型转换为字符串时，不要用 &lt;code&gt;fmt.Sprintf&lt;/code&gt;，更好的做法是用标准库函数。&lt;code&gt;fmt.Sprintf&lt;/code&gt; 的用途是格式化字符串，接受的类型是 interface{}，内部使用了反射。所以，与相应的标准库函数相比，&lt;code&gt;fmt.Sprintf&lt;/code&gt; 需要更大的开销。大多数类型转换的函数都可以在 &lt;code&gt;strconv&lt;/code&gt; 包里找到。&lt;/p&gt;

&lt;h2 id=&#34;int-to-string:fa92a5344b4f2c93ba7190e9f429e269&#34;&gt;int to string&lt;/h2&gt;

&lt;p&gt;整数类型转换为字符串，推荐使用 &lt;code&gt;strconv.FormatInt&lt;/code&gt;（&lt;code&gt;int64&lt;/code&gt;），对于 &lt;code&gt;int&lt;/code&gt; 类型，&lt;code&gt;strconv.Itoa&lt;/code&gt; 对前者做了一个封装。&lt;/p&gt;

&lt;p&gt;比较一下 &lt;code&gt;strconv.FormatInt&lt;/code&gt; 和 &lt;code&gt;fmt.Sprintf&lt;/code&gt; 的时间开销：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;strconv&amp;quot;
    &amp;quot;time&amp;quot;
)

const LOOP = 10000

var num int64 = 10000

func main() {
    startTime := time.Now()
    for i := 0; i &amp;lt; LOOP; i++ {
        fmt.Sprintf(&amp;quot;%d&amp;quot;, num)
    }
    fmt.Printf(&amp;quot;fmt.Sprintf taken: %v\n&amp;quot;, time.Since(startTime))

    startTime = time.Now()
    for i := 0; i &amp;lt; LOOP; i++ {
        strconv.FormatInt(num, 10)
    }
    fmt.Printf(&amp;quot;strconv.FormatInt taken: %v\n&amp;quot;, time.Since(startTime))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中某一次运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;fmt.Sprintf taken: 2.995178ms
strconv.FormatInt taken: 1.057318ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多次运行结果都类似，结论是：&lt;code&gt;fmt.Sprintf&lt;/code&gt; 所需要的时间大约是 &lt;code&gt;strconv.FormatInt&lt;/code&gt; 的 3 倍。&lt;/p&gt;

&lt;p&gt;同理，对于 &lt;code&gt;float64&lt;/code&gt; 类型，推荐使用 &lt;code&gt;strconv.FormatFloat&lt;/code&gt;。测试代码和上面类似，得到的结论是：&lt;code&gt;fmt.Sprintf&lt;/code&gt; 所需要的时间大约是 &lt;code&gt;strconv.FormatFloat&lt;/code&gt; 的 1.1 倍。效果没有整型明显，但依然更高效。&lt;/p&gt;

&lt;h2 id=&#34;hexadecimal-to-string:fa92a5344b4f2c93ba7190e9f429e269&#34;&gt;hexadecimal to string&lt;/h2&gt;

&lt;p&gt;十六进制数到字符串的转换也很常见，尤其是在一些加解密程序中，如获取 md5 值。 &lt;code&gt;encoding/hex&lt;/code&gt; 包提供了十六进制数的编解码函数。&lt;/p&gt;

&lt;p&gt;下面比较一下 &lt;code&gt;fmt.Sprintf&lt;/code&gt; 和 &lt;code&gt;hex.EncodeToString&lt;/code&gt; 的时间开销：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;crypto/md5&amp;quot;
    &amp;quot;encoding/hex&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;io&amp;quot;
    &amp;quot;time&amp;quot;
)

const LOOP = 10000

func makeMd5(data string) []byte {
    h := md5.New()
    io.WriteString(h, data)
    return h.Sum(nil)
}

func main() {
    s := &amp;quot;123456&amp;quot;
    hexBytes := makeMd5(s)
    s1 := fmt.Sprintf(&amp;quot;%x&amp;quot;, hexBytes)
    s2 := hex.EncodeToString(hexBytes)
    fmt.Println(&amp;quot;result of fmt.Sprintf == hex.EncodeToString:&amp;quot;, s1 == s2) // 确保结果一致

    start := time.Now()
    for i := 0; i &amp;lt; LOOP; i++ {
        fmt.Sprintf(&amp;quot;%x&amp;quot;, hexBytes)
    }
    fmt.Printf(&amp;quot;fmt.Sprintf taken: %v\n&amp;quot;, time.Since(start))

    start = time.Now()
    for i := 0; i &amp;lt; LOOP; i++ {
        hex.EncodeToString(hexBytes)
    }
    fmt.Printf(&amp;quot;hex.EncodeToString taken: %v\n&amp;quot;, time.Since(start))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个程序某一次的运行结果是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;result of fmt.Sprintf == hex.EncodeToString: true
fmt.Sprintf taken: 10.285488ms
hex.EncodeToString taken: 2.080457ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多次运行结果都类似，可以得到一个结论：&lt;code&gt;fmt.Sprintf&lt;/code&gt; 所需要的时间大约是 &lt;code&gt;hex.EncodeToString&lt;/code&gt; 的 5 倍。&lt;/p&gt;

&lt;p&gt;这里只讨论了三种数据类型，对于其他类型的数据也是类似的。总之，在需要转换成字符串时，即使对性能要求不高，都尽量不要用 &lt;code&gt;fmt.Sprintf&lt;/code&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang 排序</title>
      <link>http://deanthompson.github.io/posts/2014/06/sort-in-golang</link>
      <pubDate>Tue, 03 Jun 2014 16:50:50 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2014/06/sort-in-golang</guid>
      <description>

&lt;h2 id=&#34;interface-接口:a0aceb8e02a4cd06e9365f18ce315aea&#34;&gt;Interface 接口&lt;/h2&gt;

&lt;p&gt;Go 语言标准库提供了排序的package sort，也实现了对 &lt;code&gt;int&lt;/code&gt;， &lt;code&gt;float64&lt;/code&gt; 和 &lt;code&gt;string&lt;/code&gt; 三种基础类型的排序接口。所有排序调用 &lt;code&gt;sort.Sort&lt;/code&gt;，内部根据排序数据个数自动切换排序算法（堆排、快排、插排）。下面这段代码出自 Go 标准库 sort/sort.go：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func quickSort(data Interface, a, b, maxDepth int) {
    for b-a &amp;gt; 7 {
        if maxDepth == 0 {
            heapSort(data, a, b)
            return
        }
        maxDepth--
        mlo, mhi := doPivot(data, a, b)
        // Avoiding recursion on the larger subproblem guarantees
        // a stack depth of at most lg(b-a).
        if mlo-a &amp;lt; b-mhi {
            quickSort(data, a, mlo, maxDepth)
            a = mhi // i.e., quickSort(data, mhi, b)
        } else {
            quickSort(data, mhi, b, maxDepth)
            b = mlo // i.e., quickSort(data, a, mlo)
        }
    }
    if b-a &amp;gt; 1 {
        insertionSort(data, a, b)
    }
}

// Sort sorts data.
// It makes one call to data.Len to determine n, and O(n*log(n)) calls to
// data.Less and data.Swap. The sort is not guaranteed to be stable.
func Sort(data Interface) {
    // Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
    n := data.Len()
    maxDepth := 0
    for i := n; i &amp;gt; 0; i &amp;gt;&amp;gt;= 1 {
        maxDepth++
    }
    maxDepth *= 2
    quickSort(data, 0, n, maxDepth)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里不详细探讨排序算法的实现和性能细节，主要写一下如何使用标准库对基础数据进行排序，以及如何实现对自定义类型的数据进行排序。&lt;/p&gt;

&lt;p&gt;标准库提供一个通用接口，只要实现了这个接口，就可以通过调用 &lt;code&gt;sort.Sort&lt;/code&gt; 来排序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Interface interface {
    // Len is the number of elements in the collection.
    Len() int
    // Less returns whether the element with index i should sort
    // before the element with index j.
    Less(i, j int) bool
    // Swap swaps the elements with indexes i and j.
    Swap(i, j int)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;基本数据类型的排序:a0aceb8e02a4cd06e9365f18ce315aea&#34;&gt;基本数据类型的排序&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Interface&lt;/code&gt; 接口的三个函数分别用于获取长度（&lt;code&gt;Len&lt;/code&gt;）、大小比较（&lt;code&gt;Less&lt;/code&gt;）和交换（&lt;code&gt;Swap&lt;/code&gt;）。对 &lt;code&gt;int&lt;/code&gt;、&lt;code&gt;float64&lt;/code&gt; 和 &lt;code&gt;string&lt;/code&gt; 的排序，标准库已经做好了封装，直接调用即可。以 &lt;code&gt;int&lt;/code&gt; 为例简单说明：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main                                                                                                                                                                                                 

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;sort&amp;quot;
)

func main() {
    a := []int{100, 5, 29, 3, 76} 
    fmt.Println(a)     // [100 5 29 3 76]
    sort.Ints(a)       // sort.Sort(IntSlice(a)) 的封装
    fmt.Println(a)     // [3 5 29 76 100]，默认的 Less() 实现的是升序

    a = []int{100, 5, 29, 3, 76} 
    fmt.Println(a)     // [100 5 29 3 76]
    sort.Sort(sort.Reverse(sort.IntSlice(a)))
    fmt.Println(a)     // [100 76 29 5 3]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对 &lt;code&gt;float64&lt;/code&gt; 和 &lt;code&gt;string&lt;/code&gt; 的排序，和上面类似。需要注意的是，默认的 &lt;code&gt;sort.Less&lt;/code&gt; 实现的是升序排列，如果想要让结果降序，可以先用 &lt;code&gt;sort.Reverse&lt;/code&gt; 包装一次。这个调用会得到一个 &lt;code&gt;reverse&lt;/code&gt; 的类型，包含一个 &lt;code&gt;Interface&lt;/code&gt; 的匿名字段，其 &lt;code&gt;Less&lt;/code&gt; 函数与 &lt;code&gt;Interface&lt;/code&gt; 里的相反，从而实现逆序。&lt;/p&gt;

&lt;h2 id=&#34;自定义数据类型的排序:a0aceb8e02a4cd06e9365f18ce315aea&#34;&gt;自定义数据类型的排序&lt;/h2&gt;

&lt;p&gt;如果要对自定义的数据类型进行排序，需要实现 &lt;code&gt;sort.Interface&lt;/code&gt; 接口，也就是实现 &lt;code&gt;Len&lt;/code&gt;、&lt;code&gt;Less&lt;/code&gt; 和 &lt;code&gt;Swap&lt;/code&gt; 三个函数。很多场景下 &lt;code&gt;Len&lt;/code&gt; 和 &lt;code&gt;Swap&lt;/code&gt; 基本上和数据类型无关，所以实际上只有 &lt;code&gt;Less&lt;/code&gt; 会有差别。&lt;/p&gt;

&lt;p&gt;例如有个游戏下载排行榜，知道游戏ID和对应的下载量，需要把数据根据下载量进行排序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;math/rand&amp;quot;
    &amp;quot;sort&amp;quot;
)

type GameDownloadItem struct {
    GameID        int // 游戏ID
    DownloadTimes int // 下载次数
}

func (self GameDownloadItem) String() string {
    return fmt.Sprintf(&amp;quot;&amp;lt;Item(%d, %d)&amp;gt;&amp;quot;, self.GameID, self.DownloadTimes)
}

type GameDownloadSlice []*GameDownloadItem

func (p GameDownloadSlice) Len() int {
    return len(p)
}

func (p GameDownloadSlice) Swap(i int, j int) {
    p[i], p[j] = p[j], p[i]
}

// 根据游戏下载量 降序 排列
func (p GameDownloadSlice) Less(i int, j int) bool {
    return p[i].DownloadTimes &amp;gt; p[j].DownloadTimes
}

func main() {
    a := make(GameDownloadSlice, 7)
    for i := 0; i &amp;lt; len(a); i++ {
        a[i] = &amp;amp;GameDownloadItem{i + 1, rand.Intn(1000)}
    }

    fmt.Println(a)
    sort.Sort(a)
    fmt.Println(a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一次输出结果是随机（每次运行结果都一样）生成的未排序的数据：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;[&amp;lt;Item(1, 81)&amp;gt; &amp;lt;Item(2, 887)&amp;gt; &amp;lt;Item(3, 847)&amp;gt; &amp;lt;Item(4, 59)&amp;gt; &amp;lt;Item(5, 81)&amp;gt; &amp;lt;Item(6, 318)&amp;gt; &amp;lt;Item(7, 425)&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;排序后：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;[&amp;lt;Item(2, 887)&amp;gt; &amp;lt;Item(3, 847)&amp;gt; &amp;lt;Item(7, 425)&amp;gt; &amp;lt;Item(6, 318)&amp;gt; &amp;lt;Item(1, 81)&amp;gt; &amp;lt;Item(5, 81)&amp;gt; &amp;lt;Item(4, 59)&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vs-python:a0aceb8e02a4cd06e9365f18ce315aea&#34;&gt;Vs. Python&lt;/h2&gt;

&lt;p&gt;相比之下，Python 里的排序就非常简单便捷了，直接调用 &lt;code&gt;list&lt;/code&gt; 的 &lt;code&gt;sort&lt;/code&gt; 方法（in-place）即可，还可以用 built-in 函数 &lt;code&gt;sorted&lt;/code&gt; （返回新列表）。对于自定义类型指定属性，或 tuple 指定列的排序也很简单，只需要重新定义一下 &lt;code&gt;sort&lt;/code&gt; 方法的 &lt;code&gt;key&lt;/code&gt; 参数。对于上面游戏下载量排序的例子，下面是 python 实现版本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python                                                                                                                                                                                        
# -*- coding: utf-8 -*-

import random

class GameDownloadItem(object):

    def __init__(self, game_id, download_times):
        self.game_id = game_id
        self.download_times = download_times

    def __str__(self):
        return &#39;&amp;lt;Item(%d, %d)&amp;gt;&#39; % (self.game_id, self.download_times)

def display(items):
    for item in items:
        print item,
    print &#39;\n&#39;


if __name__ == &amp;quot;__main__&amp;quot;:
    items = [GameDownloadItem(i+1, random.randrange(1000)) for i in range(7)]
    display(items)

    items.sort(key=lambda item: item.download_times, reverse=True)
    display(items)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;某一次的执行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;&amp;lt;Item(1, 819)&amp;gt; &amp;lt;Item(2, 959)&amp;gt; &amp;lt;Item(3, 812)&amp;gt; &amp;lt;Item(4, 193)&amp;gt; &amp;lt;Item(5, 408)&amp;gt; &amp;lt;Item(6, 884)&amp;gt; &amp;lt;Item(7, 849)&amp;gt; 

&amp;lt;Item(2, 959)&amp;gt; &amp;lt;Item(6, 884)&amp;gt; &amp;lt;Item(7, 849)&amp;gt; &amp;lt;Item(1, 819)&amp;gt; &amp;lt;Item(3, 812)&amp;gt; &amp;lt;Item(5, 408)&amp;gt; &amp;lt;Item(4, 193)&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>MySQL参数：innodb_flush_log_at_trx_commit 和 sync_binlog</title>
      <link>http://deanthompson.github.io/posts/2014/03/innodb_flush_log_at_trx_commit-and-sync_binlog</link>
      <pubDate>Sun, 02 Mar 2014 16:16:04 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2014/03/innodb_flush_log_at_trx_commit-and-sync_binlog</guid>
      <description>

&lt;p&gt;&lt;code&gt;innodb_flush_log_at_trx_commit&lt;/code&gt; 和 &lt;code&gt;sync_binlog&lt;/code&gt; 是 MySQL 的两个配置参数，前者是 InnoDB 引擎特有的。之所以把这两个参数放在一起讨论，是因为在实际应用中，它们的配置对于 MySQL 的性能有很大影响。&lt;/p&gt;

&lt;h2 id=&#34;1-innodb-flush-log-at-trx-commit:59ae80d39a9fc958db330bc7cfc3b146&#34;&gt;1. innodb_flush_log_at_trx_commit&lt;/h2&gt;

&lt;p&gt;简而言之，&lt;a href=&#34;http://dev.MySQL.com/doc/refman/4.1/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit&#34;&gt;&lt;code&gt;innodb_flush_log_at_trx_commit&lt;/code&gt;&lt;/a&gt; 参数指定了 InnoDB 在事务提交后的日志写入频率。这么说其实并不严谨，且看其不同取值的意义和表现。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当 &lt;code&gt;innodb_flush_log_at_trx_commit&lt;/code&gt; 取值为 &lt;code&gt;0&lt;/code&gt; 的时候，log buffer 会 每秒写入到日志文件并刷写（flush）到磁盘。但每次事务提交不会有任何影响，也就是 log buffer 的刷写操作和事务提交操作没有关系。在这种情况下，MySQL性能最好，但如果 mysqld 进程崩溃，通常会导致最后 1s 的日志丢失。&lt;/li&gt;
&lt;li&gt;当取值为 &lt;code&gt;1&lt;/code&gt; 时，每次事务提交时，log buffer 会被写入到日志文件并刷写到磁盘。这也是默认值。这是最安全的配置，但由于每次事务都需要进行磁盘I/O，所以也最慢。&lt;/li&gt;
&lt;li&gt;当取值为 &lt;code&gt;2&lt;/code&gt; 时，每次事务提交会写入日志文件，但并不会立即刷写到磁盘，日志文件会每秒刷写一次到磁盘。这时如果 mysqld 进程崩溃，由于日志已经写入到系统缓存，所以并不会丢失数据；在操作系统崩溃的情况下，通常会导致最后 1s 的日志丢失。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面说到的「最后 1s」并不是绝对的，有的时候会丢失更多数据。有时候由于调度的问题，每秒刷写（once-per-second flushing）并不能保证 100% 执行。对于一些数据一致性和完整性要求不高的应用，配置为 &lt;code&gt;2&lt;/code&gt; 就足够了；如果为了最高性能，可以设置为 &lt;code&gt;0&lt;/code&gt;。有些应用，如支付服务，对一致性和完整性要求很高，所以即使最慢，也最好设置为 &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;2-sync-binlog:59ae80d39a9fc958db330bc7cfc3b146&#34;&gt;2. sync_binlog&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://dev.MySQL.com/doc/refman/5.5/en/replication-options-binary-log.html#sysvar_sync_binlog&#34;&gt;sync_binlog&lt;/a&gt; 是 MySQL 的二进制日志（binary log）同步到磁盘的频率。MySQL server 在 binary log 每写入 &lt;code&gt;sync_binlog&lt;/code&gt; 次后，刷写到磁盘。&lt;/p&gt;

&lt;p&gt;如果 &lt;code&gt;autocommit&lt;/code&gt; 开启，每个语句都写一次 binary log，否则每次事务写一次。默认值是 &lt;code&gt;0&lt;/code&gt;，不主动同步，而依赖操作系统本身不定期把文件内容 flush 到磁盘。设为 &lt;code&gt;1&lt;/code&gt; 最安全，在每个语句或事务后同步一次 binary log，即使在崩溃时也最多丢失一个语句或事务的日志，但因此也最慢。&lt;/p&gt;

&lt;p&gt;大多数情况下，对数据的一致性并没有很严格的要求，所以并不会把 &lt;code&gt;sync_binlog&lt;/code&gt; 配置成 &lt;code&gt;1&lt;/code&gt;. 为了追求高并发，提升性能，可以设置为 &lt;code&gt;100&lt;/code&gt; 或直接用 &lt;code&gt;0&lt;/code&gt;. 而和 &lt;code&gt;innodb_flush_log_at_trx_commit&lt;/code&gt; 一样，对于支付服务这样的应用，还是比较推荐 &lt;code&gt;sync_binlog = 1&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Flask 路由做范围限制</title>
      <link>http://deanthompson.github.io/posts/2014/02/range-validation-in-flask-routing</link>
      <pubDate>Wed, 26 Feb 2014 23:15:42 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2014/02/range-validation-in-flask-routing</guid>
      <description>

&lt;p&gt;这其实是我之前在 StackOverflow 上回答过的一道题，令我感到意外的是，这个问题只有我一个人回答，而且我也获得了 8 个赞同。小小的成就感。&lt;/p&gt;

&lt;h1 id=&#34;1-what:6e1d883f88cf13596243023295e5bb32&#34;&gt;1. What&lt;/h1&gt;

&lt;p&gt;原题在这里：&lt;a href=&#34;http://stackoverflow.com/questions/19076226/how-to-validate-integer-range-in-flask-routing-werkzeug/&#34;&gt;How to validate integer range in Flask routing (Werkzeug)?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;简单翻译一下，大致如下：&lt;/p&gt;

&lt;p&gt;Flask 应用里面有一个这样的路由&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from foo import get_foo

@app.route(&amp;quot;/foo/&amp;lt;int:id&amp;gt;&amp;quot;)
def foo_id(id):
    return render_template(&#39;foo.html&#39;, foo = get_foo(id))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;id&lt;/code&gt; 的取值是 &lt;code&gt;1～300&lt;/code&gt;，如何在路由层级做这个验证？也就是一个类似于这样的东西 &lt;code&gt;@app.route(&amp;quot;/foo/&amp;lt;int:id(1-300)&amp;quot;)&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;2-how:6e1d883f88cf13596243023295e5bb32&#34;&gt;2. How&lt;/h1&gt;

&lt;p&gt;这个问题其实对我很有启发，虽然平时都在用 Flask 做项目，但是没有考虑过在 router 层面做验证。虽然在应用场景中可能用处不大，但至少可能存在这个选项，在一些特殊的场景下可以很方便的处理非法请求。&lt;/p&gt;

&lt;p&gt;虽然没用过参数验证，但是对 Flask 的路由规则还是比较熟悉的，也用过转换器（converter）。整体而言，Flask 基于一个 &lt;a href=&#34;http://werkzeug.pocoo.org/&#34;&gt;WSGI Utility Library: Werkzeug&lt;/a&gt; 和 &lt;a href=&#34;http://jinja.pocoo.org&#34;&gt;模板引擎 Jinja2&lt;/a&gt;，其中路由规则就是基于 Werkzeug 的。Werkzeug 提供了几种 builtin converters 用于将 URL 里的参数转换成对应 python 的数据类型，而事实上这就已经进行了一次类型检查。&lt;/p&gt;

&lt;h2 id=&#34;2-1-builtin-converters:6e1d883f88cf13596243023295e5bb32&#34;&gt;2.1 Builtin Converters&lt;/h2&gt;

&lt;p&gt;如前所述，Werkzeug 提供了几种 &lt;a href=&#34;http://werkzeug.pocoo.org/docs/routing/#builtin-converters&#34;&gt;builtin converters&lt;/a&gt;，分别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;class werkzeug.routing.UnicodeConverter(map, minlength=1, maxlength=None, length=None)&lt;/code&gt;：字符串转换器，接受除了路径类型（含有 &lt;code&gt;/&lt;/code&gt;）的所有字符串，这也是默认的转换器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class werkzeug.routing.PathConverter(map)&lt;/code&gt;：路径类型转换器，一般用得不多吧。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class werkzeug.routing.IntegerConverter(map, fixed_digits=0, min=None, max=None)&lt;/code&gt;：整型转换器，接受并转换成 &lt;code&gt;int&lt;/code&gt; 类型，不支持负数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class werkzeug.routing.FloatConverter(map, min=None, max=None)&lt;/code&gt;：浮点型转换器，接受并转换成 &lt;code&gt;float&lt;/code&gt; 类型，不支持负数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class werkzeug.routing.AnyConverter(map, *items)&lt;/code&gt;：匹配任意一个给定的选项，这些选项可以是 python 标识符或字符串。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从文档里可以看到，有些转换器是支持一些简单的范围验证。如 UnicodeConverter 可以检查字符串的最小长度（&lt;code&gt;minlength&lt;/code&gt;）、最大长度（&lt;code&gt;maxlength&lt;/code&gt;）或者指定长度（&lt;code&gt;length&lt;/code&gt;）。IntergerConverter 和 FloatConverter 都可以指定最小值（&lt;code&gt;min&lt;/code&gt;）和最大值（&lt;code&gt;max&lt;/code&gt;）。所以看完这些，就可以解决最开始的问题了。&lt;/p&gt;

&lt;h2 id=&#34;2-2-solution:6e1d883f88cf13596243023295e5bb32&#34;&gt;2.2 Solution&lt;/h2&gt;

&lt;p&gt;回到原题，是需要对 &lt;code&gt;id&lt;/code&gt; 做范围限制（&lt;code&gt;1～300&lt;/code&gt;），因此路由就可以这样写了（&lt;a href=&#34;http://stackoverflow.com/a/19076418/1461780&#34;&gt;我的回答&lt;/a&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from foo import get_foo

@app.route(&amp;quot;/foo/&amp;lt;int(min=1, max=300):id&amp;gt;&amp;quot;)
def foo_id(id):
    return render_template(&#39;foo.html&#39;, foo = get_foo(id))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个路由就限定了 &lt;code&gt;id&lt;/code&gt; 的范围，对于超出范围的请求，如 &lt;code&gt;/foo/1024/&lt;/code&gt;，就会找不到对应的路由，因此会返回 &lt;code&gt;404&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&#34;3-end:6e1d883f88cf13596243023295e5bb32&#34;&gt;3. End&lt;/h1&gt;

&lt;p&gt;题外话，其实题主开始的时候是在函数内部做了参数检测（我也基本这么干），而且最后也没有采用在路由做限制的方法。原因上面已经说了，就是对于超出范围的请求，会直接返回 &lt;code&gt;404&lt;/code&gt;，某些情况下这是可以接受的，但另外的情况下最好能让用户知道他的请求到底哪里出了问题。用哪种方案取决于具体的应用场景，但对我来说至少多了一个选项，也对 converters 相关的内容更了解了一些。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>less 命令支持语法高亮和行号</title>
      <link>http://deanthompson.github.io/posts/2013/11/less-with-syntax-highlight-and-line-number</link>
      <pubDate>Sun, 03 Nov 2013 00:30:00 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2013/11/less-with-syntax-highlight-and-line-number</guid>
      <description>

&lt;p&gt;首先来一句装X的话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;less is more&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;1-how:bea817191773b780e7e12130f8d11db2&#34;&gt;1. How&lt;/h1&gt;

&lt;p&gt;less 是一个很方便的命令行工具，但不足的是不能语法高亮，查看的都是黑白的纯文本。幸运的是，&lt;a href=&#34;http://www.gnu.org/software/src-highlite/&#34;&gt;source-highlight&lt;/a&gt; 可以弥补这一点。在 Ubuntu 安装 source-highlight 非常方便：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install source-highlight
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成后需要做一些简单的配置。编辑 .bashrc，加上以下配置项：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# less hightlight
export LESSOPEN=&amp;quot;| /usr/share/source-highlight/src-hilite-lesspipe.sh %s&amp;quot;
export LESS=&amp;quot; -R &amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要注意的是 &lt;code&gt;/usr/share/source-highlight/src-hilite-lesspipe.sh&lt;/code&gt; 是 &lt;code&gt;src-hilite-lesspipe.sh&lt;/code&gt; 脚本的路径，不同的系统可能不一样，可以查找一下（&lt;code&gt;find / -name src-hilite-lesspipe.sh&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;使配置生效：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;source ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以在之后使用 &lt;code&gt;less filename&lt;/code&gt; 查看文件内容时，支持语法高亮。&lt;/p&gt;

&lt;h1 id=&#34;2-why:bea817191773b780e7e12130f8d11db2&#34;&gt;2. Why&lt;/h1&gt;

&lt;p&gt;接下来看看到底发生了什么事情，可以做到这么「神奇」的效果。&lt;/p&gt;

&lt;h2 id=&#34;2-1-lessopen:bea817191773b780e7e12130f8d11db2&#34;&gt;2.1. LESSOPEN&lt;/h2&gt;

&lt;p&gt;首先来看&lt;code&gt;source-highlight&lt;/code&gt;，这个工具可以根据给定的源文件，读取动态读取语言特性，然后输出一个语法高亮的文件，支持多种输出格式，如 HTML、XHTML、LATEX、 「ANSI &lt;em&gt;color escape sequences&lt;/em&gt; 」等；默认是 HTML格式。最后一种输出格式是 ANSI 颜色转义序列，支持彩色。这种输出格式恰好可以和 less 结合使用，使其输出结果支持语法高亮。&lt;/p&gt;

&lt;p&gt;再看 &lt;code&gt;LESSOPEN&lt;/code&gt;。查看 less 的 man 帮助手册，可以看到 less 支持一个叫 「input preprocessor」的东西，可以在 less 打开源文件之前对源文件进行一次预处理。这个「input preprocessor」 可以自己定义：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;To  set up an input preprocessor, set the LESSOPEN environment variable to a command line which will invoke your input preprocessor.  This command line should include one occurrence of the string &amp;ldquo;%s&amp;rdquo;, which will be replaced by the  filename  when  the input preprocessor command is invoked.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面这句话说明了如何使用自己定义的预处理器，就是设置一下 &lt;code&gt;LESSOPEN&lt;/code&gt; 这个环境变量。那么 &lt;code&gt;LESSOPEN&lt;/code&gt; 到底是什么呢？ 可以在帮助手册找到定义：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Command line to invoke the (optional) input-preprocessor.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;LESSOPEN&lt;/code&gt; 指定一个「input preprocessor」，后面用 &lt;code&gt;%s&lt;/code&gt; 读取文件路径。可以看到上面的配置中，有一个前导的竖线 &lt;code&gt;|&lt;/code&gt;。熟悉 &lt;code&gt;*nix&lt;/code&gt; 命令行的人知道这是管道，这个竖线表示把「input preprocessor」的处理结果写到标准输出（standard output），然后 less 通过 input pipe 读取再显示到屏幕上。&lt;/p&gt;

&lt;h2 id=&#34;2-2-less:bea817191773b780e7e12130f8d11db2&#34;&gt;2.2. LESS&lt;/h2&gt;

&lt;p&gt;另一个变量是 &lt;code&gt;LESS&lt;/code&gt;，同样查看帮助手册：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Options which are passed to less automatically.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也就是自动传给 less 的选项，相当于缺省参数。上面设置的缺省选项是 &lt;code&gt;-R&lt;/code&gt;，看看 &lt;code&gt;-R&lt;/code&gt; 选项的意义：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;-R or &amp;ndash;RAW-CONTROL-CHARS&lt;/p&gt;

&lt;p&gt;Like -r, but only ANSI &amp;ldquo;color&amp;rdquo; escape sequences are output in &amp;ldquo;raw&amp;rdquo; form. &amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个选项的意义是，对于「ANSI &lt;em&gt;color escape sequences&lt;/em&gt; 」是直接输出的，而不错其他处理。上面用 &lt;code&gt;source-highlight&lt;/code&gt; 提供的 src-hilite-lesspipe.sh 脚本用作 「input preprocessor」把源文件进行了高亮处理，并且输出「ANSI &lt;em&gt;color escape sequences&lt;/em&gt; 」格式，这里设置 &lt;code&gt;-R&lt;/code&gt; 选项刚好可以把这个高亮过后的字符序列直接输出，因此就可以看到 less 下的语法高亮。&lt;/p&gt;

&lt;h1 id=&#34;3-more:bea817191773b780e7e12130f8d11db2&#34;&gt;3. More&amp;hellip;&lt;/h1&gt;

&lt;p&gt;在第二节里说到 &lt;code&gt;LESS&lt;/code&gt; 这个环境变量，同理，可以设置其他默认选项，比如 &lt;code&gt;-N&lt;/code&gt;。&lt;code&gt;-N&lt;/code&gt; 选项的意义相对更为显然：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;-N or &amp;ndash;LINE-NUMBERS&lt;/p&gt;

&lt;p&gt;Causes a line number to be displayed at the beginning of each line in the display.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;就是在每一行开头显示行号。这个非常有用啊～于是只要修改一下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export LESS=&amp;quot; -R -N &amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一来，就可以在 less 时既能语法高亮，还能查看行号，感觉很不错的说。试着贴一张效果图看看。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ww3.sinaimg.cn/large/65df5320tw1ea3o9tmdirj20ch0alq3h.jpg&#34; alt=&#34;less-with-syntax-highlight-and-line-number&#34; /&gt;
&lt;/p&gt;

&lt;h1 id=&#34;4-references:bea817191773b780e7e12130f8d11db2&#34;&gt;4. References&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;GNU Source-highlight: &lt;a href=&#34;http://www.gnu.org/software/src-highlite/&#34;&gt;http://www.gnu.org/software/src-highlite/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Powering Less to Highlight Syntax and Display Line Numbers:  &lt;a href=&#34;http://greyblake.com/blog/2011/09/23/powering-less-to-highlight-syntax-and-display-line-numbers/&#34;&gt;http://greyblake.com/blog/2011/09/23/powering-less-to-highlight-syntax-and-display-line-numbers/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>【翻译】理解 Python 装饰器</title>
      <link>http://deanthompson.github.io/posts/2013/03/understand-python-decorators</link>
      <pubDate>Wed, 13 Mar 2013 00:26:58 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2013/03/understand-python-decorators</guid>
      <description>

&lt;h2 id=&#34;note:5cd98240460e7b5c77708168d0565250&#34;&gt;Note&lt;/h2&gt;

&lt;p&gt;前段时间在 stack overflow 上看到一个关于 python decorator（装饰器）的问题，有一个人很耐心的写了一篇很长的教程。我也很耐心的看完了，获益匪浅。现在尝试翻译过来，尽量追求准确和尊重原文。不明白的地方，或翻译不好的地方，请参照原文，地址：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/739654/understanding-python-decorators#answer-1594484&#34;&gt;Understanding Python decorators&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;1-python的函数是对象-python-s-functions-are-objects:5cd98240460e7b5c77708168d0565250&#34;&gt;1. python的函数是对象（Python&amp;rsquo;s functions are objects）&lt;/h1&gt;

&lt;p&gt;要理解装饰器，就必须先知道，在python里，函数也是对象（functions are objects）。明白这一点非常重要，让我们通过一个例子来看看为什么。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def shout(word=&amp;quot;yes&amp;quot;):
    return word.capitalize()+&amp;quot;!&amp;quot;
 
print shout()
# outputs : &#39;Yes!&#39;
 
# 作为一个对象，你可以像其他对象一样把函数赋值给其他变量
 
scream = shout
 
# 注意我们没有用括号：我们不是在调用函数，
# 而是把函数&#39;shout&#39;的值绑定到&#39;scream&#39;这个变量上
# 这也意味着你可以通过&#39;scream&#39;这个变量来调用&#39;shout&#39;函数
 
print scream()
# outputs : &#39;Yes!&#39;
 
# 不仅如此，这也还意味着你可以把原来的名字&#39;shout&#39;删掉，
# 而这个函数仍然可以通过&#39;scream&#39;来访问
del shout
try:
    print shout()
except NameError, e:
    print e
    #outputs: &amp;quot;name &#39;shout&#39; is not defined&amp;quot;
 
print scream()
outputs: &#39;Yes!&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK，先记住这点，我们马上会用到。python 函数的另一个有趣的特性是，它们可以在另一个函数体内定义。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def talk():
 
    # 你可以在 &#39;talk&#39; 里动态的(on the fly)定义一个函数...
    def whisper(word=&amp;quot;yes&amp;quot;):
        return word.lower()+&amp;quot;...&amp;quot;
 
    # ... 然后马上调用它！
 
    print whisper()
 
# 每当调用&#39;talk&#39;，都会定义一次&#39;whisper&#39;，然后&#39;whisper&#39;在&#39;talk&#39;里被调用
talk()
# outputs:
# &amp;quot;yes...&amp;quot;
 
# 但是&amp;quot;whisper&amp;quot; 在 &amp;quot;talk&amp;quot;外并不存在:
 
try:
    print whisper()
except NameError, e:
    print e
    #outputs : &amp;quot;name &#39;whisper&#39; is not defined&amp;quot;*
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-函数引用-functions-references:5cd98240460e7b5c77708168d0565250&#34;&gt;2. 函数引用（Functions references）&lt;/h1&gt;

&lt;p&gt;OK，还在吧？！现在到了有趣的部分，你刚刚已经知道了，python的函数也是对象，因此：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以被赋值给变量&lt;/li&gt;
&lt;li&gt;可以在另一个函数体内定义&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么，这样就意味着一个函数可以返回另一个函数 :-)，来看个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def getTalk(type=&amp;quot;shout&amp;quot;):
 
    # 我们先动态定义一些函数
    def shout(word=&amp;quot;yes&amp;quot;):
        return word.capitalize()+&amp;quot;!&amp;quot;
 
    def whisper(word=&amp;quot;yes&amp;quot;) :
        return word.lower()+&amp;quot;...&amp;quot;;
 
    # 然后返回其中一个
    if type == &amp;quot;shout&amp;quot;:
        # 注意：我们是在返回函数对象，而不是调用函数，
        # 所以不要用到括号 &amp;quot;()&amp;quot;
        return shout 
    else:
        return whisper
 
# 那你改如何使用这个怪兽呢？(How do you use this strange beast?)
 
# 先把函数赋值给一个变量
talk = getTalk()     
 
# 你可以发现 &amp;quot;talk&amp;quot; 其实是一个函数对象:
print talk
#outputs : &amp;lt;function shout at 0xb7ea817c&amp;gt;
 
# 这个对象就是 getTalk 函数返回的:
print talk()
#outputs : Yes!
 
# 你甚至还可以直接这样使用(if you feel wild):
print getTalk(&amp;quot;whisper&amp;quot;)()
#outputs : yes...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是等等，还有呢。既然可以返回一个函数，那么也就可以像参数一样传递：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def doSomethingBefore(func):
    print &amp;quot;I do something before then I call the function you gave me&amp;quot;
    print func()
 
doSomethingBefore(scream)
#outputs:
#I do something before then I call the function you gave me
#Yes!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那好，你现在已经具备了理解装饰器的所有基础知识了。你看，装饰器也就是一种包装材料，&lt;strong&gt;它们可以让你在执行被装饰的函数之前或之后执行其他代码，而且不需要修改函数本身&lt;/strong&gt;。（原句比较长：You see, decorators are wrappers which means that they let you execute code before and after the function they decorate without the need to modify the function itself.）&lt;/p&gt;

&lt;h1 id=&#34;3-手工制作装饰器-handcrafted-decorators:5cd98240460e7b5c77708168d0565250&#34;&gt;3. 手工制作装饰器（Handcrafted decorators）&lt;/h1&gt;

&lt;p&gt;你可以像这样来定制：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 一个装饰器是一个需要另一个函数作为参数的函数
def my_shiny_new_decorator(a_function_to_decorate):
 
    # 在装饰器内部动态定义一个函数：wrapper(原意：包装纸).
    # 这个函数将被包装在原始函数的四周
    # 因此就可以在原始函数之前和之后执行一些代码.
    def the_wrapper_around_the_original_function():
 
        # 把想要在调用原始函数前运行的代码放这里
        print &amp;quot;Before the function runs&amp;quot;
 
        # 调用原始函数（需要带括号）
        a_function_to_decorate()
 
        # 把想要在调用原始函数后运行的代码放这里
        print &amp;quot;After the function runs&amp;quot;
 
    # 直到现在，&amp;quot;a_function_to_decorate&amp;quot;还没有执行过 (HAS NEVER BEEN EXECUTED).
    # 我们把刚刚创建的 wrapper 函数返回.
    # wrapper 函数包含了这个函数，还有一些需要提前后之后执行的代码，
    # 可以直接使用了（It&#39;s ready to use!）
    return the_wrapper_around_the_original_function
 
# Now imagine you create a function you don&#39;t want to ever touch again.
def a_stand_alone_function():
    print &amp;quot;I am a stand alone function, don&#39;t you dare modify me&amp;quot;
 
a_stand_alone_function()
#outputs: I am a stand alone function, don&#39;t you dare modify me
 
# 现在，你可以装饰一下来修改它的行为.
# 只要简单的把它传递给装饰器，后者能用任何你想要的代码动态的包装
# 而且返回一个可以直接使用的新函数:
 
a_stand_alone_function_decorated = my_shiny_new_decorator(a_stand_alone_function)
a_stand_alone_function_decorated()
#outputs:
#Before the function runs
#I am a stand alone function, don&#39;t you dare modify me
#After the function runs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你大概希望，每次调用 &lt;code&gt;a_stand_alone_function&lt;/code&gt; 时，实际调用的是 &lt;code&gt;a_stand_alone_function_decorated&lt;/code&gt; 。这很容易，只要把 &lt;code&gt;my_shiny_new_decorator&lt;/code&gt; 返回的函数覆盖 &lt;code&gt;a_stand_alone_function&lt;/code&gt; 就可以了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a_stand_alone_function = my_shiny_new_decorator(a_stand_alone_function)
a_stand_alone_function()
#outputs:
#Before the function runs
#I am a stand alone function, don&#39;t you dare modify me
#After the function runs
 
# And guess what? That&#39;s EXACTLY what decorators do!
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;4-揭秘装饰器-decorators-demystified:5cd98240460e7b5c77708168d0565250&#34;&gt;4. 揭秘装饰器(Decorators demystified)&lt;/h1&gt;

&lt;p&gt;我们用装饰器的语法来重写一下前面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@my_shiny_new_decorator
def another_stand_alone_function():
    print &amp;quot;Leave me alone&amp;quot;
 
another_stand_alone_function() 
#outputs: 
#Before the function runs
#Leave me alone
#After the function runs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是的，这就完了，就这么简单。&lt;code&gt;@decorator&lt;/code&gt; 只是下面这条语句的简写(shortcut)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;装饰器其实就是装饰器模式的一个python化的变体（pythonic variant）。为了方便开发，python已经内置了好几种经典的设计模式，比如迭代器（iterators）。
当然，你还可以堆积使用装饰器(you can cumulate decorators)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def bread(func):
    def wrapper():
        print &amp;quot;&amp;lt;/&#39;&#39;&#39;&#39;&#39;&#39;\&amp;gt;&amp;quot;
        func()
        print &amp;quot;&amp;lt;\______/&amp;gt;&amp;quot;
    return wrapper
 
def ingredients(func):
    def wrapper():
        print &amp;quot;#tomatoes#&amp;quot;
        func()
        print &amp;quot;~salad~&amp;quot;
    return wrapper
 
def sandwich(food=&amp;quot;--ham--&amp;quot;):
    print food
 
sandwich()
#outputs: --ham--
sandwich = bread(ingredients(sandwich))
sandwich()
#outputs:
#&amp;lt;/&#39;&#39;&#39;&#39;&#39;&#39;\&amp;gt;
# #tomatoes#
# --ham--
# ~salad~
#&amp;lt;\______/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用python的装饰器语法表示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@bread
@ingredients
def sandwich(food=&amp;quot;--ham--&amp;quot;):
    print food
 
sandwich()
#outputs:
#&amp;lt;/&#39;&#39;&#39;&#39;&#39;&#39;\&amp;gt;
# #tomatoes#
# --ham--
# ~salad~
#&amp;lt;\______/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;装饰器放置的顺序 &lt;strong&gt;很重要&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@ingredients
@bread
def strange_sandwich(food=&amp;quot;--ham--&amp;quot;):
    print food
 
strange_sandwich()
#outputs:
##tomatoes#
#&amp;lt;/&#39;&#39;&#39;&#39;&#39;&#39;\&amp;gt;
# --ham--
#&amp;lt;\______/&amp;gt;
# ~salad~
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;5-回答题主问题-略:5cd98240460e7b5c77708168d0565250&#34;&gt;5. 回答题主问题，略&lt;/h1&gt;

&lt;h1 id=&#34;6-给装饰器函数传参-passing-arguments-to-the-decorated-function:5cd98240460e7b5c77708168d0565250&#34;&gt;6. 给装饰器函数传参（Passing arguments to the decorated function）&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 这不是什么黑色魔法(black magic)，你只是必须让wrapper传递参数:
 
def a_decorator_passing_arguments(function_to_decorate):
    def a_wrapper_accepting_arguments(arg1, arg2):
        print &amp;quot;I got args! Look:&amp;quot;, arg1, arg2
        function_to_decorate(arg1, arg2)
    return a_wrapper_accepting_arguments
 
# 当你调用装饰器返回的函数式，你就在调用wrapper，而给wrapper的
# 参数传递将会让它把参数传递给要装饰的函数
 
@a_decorator_passing_arguments
def print_full_name(first_name, last_name):
    print &amp;quot;My name is&amp;quot;, first_name, last_name
 
print_full_name(&amp;quot;Peter&amp;quot;, &amp;quot;Venkman&amp;quot;)
# outputs:
#I got args! Look: Peter Venkman
#My name is Peter 
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;7-装饰方法-decorating-methods:5cd98240460e7b5c77708168d0565250&#34;&gt;7. 装饰方法（Decorating methods）&lt;/h1&gt;

&lt;p&gt;Python的一个伟大之处在于：方法和函数几乎是一样的(methods and functions are really the same)，除了方法的第一个参数应该是当前对象的引用(也就是 self)。这也就意味着只要记住把 self 考虑在内，你就可以用同样的方法给方法创建装饰器了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def method_friendly_decorator(method_to_decorate):
    def wrapper(self, lie):
        lie = lie - 3 # very friendly, decrease age even more :-)
        return method_to_decorate(self, lie)
    return wrapper
 
 
class Lucy(object):
 
    def __init__(self):
        self.age = 32
 
    @method_friendly_decorator
    def sayYourAge(self, lie):
        print &amp;quot;I am %s, what did you think?&amp;quot; % (self.age + lie)
 
l = Lucy()
l.sayYourAge(-3)
#outputs: I am 26, what did you think?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，如果你想编写一个非常通用的装饰器，可以用来装饰任意函数和方法，你就可以无视具体参数了，直接使用 &lt;code&gt;*args&lt;/code&gt;, &lt;code&gt;**kwargs&lt;/code&gt; 就行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def a_decorator_passing_arbitrary_arguments(function_to_decorate):
    # The wrapper accepts any arguments
    def a_wrapper_accepting_arbitrary_arguments(*args, **kwargs):
        print &amp;quot;Do I have args?:&amp;quot;
        print args
        print kwargs
        # Then you unpack the arguments, here *args, **kwargs
        # If you are not familiar with unpacking, check:
        # http://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/
        function_to_decorate(*args, **kwargs)
    return a_wrapper_accepting_arbitrary_arguments
 
@a_decorator_passing_arbitrary_arguments
def function_with_no_argument():
    print &amp;quot;Python is cool, no argument here.&amp;quot;
 
function_with_no_argument()
#outputs
#Do I have args?:
#()
#{}
#Python is cool, no argument here.
 
@a_decorator_passing_arbitrary_arguments
def function_with_arguments(a, b, c):
    print a, b, c
 
function_with_arguments(1,2,3)
#outputs
#Do I have args?:
#(1, 2, 3)
#{}
#1 2 3
 
@a_decorator_passing_arbitrary_arguments
def function_with_named_arguments(a, b, c, platypus=&amp;quot;Why not ?&amp;quot;):
    print &amp;quot;Do %s, %s and %s like platypus? %s&amp;quot; %\
    (a, b, c, platypus)
 
function_with_named_arguments(&amp;quot;Bill&amp;quot;, &amp;quot;Linus&amp;quot;, &amp;quot;Steve&amp;quot;, platypus=&amp;quot;Indeed!&amp;quot;)
#outputs
#Do I have args ? :
#(&#39;Bill&#39;, &#39;Linus&#39;, &#39;Steve&#39;)
#{&#39;platypus&#39;: &#39;Indeed!&#39;}
#Do Bill, Linus and Steve like platypus? Indeed!
 
class Mary(object):
 
    def __init__(self):
        self.age = 31
 
    @a_decorator_passing_arbitrary_arguments
    def sayYourAge(self, lie=-3): # You can now add a default value
        print &amp;quot;I am %s, what did you think ?&amp;quot; % (self.age + lie)
 
m = Mary()
m.sayYourAge()
#outputs
# Do I have args?:
#(&amp;lt;__main__.Mary object at 0xb7d303ac&amp;gt;,)
#{}
#I am 28, what did you think?
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;8-给装饰器传参-passing-arguments-to-the-decorator:5cd98240460e7b5c77708168d0565250&#34;&gt;8. 给装饰器传参（Passing arguments to the decorator）&lt;/h1&gt;

&lt;p&gt;太棒了，那么现在对于给装饰器本身传参数，你有什么看法呢？好吧，这样说有点绕，因为装饰器必须接受一个函数作为参数，所以就不能把被装饰的函数的参数，直接传给装饰器（you cannot pass the decorated function arguments directly to the decorator.）&lt;/p&gt;

&lt;p&gt;在直奔答案之前，我们先写一个小提示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Decorators are ORDINARY functions
def my_decorator(func):
    print &amp;quot;I am a ordinary function&amp;quot;
    def wrapper():
        print &amp;quot;I am function returned by the decorator&amp;quot;
        func()
    return wrapper
 
# Therefore, you can call it without any &amp;quot;@&amp;quot;
 
def lazy_function():
    print &amp;quot;zzzzzzzz&amp;quot;
 
decorated_function = my_decorator(lazy_function)
#outputs: I am a ordinary function
 
# It outputs &amp;quot;I am a ordinary function&amp;quot;, because that&#39;s just what you do:
# calling a function. Nothing magic.
 
@my_decorator
def lazy_function():
    print &amp;quot;zzzzzzzz&amp;quot;
 
#outputs: I am a ordinary function
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这完全一样，都是 &lt;code&gt;my_decorator&lt;/code&gt; 被调用。所以当你使用 &lt;code&gt;@my_decorator&lt;/code&gt; 时，你在告诉 python 去调用 “被变量 &lt;code&gt;my_decorator&lt;/code&gt; 标记的” 函数（the function &amp;lsquo;labeled by the variable &amp;ldquo;my_decorator&amp;rdquo;&amp;lsquo;）。这很重要，因为你给的这个标签能直接指向装饰器。。。或者其他！让我们开始变得邪恶！（Let&amp;rsquo;s start to be evil!）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def decorator_maker():
 
    print &amp;quot;I make decorators! I am executed only once: &amp;quot;+\
          &amp;quot;when you make me create a decorator.&amp;quot;
 
    def my_decorator(func):
 
        print &amp;quot;I am a decorator! I am executed only when you decorate a function.&amp;quot;
 
        def wrapped():
            print (&amp;quot;I am the wrapper around the decorated function. &amp;quot;
                  &amp;quot;I am called when you call the decorated function. &amp;quot;
                  &amp;quot;As the wrapper, I return the RESULT of the decorated function.&amp;quot;)
            return func()
 
        print &amp;quot;As the decorator, I return the wrapped function.&amp;quot;
 
        return wrapped
 
    print &amp;quot;As a decorator maker, I return a decorator&amp;quot;
    return my_decorator
 
# Let&#39;s create a decorator. It&#39;s just a new function after all.
new_decorator = decorator_maker()      
#outputs:
#I make decorators! I am executed only once: when you make me create a decorator.
#As a decorator maker, I return a decorator
 
# Then we decorate the function
 
def decorated_function():
    print &amp;quot;I am the decorated function.&amp;quot;
 
decorated_function = new_decorator(decorated_function)
#outputs:
#I am a decorator! I am executed only when you decorate a function.
#As the decorator, I return the wrapped function
 
# Let&#39;s call the function:
decorated_function()
#outputs:
#I am the wrapper around the decorated function. I am called when you call the decorated function.
#As the wrapper, I return the RESULT of the decorated function.
#I am the decorated function.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不要感到惊讶，让我们做一件完全一样的事情，只不过跳过了中间变量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def decorated_function():
    print &amp;quot;I am the decorated function.&amp;quot;
decorated_function = decorator_maker()(decorated_function)
#outputs:
#I make decorators! I am executed only once: when you make me create a decorator.
#As a decorator maker, I return a decorator
#I am a decorator! I am executed only when you decorate a function.
#As the decorator, I return the wrapped function.
 
# Finally:
decorated_function()   
#outputs:
#I am the wrapper around the decorated function. I am called when you call the decorated function.
#As the wrapper, I return the RESULT of the decorated function.
#I am the decorated function.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再做一次，代码甚至更短：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@decorator_maker()
def decorated_function():
    print &amp;quot;I am the decorated function.&amp;quot;
#outputs:
#I make decorators! I am executed only once: when you make me create a decorator.
#As a decorator maker, I return a decorator
#I am a decorator! I am executed only when you decorate a function.
#As the decorator, I return the wrapped function.
 
#Eventually:
decorated_function()   
#outputs:
#I am the wrapper around the decorated function. I am called when you call the decorated function.
#As the wrapper, I return the RESULT of the decorated function.
#I am the decorated function.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;嘿，看到了吗？我们在用 &lt;code&gt;@&lt;/code&gt; 语法调用了函数 ：-）
那么回到带参数的装饰器。如果我们能够使用一个函数动态（on the fly）的生成装饰器，那么我们就能把参数传递给那个函数，对吗？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def decorator_maker_with_arguments(decorator_arg1, decorator_arg2):
 
    print &amp;quot;I make decorators! And I accept arguments:&amp;quot;, decorator_arg1, decorator_arg2
 
    def my_decorator(func):
        # 在这里能传参数是一个来自闭包的馈赠.
        # 如果你对闭包感到不舒服，你可以直接忽略（you can assume it&#39;s ok）,
        # 或者看看这里: http://stackoverflow.com/questions/13857/can-you-explain-closures-as-they-relate-to-python
        print &amp;quot;I am the decorator. Somehow you passed me arguments:&amp;quot;, decorator_arg1, decorator_arg2
 
        # 不要把装饰器参数和函数参数搞混了！
        def wrapped(function_arg1, function_arg2) :
            print (&amp;quot;I am the wrapper around the decorated function.\n&amp;quot;
                  &amp;quot;I can access all the variables\n&amp;quot;
                  &amp;quot;\t- from the decorator: {0} {1}\n&amp;quot;
                  &amp;quot;\t- from the function call: {2} {3}\n&amp;quot;
                  &amp;quot;Then I can pass them to the decorated function&amp;quot;
                  .format(decorator_arg1, decorator_arg2,
                          function_arg1, function_arg2))
            return func(function_arg1, function_arg2)
 
        return wrapped
 
    return my_decorator
 
@decorator_maker_with_arguments(&amp;quot;Leonard&amp;quot;, &amp;quot;Sheldon&amp;quot;)
def decorated_function_with_arguments(function_arg1, function_arg2):
    print (&amp;quot;I am the decorated function and only knows about my arguments: {0}&amp;quot;
           &amp;quot; {1}&amp;quot;.format(function_arg1, function_arg2))
 
decorated_function_with_arguments(&amp;quot;Rajesh&amp;quot;, &amp;quot;Howard&amp;quot;)
#outputs:
#I make decorators! And I accept arguments: Leonard Sheldon
#I am the decorator. Somehow you passed me arguments: Leonard Sheldon
#I am the wrapper around the decorated function.
#I can access all the variables
#   - from the decorator: Leonard Sheldon
#   - from the function call: Rajesh Howard
#Then I can pass them to the decorated function
#I am the decorated function and only knows about my arguments: Rajesh Howard
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是了，带参数的装饰器。参数也可以设置为变量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;c1 = &amp;quot;Penny&amp;quot;
c2 = &amp;quot;Leslie&amp;quot;
 
@decorator_maker_with_arguments(&amp;quot;Leonard&amp;quot;, c1)
def decorated_function_with_arguments(function_arg1, function_arg2):
    print (&amp;quot;I am the decorated function and only knows about my arguments:&amp;quot;
           &amp;quot; {0} {1}&amp;quot;.format(function_arg1, function_arg2))
 
decorated_function_with_arguments(c2, &amp;quot;Howard&amp;quot;)
#outputs:
#I make decorators! And I accept arguments: Leonard Penny
#I am the decorator. Somehow you passed me arguments: Leonard Penny
#I am the wrapper around the decorated function.
#I can access all the variables
#   - from the decorator: Leonard Penny
#   - from the function call: Leslie Howard
#Then I can pass them to the decorated function
#I am the decorated function and only knows about my arguments: Leslie Howard
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如你所见，你可以给装饰器传递参数，就好像其他任意一个使用了这种把戏的函数一样（you can pass arguments to the decorator like any function using this trick. ）。如果你愿意，甚至可以使用 &lt;code&gt;*args&lt;/code&gt;, &lt;code&gt;**kwargs&lt;/code&gt;。但是，记住，装置器只调用一次，仅当python导入这个脚本时。你不能在之后动态的设置参数（You can&amp;rsquo;t dynamically set the arguments afterwards.）。当你执行 &lt;code&gt;import x&lt;/code&gt; 时，这个函数已经被装饰了，因此你不能修改任何东西。&lt;/p&gt;

&lt;h1 id=&#34;9-实践-装饰器装饰一个装饰器-let-s-practice-a-decorator-to-decorate-a-decorator:5cd98240460e7b5c77708168d0565250&#34;&gt;9. 实践：装饰器装饰一个装饰器（Let&amp;rsquo;s practice: a decorator to decorate a decorator）&lt;/h1&gt;

&lt;p&gt;OK，作为一个福利，我将展示一段能用来创建能接受通用的任意参数的装饰器的代码（I&amp;rsquo;ll give you a snippet to make any decorator accept generically any argument. ）。毕竟，为了能接受参数，我们用了另一个函数来创建我们的装饰器。我们包装了装饰器。在我们刚刚看到的东西里，还有用来包装函数的吗？是的，就是装饰器。让我们给装饰器写一个装饰器来玩玩：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def decorator_with_args(decorator_to_enhance):
    &amp;quot;&amp;quot;&amp;quot;
    This function is supposed to be used as a decorator.
    It must decorate an other function, that is intended to be used as a decorator.
    Take a cup of coffee.
    It will allow any decorator to accept an arbitrary number of arguments,
    saving you the headache to remember how to do that every time.
    &amp;quot;&amp;quot;&amp;quot;
 
    # We use the same trick we did to pass arguments
    def decorator_maker(*args, **kwargs):
 
        # We create on the fly a decorator that accepts only a function
        # but keeps the passed arguments from the maker.
        def decorator_wrapper(func):
 
            # We return the result of the original decorator, which, after all,
            # IS JUST AN ORDINARY FUNCTION (which returns a function).
            # Only pitfall: the decorator must have this specific signature or it won&#39;t work:
            return decorator_to_enhance(func, *args, **kwargs)
 
        return decorator_wrapper
 
    return decorator_maker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它可以像这样使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# You create the function you will use as a decorator. And stick a decorator on it :-)
# Don&#39;t forget, the signature is &amp;quot;decorator(func, *args, **kwargs)&amp;quot;
@decorator_with_args
def decorated_decorator(func, *args, **kwargs):
    def wrapper(function_arg1, function_arg2):
        print &amp;quot;Decorated with&amp;quot;, args, kwargs
        return func(function_arg1, function_arg2)
    return wrapper
 
# Then you decorate the functions you wish with your brand new decorated decorator.
 
@decorated_decorator(42, 404, 1024)
def decorated_function(function_arg1, function_arg2):
    print &amp;quot;Hello&amp;quot;, function_arg1, function_arg2
 
decorated_function(&amp;quot;Universe and&amp;quot;, &amp;quot;everything&amp;quot;)
#outputs:
#Decorated with (42, 404, 1024) {}
#Hello Universe and everything
 
# Whoooot!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我知道，你上一次有这种感觉，是在听一个人说“在理解递归之前，你必须先理解递归”之后。但是现在，掌握之后，你不觉得很爽吗？&lt;/p&gt;

&lt;h1 id=&#34;10-装饰器最佳实践-best-practices-while-using-decorators:5cd98240460e7b5c77708168d0565250&#34;&gt;10. 装饰器最佳实践（Best practices while using decorators）&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;装饰器是在 python 2.4 之后才有的，所以先确定你的代码运行时；&lt;/li&gt;
&lt;li&gt;记住这点：装饰器降低了函数调用效率；&lt;/li&gt;
&lt;li&gt;你不能“解装饰”一个函数（You can not un-decorate a function. ）。有一些能用来创建可以移除的装饰器的方法（There are hacks to create decorators that can be removed），但没人用它们。所以一个函数一旦被装饰了，就结束了（不能改变了）。&lt;strong&gt;For all the code.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;装饰器包装了函数，这使得会难以调试。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Python 2.5 通过提供了一个 &lt;code&gt;functools&lt;/code&gt; 模块解决了最后一个问题。&lt;code&gt;functools.wraps&lt;/code&gt; 把任意被包装函数的函数名、模块名和 docstring 拷贝给了 &lt;code&gt;wrapper&lt;/code&gt;. 有趣的事是，&lt;code&gt;functools.wraps&lt;/code&gt; 也是一个装饰器：-）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# For debugging, the stacktrace prints you the function __name__
def foo():
    print &amp;quot;foo&amp;quot;
 
print foo.__name__
#outputs: foo
 
# With a decorator, it gets messy   
def bar(func):
    def wrapper():
        print &amp;quot;bar&amp;quot;
        return func()
    return wrapper
 
@bar
def foo():
    print &amp;quot;foo&amp;quot;
 
print foo.__name__
#outputs: wrapper
 
# &amp;quot;functools&amp;quot; can help for that
 
import functools
 
def bar(func):
    # We say that &amp;quot;wrapper&amp;quot;, is wrapping &amp;quot;func&amp;quot;
    # and the magic begins
    @functools.wraps(func)
    def wrapper():
        print &amp;quot;bar&amp;quot;
        return func()
    return wrapper
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;11-装饰器如何才能有用-how-can-the-decorators-be-useful:5cd98240460e7b5c77708168d0565250&#34;&gt;11. 装饰器如何才能有用（How can the decorators be useful?）&lt;/h1&gt;

&lt;p&gt;现在问题来了：我能用装饰器来干嘛？看起来很酷也很强大，但是来一个实际例子才更好。好吧，有1000中可能性（Well, there are 1000 possibilities.）。一个典型的用途是，用来扩展一个外部导入的函数（你不能修改）的行为，或者为了调试（你不想修改这个函数，因为只是暂时的）。你也可以用装饰器实现只用一段相同的代码来扩展成几个不同的函数，而且你不需要每次都重写这段代码。这样就是常说的 DRY。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def benchmark(func):
    &amp;quot;&amp;quot;&amp;quot;
    A decorator that prints the time a function takes
    to execute.
    &amp;quot;&amp;quot;&amp;quot;
    import time
    def wrapper(*args, **kwargs):
        t = time.clock()
        res = func(*args, **kwargs)
        print func.__name__, time.clock()-t
        return res
    return wrapper
 
 
def logging(func):
    &amp;quot;&amp;quot;&amp;quot;
    A decorator that logs the activity of the script.
    (it actually just prints it, but it could be logging!)
    &amp;quot;&amp;quot;&amp;quot;
    def wrapper(*args, **kwargs):
        res = func(*args, **kwargs)
        print func.__name__, args, kwargs
        return res
    return wrapper
 
 
def counter(func):
    &amp;quot;&amp;quot;&amp;quot;
    A decorator that counts and prints the number of times a function has been executed
    &amp;quot;&amp;quot;&amp;quot;
    def wrapper(*args, **kwargs):
        wrapper.count = wrapper.count + 1
        res = func(*args, **kwargs)
        print &amp;quot;{0} has been used: {1}x&amp;quot;.format(func.__name__, wrapper.count)
        return res
    wrapper.count = 0
    return wrapper
 
@counter
@benchmark
@logging
def reverse_string(string):
    return str(reversed(string))
 
print reverse_string(&amp;quot;Able was I ere I saw Elba&amp;quot;)
print reverse_string(&amp;quot;A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!&amp;quot;)
 
#outputs:
#reverse_string (&#39;Able was I ere I saw Elba&#39;,) {}
#wrapper 0.0
#wrapper has been used: 1x
#ablE was I ere I saw elbA
#reverse_string (&#39;A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!&#39;,) {}
#wrapper 0.0
#wrapper has been used: 2x
#!amanaP :lanac a ,noep a ,stah eros ,raj a ,hsac ,oloR a ,tur a ,mapS ,snip ,eperc a ,)lemac a ro( niaga gab ananab a ,gat a ,nat a ,gab ananab a ,gag a ,inoracam ,elacrep ,epins ,spam ,arutaroloc a ,shajar ,soreh ,atsap ,eonac a ,nalp a ,nam A

当然，装饰器的好处就是你可以几乎用来装饰所有东西，而且不要重写。也就是我说的 DRY：（Of course the good thing with decorators is that you can use them right away on almost anything without rewriting. DRY, I said:）

:::python
@counter
@benchmark
@logging
def get_random_futurama_quote():
    import httplib
    conn = httplib.HTTPConnection(&amp;quot;slashdot.org:80&amp;quot;)
    conn.request(&amp;quot;HEAD&amp;quot;, &amp;quot;/index.html&amp;quot;)
    for key, value in conn.getresponse().getheaders():
        if key.startswith(&amp;quot;x-b&amp;quot;) or key.startswith(&amp;quot;x-f&amp;quot;):
            return value
    return &amp;quot;No, I&#39;m ... doesn&#39;t!&amp;quot;
 
print get_random_furturama_quote()
print get_random_furturama_quote()
 
#outputs:
#get_random_futurama_quote () {}
#wrapper 0.02
#wrapper has been used: 1x
#The laws of science be a harsh mistress.
#get_random_futurama_quote () {}
#wrapper 0.01
#wrapper has been used: 2x
#Curse you, merciful Poseidon!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python 语言本身也提供了一些装饰器：&lt;code&gt;property&lt;/code&gt;、&lt;code&gt;staticmethod&lt;/code&gt; 等。Django 用装饰器来管理换成和视图权限。Twisted 用来伪装 内联异步函数调用（Twisted to fake inlining asynchronous functions calls. ）。这确实是一片广阔的天地。（This really is a large playground.）&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用 openpyxl 处理 xlsx 文件</title>
      <link>http://deanthompson.github.io/posts/2013/02/using-openpyxl-to-read-and-write-xlsx-files</link>
      <pubDate>Mon, 25 Feb 2013 16:39:55 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2013/02/using-openpyxl-to-read-and-write-xlsx-files</guid>
      <description>

&lt;p&gt;久违的图书馆~~虽然刚开学，图书馆里已经有不少同学在看书自习了，学校的氛围就是不一样，在安静的环境和熟悉的书香中，很容易就静下心来。OK，下面进入正题。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;openpyxl&lt;/code&gt; 是一个用来处理 excel 文件的 python 代码库。Python 有一些内置的功能相似的代码库，不过我都没用过，而且好像都有不少局限性。&lt;code&gt;openpyxl&lt;/code&gt; 用起来还是挺简单的，对照文档就可以解决一些基本需求，比如常见的都写操作。不过有一个前提，它只能用来处理 Excel 2007 及以上版本的 excel 文件，也就是 &lt;code&gt;.xlsx/.xlsm&lt;/code&gt; 格式的表格文件。顺便提一下，&lt;code&gt;xls&lt;/code&gt; 和 &lt;code&gt;xlsx&lt;/code&gt; 是两种完全不同的格式，其本质的差别相比字面的区别要多很多。xls 的核心结构是复合文档类型的结构，而 xlsx 的核心结构是 XML 类型的结构，采用的是基于XML的压缩方式，使其占用的空间更小。&lt;code&gt;xlsx&lt;/code&gt; 中最后一个 &lt;code&gt;x&lt;/code&gt; 的意义就在于此。&lt;/p&gt;

&lt;h1 id=&#34;1-安装:aebfe74b7cb46f66dc1d78cd9abadd46&#34;&gt;1. 安装&lt;/h1&gt;

&lt;p&gt;可以在这里下载openpyxl的代码包，然后从源代码安装即可。最新版本是 1.6.1.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://pypi.python.org/pypi/openpyxl&#34;&gt;https://pypi.python.org/pypi/openpyxl&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;2-读:aebfe74b7cb46f66dc1d78cd9abadd46&#34;&gt;2. 读&lt;/h1&gt;

&lt;p&gt;用openpyxl读一个xlsx文件很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from openpyxl import load_workbook
 
wb = load_workbook(filename=r&#39;existing_file.xlsx&#39;)
 
sheets = wb.get_sheet_names()   # 获取所有表格(worksheet)的名字
sheet0 = sheets[0]  # 第一个表格的名称
ws = wb.get_sheet_by_name(&#39;sheet_name&#39;) # 获取特定的 worksheet
 
# 获取表格所有行和列，两者都是可迭代的
rows = ws.rows
columns = ws.columns
 
# 行迭代
content = []
for row in rows:
    line = [col.value for col in row]
    content.append(line)
 
# 通过坐标读取值
print ws.cell(&#39;B12&#39;).value    # B 表示列，12 表示行
print ws.cell(row=12, column=2).value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当调用 &lt;code&gt;get_sheet_by_name(&#39;sheet_name&#39;)&lt;/code&gt; 方法获取表格时，如果名字为 &lt;code&gt;sheet_name&lt;/code&gt; 的表格不存在，不会报错或抛出异常，而只是返回 &lt;code&gt;None&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;3-写:aebfe74b7cb46f66dc1d78cd9abadd46&#34;&gt;3. 写&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from openpyxl import Workbook
 
# 在内存中创建一个workbook对象，而且会至少创建一个 worksheet
wb = Workbook()
 
ws = wb.get_active_sheet()
print ws.title
ws.title = &#39;New Title&#39;  # 设置worksheet的标题
 
# 设置单元格的值
ws.cell(&#39;D3&#39;).value = 4
ws.cell(row=3, column=1).value = 6
 
new_ws = wb.create_sheet(title=&#39;new_sheet&#39;)
for row in range(100):
    for col in range(10):
        new_ws.cell(row=row, column=col).value = row+col
 
# 最后一定要保存！
wb.save(filename=&#39;new_file.xlsx&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;4-文档:aebfe74b7cb46f66dc1d78cd9abadd46&#34;&gt;4. 文档&lt;/h1&gt;

&lt;p&gt;对于常规的小文件的操作，以上的一些介绍基本是够了。有时候需要处理大文件，就需要用到更高级一些的方法。更详细的用法、教程和API文档请参考这里：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://pythonhosted.org/openpyxl/&#34;&gt;http://pythonhosted.org/openpyxl/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;5-references:aebfe74b7cb46f66dc1d78cd9abadd46&#34;&gt;5. References&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;下载 openpyxl：&lt;a href=&#34;https://pypi.python.org/pypi/openpyxl&#34;&gt;https://pypi.python.org/pypi/openpyxl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;openpyxl 文档：&lt;a href=&#34;http://pythonhosted.org/openpyxl/&#34;&gt;http://pythonhosted.org/openpyxl/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Python字典切片</title>
      <link>http://deanthompson.github.io/posts/2012/12/python-dict-slice</link>
      <pubDate>Sat, 01 Dec 2012 15:09:08 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2012/12/python-dict-slice</guid>
      <description>&lt;p&gt;python 的 &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt; 都提供了切片操作，用起来非常方便。有时候会需要对字典进行截取，只需要其中一部分数据。然而 python 的 &lt;code&gt;dict&lt;/code&gt; 没有提供类似的切片操作，所以就得要自己实现。&lt;/p&gt;

&lt;p&gt;其实也很简单：先取出所有 keys，再对 keys 切片，然后用得到的键去字典里找值重新创建一个新的字典。示例代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def dict_slice(adict, start, end):
    keys = adict.keys()
    dict_slice = {}
    for k in keys[start:end]:
        dict_slice[k] = adict[k]
    return dict_slice
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;EDIT 2013-10-26 01:13&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;补充一个一行的版本（one-liner）:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dict_slice = lambda adict, start, end: dict((k, adict[k]) for k in adict.keys()[start:end])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这行代码主要是用了 &lt;code&gt;lambda&lt;/code&gt; 来创建一个匿名函数，再用 built-in 函数 &lt;code&gt;dict()&lt;/code&gt; 来生成新的字典。作用和上面的函数一模一样，调用方式也是一样的。如果是 python 2.7 及以上的版本，还可以用 dict comprehension 来替换 &lt;code&gt;dict()&lt;/code&gt; 函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dict_slice = lambda adict, start, end: { k:adict[k] for k in adict.keys()[start:end] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个看起来和 list comprehension 就很像了。非常优雅，且节省空间 ：）&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;简单验证：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; d = {}.fromkeys(range(10), 5)
&amp;gt;&amp;gt;&amp;gt; d
{0: 5, 1: 5, 2: 5, 3: 5, 4: 5, 5: 5, 6: 5, 7: 5, 8: 5, 9: 5}
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; slice = dict_slice(d, 3, 5)
&amp;gt;&amp;gt;&amp;gt; slice
{3: 5, 4: 5}
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; slice = dict_slice(d, 4, 8)
&amp;gt;&amp;gt;&amp;gt; slice
{4: 5, 5: 5, 6: 5, 7: 5}
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; slice = dict_slice(d, 5, -1)
&amp;gt;&amp;gt;&amp;gt; slice
{5: 5, 6: 5, 7: 5, 8: 5}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在某些场景下，如果需要对字典的切片有其他需求，如字典按键值排序等，还可以在创建新字典之前进行处理。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python 时间戳和日期相互转换</title>
      <link>http://deanthompson.github.io/posts/2012/10/python-timestamp-to-timestr</link>
      <pubDate>Sun, 21 Oct 2012 18:53:51 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2012/10/python-timestamp-to-timestr</guid>
      <description>&lt;p&gt;在写Python的时候经常会遇到时间格式的问题，每次都是上 google 搜索然后找别人的博客或网站来参考。现在自己简单总结一下，方便以后查询。&lt;/p&gt;

&lt;p&gt;首先就是最近用到的时间戳（timestamp）和时间字符串之间的转换。所谓时间戳，就是从 1970 年 1 月 1 日 00:00:00 到现在的秒数。那关于为什么是1970年这个特殊的日期，这篇文章有个简单明了的介绍：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://www.scriptlover.com/static/1071-%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4-%E7%BC%96%E7%A8%8B-%E6%95%B0%E6%8D%AE%E5%BA%93&#34;&gt;为什么计算机时间要从1970年1月1日开始算起？&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在Python里，时间戳可以通过 &lt;code&gt;time&lt;/code&gt; 模块里的 &lt;code&gt;time()&lt;/code&gt; 方法获得，比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;In [1]: import time

In [2]: time.time()
Out[2]: 1350816710.8050799
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个值对人来说是不友好的，所以有时候需要转换为一定的格式方便人理解。我们可以调用 &lt;code&gt;time.strftime()&lt;/code&gt; 函数来达到这个目的。根据 &lt;code&gt;strftime()&lt;/code&gt; 函数的文档，我猜这个名称应该是 “string format time” 的简写，也就是字符串格式的时间。这个方法需要两个参数，其中一个是时间格式，一个是一个9元组，第二个参数可选，默认为 &lt;code&gt;time.localtime()&lt;/code&gt; 的返回值。而那个9元组其实是 &lt;code&gt;struct_time&lt;/code&gt;，由9个元素组成的元组(tuple)，也是一种时间表示的格式。比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;In [5]: import time

In [6]: time.localtime()
Out[6]: time.struct_time(tm_year=2012, tm_mon=10, tm_mday=21, tm_hour=19, tm_min=4, tm_sec=25, tm_wday=6, tm_yday=295, tm_isdst=0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体的含义，前6个应该很明显，那么后三个分别是：weekday(0-6)，在一年中的第几天(1-366)，是否是夏令时（默认-1）。现在再来看看如何把时间戳转换为指定格式的字符串形式。很简单，直接上代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;In [8]: import time

In [9]: st = time.localtime(1350816710.8050799)
 
In [10]: time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;, st)
Out[10]: &#39;2012-10-21 18:51:50&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先用 &lt;code&gt;localtime()&lt;/code&gt; 把时间戳转换为 &lt;code&gt;struct_time&lt;/code&gt;， 然后传给 &lt;code&gt;strftime&lt;/code&gt; 转换为指定格式的字符串。那么反过来呢？
同样需要先转换为 &lt;code&gt;struct_time&lt;/code&gt;，这个工作由 &lt;code&gt;time.strptime()&lt;/code&gt; 函数完成。&lt;code&gt;strptime&lt;/code&gt; 中的 &lt;code&gt;p&lt;/code&gt; 应该是 parse 的意思，原型是:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;strptime(string, format) -&amp;gt; struct_time
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把字符串形式的时间按照指定格式解析，转换为 &lt;code&gt;struct_time&lt;/code&gt;。然后传给&lt;code&gt;time.mktime()&lt;/code&gt; 完成最后的工作，整个过程是:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;In [12]: import time
 
In [13]: st = time.strptime(&#39;2012-10-21 18:51:50&#39;, &#39;%Y-%m-%d %H:%M:%S&#39;)
 
In [14]: time.mktime(st)
Out[14]: 1350816710.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，有两篇参考文章：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Python中时间戳与时间字符串互相转化: &lt;a href=&#34;http://www.coder4.com/archives/2239&#34;&gt;http://www.coder4.com/archives/2239&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python中time模块详解（很好）:&lt;a href=&#34;http://qinxuye.me/article/details-about-time-module-in-python/&#34;&gt;http://qinxuye.me/article/details-about-time-module-in-python/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
