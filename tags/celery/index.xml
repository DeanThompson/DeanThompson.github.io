<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Celery on 李林克斯 </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://deanthompson.github.io/tags/celery/</link>
    <language>zh-CN</language>
    <author>Yangliang Li</author>
    
    <updated>Sat, 14 Nov 2015 16:44:34 CST</updated>
    
    <item>
      <title>Celery 使用简介</title>
      <link>http://deanthompson.github.io/posts/2015/11/a-introduction-to-celery</link>
      <pubDate>Sat, 14 Nov 2015 16:44:34 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/11/a-introduction-to-celery</guid>
      <description>

&lt;h2 id=&#34;introduction:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;Introduction&lt;/h2&gt;

&lt;h3 id=&#34;分布式任务队列:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;分布式任务队列&lt;/h3&gt;

&lt;p&gt;Celery 是一个分布式任务队列，下面是 &lt;a href=&#34;http://www.celeryproject.org/&#34;&gt;官网&lt;/a&gt; 的一段描述：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Celery is an asynchronous task queue/job queue based on distributed message passing.  It is focused on real-time operation, but supports scheduling as well.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Celery 简单、灵活、可靠，是一个专注于实时处理的任务队列，同时也支持任务调度。&lt;/p&gt;

&lt;h3 id=&#34;何为任务队列:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;何为任务队列？&lt;/h3&gt;

&lt;p&gt;摘自 Celery 官方文档的 &lt;a href=&#34;http://docs.jinkan.org/docs/celery/getting-started/introduction.html&#34;&gt;中文翻译&lt;/a&gt;：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;任务队列是一种在线程或机器间分发任务的机制。&lt;/p&gt;

&lt;p&gt;消息队列的输入是工作的一个单元，称为任务，独立的职程（Worker）进程持续监视队列中是否有需要处理的新任务。&lt;/p&gt;

&lt;p&gt;Celery 用消息通信，通常使用中间人（Broker）在客户端和职程间斡旋。这个过程从客户端向队列添加消息开始，之后中间人把消息派送给职程。&lt;/p&gt;

&lt;p&gt;Celery 系统可包含多个职程和中间人，以此获得高可用性和横向扩展能力。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;适用场景:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;适用场景&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;可以在 Request-Response 循环之外执行的操作：发送邮件、推送消息&lt;/li&gt;
&lt;li&gt;耗时的操作：调用第三方 API、视频处理（前端通过 AJAX 展示进度和结果）&lt;/li&gt;
&lt;li&gt;周期性任务：取代 crontab&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;simple-tutorial:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;Simple Tutorial&lt;/h2&gt;

&lt;p&gt;主要参考了官网文档：&lt;a href=&#34;http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html&#34;&gt;First Steps with Celery&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;选择-broker:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;选择 Broker&lt;/h3&gt;

&lt;p&gt;下图描述了 Celery 的基本架构和工作流程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;+------+      +--------+      +----------------+      +--------------+
| User | ---&amp;gt; | Broker | ---&amp;gt; | Workers (1..N) | ---&amp;gt; | Result Store |
+------+      +--------+      +----------------+      +--------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如前文所述，Celery 用消息通信。常用的 Broker 有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt;: RabbitMQ 功能完备、稳定，是一个非常可靠的选择，Celery 官网的评价是 &amp;ldquo;excellent choice for a production environment&amp;rdquo;. 缺点是使用起来毕竟有些复杂。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Redis&lt;/strong&gt;: Redis 同样功能完备，与 RabbitMQ 相比，缺点是可能因为掉电或异常退出导致数据丢失，优点是使用简单。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据库&lt;/strong&gt;: 能方便的集成 SQLAlchemy 和 Django ORM，缺点是性能差，但如果项目本来就用到了数据库，使用起来也非常便利，而且不需要再安装 RabbitMQ 或 Redis.&lt;/li&gt;
&lt;li&gt;其它: 比如 MongoDB, Amazon SQS 还有 IronMQ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们在这里选择使用 Reids.&lt;/p&gt;

&lt;h3 id=&#34;安装:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;安装&lt;/h3&gt;

&lt;p&gt;Celery 是一个 Python 的应用，而且已经上传到了 PyPi，所以可以使用 &lt;code&gt;pip&lt;/code&gt; 或 &lt;code&gt;easy_install&lt;/code&gt; 安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pip install celery
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成后会在 PATH （或 virtualenv 的 bin 目录）添加几个命令：celery, celerybeat, celeryd 和 celeryd-multi. 我们这里只使用 celery 命令。&lt;/p&gt;

&lt;h3 id=&#34;创建-application-和-task:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;创建 Application 和 Task&lt;/h3&gt;

&lt;p&gt;Celery 的使用方法和 Flask 很像，实例化一个 Celery 对象 &lt;code&gt;app&lt;/code&gt;，然后通过 &lt;code&gt;@app.task&lt;/code&gt; 装饰器注册一个 task. 下面是一个简单的例子 tasks.py：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from celery import Celery

app = Celery(__name__, broker=&#39;redis://localhost:6379/0&#39;)


@app.task
def add(x, y):
    return x + y
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;运行-worker:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;运行 worker&lt;/h3&gt;

&lt;p&gt;在 tasks.py 文件所在目录运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ celery worker -A tasks.app -l INFO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令会开启一个在前台运行的 worker，解释这个命令的意义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;worker: 运行 worker 模块&lt;/li&gt;
&lt;li&gt;-A: &amp;ndash;app=APP, 指定使用的 Celery 实例，类似 Gunicorn 的用法&lt;/li&gt;
&lt;li&gt;-l: &amp;ndash;loglevel=INFO, 指定日志级别，可选：DEBUG, INFO, WARNING, ERROR, CRITICAL, FATAL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其它常用的选项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-P: &amp;ndash;pool=prefork, 并发模型，可选：prefork (默认，multiprocessing), eventlet, gevent, threads.&lt;/li&gt;
&lt;li&gt;-c: &amp;ndash;concurrency=10, 并发级别，prefork 模型下就是子进程数量，默认等于 CPU 核心数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完整的命令行选项可以这样查看：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ celery worker --help
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;调用-task:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;调用 task&lt;/h3&gt;

&lt;p&gt;有些 Task 可以当作一个普通的函数同步调用，这里讨论异步的方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from tasks import add

add.delay(1, 2)
add.apply_async(1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面两种调用方式等价，&lt;code&gt;delay()&lt;/code&gt; 方法是 &lt;code&gt;apply_async()&lt;/code&gt; 方法的简写。这个调用会把 &lt;code&gt;add&lt;/code&gt; 操作放入到队列里，然后立即返回一个 &lt;code&gt;AsyncResult&lt;/code&gt; 对象。如果关心处理结果，需要给 &lt;code&gt;app&lt;/code&gt; 配置 &lt;code&gt;CELERY_RESULT_BACKEND&lt;/code&gt;，指定一个存储后端保存任务的返回值。&lt;/p&gt;

&lt;h3 id=&#34;配置:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;配置&lt;/h3&gt;

&lt;p&gt;前文说过 Celery 与 Flask 的使用很像，配置也是如此。一般情况下，使用 Celery 的默认配置就已经足够，但 Celery 也提供了很灵活的配置。下面是两种配置方式，&lt;a href=&#34;http://docs.celeryproject.org/en/latest/configuration.html&#34;&gt;官方文档&lt;/a&gt; 可以查看所有的配置项及默认值。&lt;/p&gt;

&lt;h4 id=&#34;直接修改配置:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;直接修改配置&lt;/h4&gt;

&lt;p&gt;单个：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;app.conf.CELERY_TASK_SERIALIZER = &#39;json&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或批量（支持 &lt;code&gt;dict&lt;/code&gt; 语法）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;app.conf.update(
    CELERY_TASK_SERIALIZER=&#39;json&#39;,
    CELERY_ACCEPT_CONTENT=[&#39;json&#39;],  # Ignore other content
    CELERY_RESULT_SERIALIZER=&#39;json&#39;,
    CELERY_TIMEZONE=&#39;Europe/Oslo&#39;,
    CELERY_ENABLE_UTC=True
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;配置模块:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;配置模块&lt;/h4&gt;

&lt;p&gt;类似 Flask，对于比较大的 Celery 项目，配置模块（configuration module）是更好的选择。Celery 对象有个 &lt;code&gt;config_from_object&lt;/code&gt; 方法，读取一个 object (py 文件或 class)来更新配置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;BROKER_URL = &#39;redis://localhost:6379/0&#39;

CELERY_TASK_SERIALIZER = &#39;json&#39;
CELERY_RESULT_SERIALIZER = &#39;json&#39;
CELERY_ACCEPT_CONTENT=[&#39;json&#39;]
CELERY_TIMEZONE = &#39;Europe/Oslo&#39;
CELERY_ENABLE_UTC = True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把上面的内容保存为 &lt;code&gt;celeryconfig.py&lt;/code&gt; 文件，然后：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;app.config_from_object(&#39;celeryconfig&#39;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
