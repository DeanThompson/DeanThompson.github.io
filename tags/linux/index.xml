<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Linux on 李林克斯 </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://deanthompson.github.io/tags/linux/</link>
    <language>zh-CN</language>
    <author>Yangliang Li</author>
    
    <updated>Fri, 20 Mar 2015 11:00:13 CST</updated>
    
    <item>
      <title>用 Fabric 来发布代码</title>
      <link>http://deanthompson.github.io/posts/2015/03/deploy-applications-using-fabric</link>
      <pubDate>Fri, 20 Mar 2015 11:00:13 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/03/deploy-applications-using-fabric</guid>
      <description>&lt;p&gt;写代码的时候很爽，本地开发一下子完成了，等到部署发布代码的时候就有些烦了。开发环境、测试环境、生产环境，有些配置是因环境而异的，在我们的 Python 项目里，一直保留这样的习惯：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用 py 文件做配置文件&lt;/li&gt;
&lt;li&gt;固定的配置，放在 settings.py 里&lt;/li&gt;
&lt;li&gt;不同环境可能要修改的，放在 site_settings.py 里，然后在 settings.py 里全部 import 进去&lt;/li&gt;
&lt;li&gt;需要使用配置的时候，只需要 &lt;code&gt;settings.FOO&lt;/code&gt; 就可以&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实际上，这样的习惯在发布代码时带来了一些小麻烦。曾经用过这些方式发布 Python 代码：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;rsync. 实际上用 rsync 发布的体验还挺好的，每次只会同步更新过的文件，而且可以配置不需要同步的文件。在使用 rsync 时，site_settings.py 是没有同步的。但是个人体验，rsync 也有不好的地方，首先就是需要依赖 rsync 服务，在远程机器和本地都要配置；二是不好做备份。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git. 应该说，git 应该是我最喜欢的发布方式了，本地 push，远程 pull，完事；而且还很好备份和回滚。再有，如果我「作死」在服务器上修改调试代码，能方便的提交到版本库。但是，考虑到安全问题，很多 git 服务器都搭建在内网，服务器上根本就无法访问到。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;scp. 这是很 low 的一种做法，也基本上是我最后的选择。刚入职到现在这家公司，新部门，有点蛮荒时代的感觉。（非常简陋的）git 服务器在内网，所以在服务器上搞了一下 rsync，配置好后发现本地无法连接到服务器的 873 端口（不知道是不是公司配置了防火墙）。一时间就堕落到选择了 scp. 好处几乎没有，不方便的地方倒是一大堆：不方便增量更新，只能全部覆盖，考虑到 site_settings.py 的存在，这个很不方便；不方便设置要排除的文件，如果想省事把整个项目 scp 过去，就会把 .git 目录和 .pyc 文件也拷过去，无用而慢。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但实际上这些天我还使用了好几次 scp 来发布代码，一直在重复体力劳动。终于，想起了 &lt;a href=&#34;http://www.fabfile.org/&#34;&gt;fabric&lt;/a&gt;，带我「脱离苦海」。&lt;/p&gt;

&lt;p&gt;fabric 使用起来非常简单，对我来说，只需要简单几行代码的配置，就能自动完成我之前繁复的体力劳动。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# -*- coding: utf-8 -*-

import os

from fabric.api import env, local, cd, lcd, put, run


def prod():
    env.hosts = [&amp;quot;123.123.123.123&amp;quot;]
    env.user = &amp;quot;test&amp;quot;
    # env.password = &amp;quot;&amp;quot;  # 用密码登录
    # env.key_filename = &amp;quot;/path/to/keyfile&amp;quot;     # 用 key file 登录（更安全）


def pyclean():
    local(&amp;quot;pyclean .&amp;quot;)      # local 函数执行本地命令


def deploy():
    pyclean()

    local_app_dir = &amp;quot;~/workspace/projects/&amp;quot;
    remote_app_dir = &amp;quot;~/projects&amp;quot;

    # lcd 是 「local cd」，cd 是在远程服务器执行 cd
    with lcd(local_app_dir), cd(remote_app_dir):
        # 1. backup
        run(&amp;quot;rm -rf SomeProj.bak&amp;quot;)          # run 是在远程服务器上执行命令
        run(&amp;quot;mv SomeProj SomeProj.bak&amp;quot;)

        # 2. transfer
        d = os.path.join(remote_app_dir, &amp;quot;SomeProj&amp;quot;)
        run(&amp;quot;mkdir -p %s&amp;quot; % d)
        # put 把本地文件传输到远程（ SFTP (SSH File Transfer Protocol) 协议）
        put(&amp;quot;SomeProj/*&amp;quot;, &amp;quot;SomeProj&amp;quot;)

        # 3. replace site_settings.py
        for subdir in [&amp;quot;apps&amp;quot;, &amp;quot;admin&amp;quot;, &amp;quot;core&amp;quot;]:
            src = &amp;quot;SomeProj.bak/%s/configs/site_settings.py&amp;quot; % subdir
            dest = &amp;quot;SomeProj/%s/configs/site_settings.py&amp;quot; % subdir
            cmd = &amp;quot;cp %s %s&amp;quot; % (src, dest)
            run(cmd)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把上面的代码保存为 fabfile.py，要发布的时候，只需在 fabfile.py 所在的路径执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;fab prod deploy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为在 env 配置里没有设置密码，所以执行过程中需要手动输入一下。然后 fabric 就把所有你指定的事情都干了，一次配置，终生享福。&lt;/p&gt;

&lt;p&gt;实际上还可以配置在发布好代码后，重启应用（supervisorctl）。为了避免意外，和某些情况下需要修改 site_settings.py，所以就没有这么干，而是选择每次都手动重启。&lt;/p&gt;

&lt;p&gt;fabric，又是一个懒人必备的神器。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>重用 SSH 连接</title>
      <link>http://deanthompson.github.io/posts/2015/03/reuse-ssh-connection</link>
      <pubDate>Sun, 15 Mar 2015 13:31:49 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/03/reuse-ssh-connection</guid>
      <description>&lt;p&gt;平时需要经常用到 SSH，比如登录远程服务器，用 Git 推送和更新代码等。建立一次 SSH 连接可能并不需要多久长时间，但是如果要频繁登录同一台服务器，就未免显得有些繁琐和浪费时间。如果是用用户名和密码登录，每次都要输入密码就更加让人崩溃。还有使用 Git 的时候，短时间内可能需要经常 &lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git push&lt;/code&gt;，如果每次操作都需要重新建立连接，等待过程就让人心生厌恶了。&lt;/p&gt;

&lt;p&gt;实际上，SSH 有个「鲜为人知」的特性可以做到重用连接，只有在第一次登录的时候会创建新的连接，后续的会话都可以重用这个已经存在的连接。这样，后续的登录就会非常快，而且不需要输入密码认证。配置也很简单，直接上代码。&lt;/p&gt;

&lt;p&gt;修改 &lt;code&gt;~/.ssh/config&lt;/code&gt; 文件，添加如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sshconfig&#34;&gt;Host *
    ControlMaster auto
    ControlPath /tmp/ssh_mux_%h_%p_%r
    ControlPersist 600
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;意思也很好理解：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Host *&lt;/code&gt; 这一行表示下面这些配置和规则影响到的 host，&lt;code&gt;*&lt;/code&gt; 表示所有的远程 host 都生效。如果要指定某个（些）特定的 host，可以使用类似 &lt;code&gt;Host *.example.com&lt;/code&gt; 的配置。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ControlMaster auto&lt;/code&gt; 这个选项告诉 SSH 客户端尝试重用现有的连接（master connection）。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ControlPath&lt;/code&gt; 指定了这个连接的 socket 保存的路径，这里配置的是在 /tmp 目录，实际上可以在任何有读写权限的路径下。&lt;code&gt;/tmp/ssh_mux_%h_%p_%r&lt;/code&gt; 配置了 socket 文件名，&lt;code&gt;%h&lt;/code&gt; 表示远程主机名（host），&lt;code&gt;%p&lt;/code&gt; 表示远程 SSH 服务器的端口（port），&lt;code&gt;%r&lt;/code&gt; 表示登录的远程用户名（remote user name）。这些 socket 可以随时删掉（&lt;code&gt;rm&lt;/code&gt;），删除后首次会话又会创建新的 master 连接。曾经遇到过这种情况，本地断网了，打开的几个远程终端都卡死，网络恢复后也一直这样，甚至打开新的终端也登录不上。这个时候只需要把之前的 socket 文件都删掉，重新登录就可以了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ControlPersist&lt;/code&gt; 这个选项比较重要，表示在创建首个连接（master connection）的会话退出后，master 连接仍然在后台保留，以便其他复用该连接的会话不会出现问题。这个特性在使用 Git 的时候就非常有用，在频繁提交和拉代码的时候，每次 SSH 会话都是很短暂的，如果 master 连接能保持在后台，后续的操作就会如丝般顺滑。&lt;/p&gt;

&lt;p&gt;只需要添加上面几行配置，SSH 的体验就瞬间上升了好几个档次，简直是懒人必备。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>less 命令支持语法高亮和行号</title>
      <link>http://deanthompson.github.io/posts/2013/11/less-with-syntax-highlight-and-line-number</link>
      <pubDate>Sun, 03 Nov 2013 00:30:00 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2013/11/less-with-syntax-highlight-and-line-number</guid>
      <description>

&lt;p&gt;首先来一句装X的话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;less is more&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;1-how:bea817191773b780e7e12130f8d11db2&#34;&gt;1. How&lt;/h1&gt;

&lt;p&gt;less 是一个很方便的命令行工具，但不足的是不能语法高亮，查看的都是黑白的纯文本。幸运的是，&lt;a href=&#34;http://www.gnu.org/software/src-highlite/&#34;&gt;source-highlight&lt;/a&gt; 可以弥补这一点。在 Ubuntu 安装 source-highlight 非常方便：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install source-highlight
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成后需要做一些简单的配置。编辑 .bashrc，加上以下配置项：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# less hightlight
export LESSOPEN=&amp;quot;| /usr/share/source-highlight/src-hilite-lesspipe.sh %s&amp;quot;
export LESS=&amp;quot; -R &amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要注意的是 &lt;code&gt;/usr/share/source-highlight/src-hilite-lesspipe.sh&lt;/code&gt; 是 &lt;code&gt;src-hilite-lesspipe.sh&lt;/code&gt; 脚本的路径，不同的系统可能不一样，可以查找一下（&lt;code&gt;find / -name src-hilite-lesspipe.sh&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;使配置生效：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;source ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以在之后使用 &lt;code&gt;less filename&lt;/code&gt; 查看文件内容时，支持语法高亮。&lt;/p&gt;

&lt;h1 id=&#34;2-why:bea817191773b780e7e12130f8d11db2&#34;&gt;2. Why&lt;/h1&gt;

&lt;p&gt;接下来看看到底发生了什么事情，可以做到这么「神奇」的效果。&lt;/p&gt;

&lt;h2 id=&#34;2-1-lessopen:bea817191773b780e7e12130f8d11db2&#34;&gt;2.1. LESSOPEN&lt;/h2&gt;

&lt;p&gt;首先来看&lt;code&gt;source-highlight&lt;/code&gt;，这个工具可以根据给定的源文件，读取动态读取语言特性，然后输出一个语法高亮的文件，支持多种输出格式，如 HTML、XHTML、LATEX、 「ANSI &lt;em&gt;color escape sequences&lt;/em&gt; 」等；默认是 HTML格式。最后一种输出格式是 ANSI 颜色转义序列，支持彩色。这种输出格式恰好可以和 less 结合使用，使其输出结果支持语法高亮。&lt;/p&gt;

&lt;p&gt;再看 &lt;code&gt;LESSOPEN&lt;/code&gt;。查看 less 的 man 帮助手册，可以看到 less 支持一个叫 「input preprocessor」的东西，可以在 less 打开源文件之前对源文件进行一次预处理。这个「input preprocessor」 可以自己定义：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;To  set up an input preprocessor, set the LESSOPEN environment variable to a command line which will invoke your input preprocessor.  This command line should include one occurrence of the string &amp;ldquo;%s&amp;rdquo;, which will be replaced by the  filename  when  the input preprocessor command is invoked.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面这句话说明了如何使用自己定义的预处理器，就是设置一下 &lt;code&gt;LESSOPEN&lt;/code&gt; 这个环境变量。那么 &lt;code&gt;LESSOPEN&lt;/code&gt; 到底是什么呢？ 可以在帮助手册找到定义：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Command line to invoke the (optional) input-preprocessor.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;LESSOPEN&lt;/code&gt; 指定一个「input preprocessor」，后面用 &lt;code&gt;%s&lt;/code&gt; 读取文件路径。可以看到上面的配置中，有一个前导的竖线 &lt;code&gt;|&lt;/code&gt;。熟悉 &lt;code&gt;*nix&lt;/code&gt; 命令行的人知道这是管道，这个竖线表示把「input preprocessor」的处理结果写到标准输出（standard output），然后 less 通过 input pipe 读取再显示到屏幕上。&lt;/p&gt;

&lt;h2 id=&#34;2-2-less:bea817191773b780e7e12130f8d11db2&#34;&gt;2.2. LESS&lt;/h2&gt;

&lt;p&gt;另一个变量是 &lt;code&gt;LESS&lt;/code&gt;，同样查看帮助手册：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Options which are passed to less automatically.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也就是自动传给 less 的选项，相当于缺省参数。上面设置的缺省选项是 &lt;code&gt;-R&lt;/code&gt;，看看 &lt;code&gt;-R&lt;/code&gt; 选项的意义：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;-R or &amp;ndash;RAW-CONTROL-CHARS&lt;/p&gt;

&lt;p&gt;Like -r, but only ANSI &amp;ldquo;color&amp;rdquo; escape sequences are output in &amp;ldquo;raw&amp;rdquo; form. &amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个选项的意义是，对于「ANSI &lt;em&gt;color escape sequences&lt;/em&gt; 」是直接输出的，而不错其他处理。上面用 &lt;code&gt;source-highlight&lt;/code&gt; 提供的 src-hilite-lesspipe.sh 脚本用作 「input preprocessor」把源文件进行了高亮处理，并且输出「ANSI &lt;em&gt;color escape sequences&lt;/em&gt; 」格式，这里设置 &lt;code&gt;-R&lt;/code&gt; 选项刚好可以把这个高亮过后的字符序列直接输出，因此就可以看到 less 下的语法高亮。&lt;/p&gt;

&lt;h1 id=&#34;3-more:bea817191773b780e7e12130f8d11db2&#34;&gt;3. More&amp;hellip;&lt;/h1&gt;

&lt;p&gt;在第二节里说到 &lt;code&gt;LESS&lt;/code&gt; 这个环境变量，同理，可以设置其他默认选项，比如 &lt;code&gt;-N&lt;/code&gt;。&lt;code&gt;-N&lt;/code&gt; 选项的意义相对更为显然：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;-N or &amp;ndash;LINE-NUMBERS&lt;/p&gt;

&lt;p&gt;Causes a line number to be displayed at the beginning of each line in the display.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;就是在每一行开头显示行号。这个非常有用啊～于是只要修改一下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export LESS=&amp;quot; -R -N &amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一来，就可以在 less 时既能语法高亮，还能查看行号，感觉很不错的说。试着贴一张效果图看看。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ww3.sinaimg.cn/large/65df5320tw1ea3o9tmdirj20ch0alq3h.jpg&#34; alt=&#34;less-with-syntax-highlight-and-line-number&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;4-references:bea817191773b780e7e12130f8d11db2&#34;&gt;4. References&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;GNU Source-highlight: &lt;a href=&#34;http://www.gnu.org/software/src-highlite/&#34;&gt;http://www.gnu.org/software/src-highlite/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Powering Less to Highlight Syntax and Display Line Numbers:  &lt;a href=&#34;http://greyblake.com/blog/2011/09/23/powering-less-to-highlight-syntax-and-display-line-numbers/&#34;&gt;http://greyblake.com/blog/2011/09/23/powering-less-to-highlight-syntax-and-display-line-numbers/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
