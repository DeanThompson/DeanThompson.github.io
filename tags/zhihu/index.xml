<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Zhihu on 李林克斯 </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://liyangliang.me/tags/zhihu/index.xml</link>
    <language>zh-CN</language>
    <author>Yangliang Li</author>
    
    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
    
    <item>
      <title>zhihu-go 源码解析：用 goquery 解析 HTML</title>
      <link>http://liyangliang.me/posts/2016/03/zhihu-go-insight-parsing-html-with-goquery</link>
      <pubDate>Wed, 30 Mar 2016 23:02:51 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://liyangliang.me/posts/2016/03/zhihu-go-insight-parsing-html-with-goquery</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://liyangliang.me/posts/2016/03/zhihu-go/&#34;&gt;上一篇博客&lt;/a&gt; 简单介绍了 &lt;a href=&#34;https://github.com/DeanThompson/zhihu-go&#34;&gt;zhihu-go&lt;/a&gt; 项目的缘起，本篇简单介绍一下关于处理 HTML 的细节。&lt;/p&gt;

&lt;p&gt;因为知乎没有开发 API，所以只能通过模拟浏览器操作的方式获取数据，这些数据有两种格式：普通的 HTML 文档和某些 Ajax 接口返回的 JSON（返回的数据实际上也是 HTML）。其实也就是爬虫了，抓取网页，然后提取数据。一般来说从 HTML 文档提取数据有这些做法：正则、XPath、CSS 选择器等。对我来说，正则写起来比较复杂，代码可读性差而且维护起来麻烦；XPath 没有详细了解，不过用起来应该不难，而且 Chrome 浏览器可以直接提取 XPath. zhihu-go 里用的是选择器的方式，使用了 &lt;a href=&#34;https://github.com/PuerkitoBio/goquery&#34;&gt;goquery&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;goquery 是 &amp;ldquo;a little like that j-thing, only in Go&amp;rdquo;，也就是用 jQuery 的方式去操作 DOM. jQuery 大家都很熟，API 也很简单明了。本文不详细介绍 goquery，下面选几个场景（API）讲讲在 zhihu-go 里的应用。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;创建-document-对象&#34;&gt;创建 Document 对象&lt;/h3&gt;

&lt;p&gt;goquery 暴露了两个结构体：&lt;code&gt;Document&lt;/code&gt; 和 &lt;code&gt;Selection&lt;/code&gt;. &lt;code&gt;Document&lt;/code&gt; 表示一个 HTML 文档，&lt;code&gt;Selection&lt;/code&gt; 用于像 jQuery 一样操作，支持链式调用。goquery 需要指定一个 HTML 文档才能继续后续的操作，有以下几个构造方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NewDocumentFromNode(root *html.Node) *Document&lt;/code&gt;: 传入 &lt;code&gt;*html.Node&lt;/code&gt; 对象，也就是根节点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NewDocument(url string) (*Document, error)&lt;/code&gt;: 传入 URL，内部用 &lt;code&gt;http.Get&lt;/code&gt; 获取网页。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NewDocumentFromReader(r io.Reader) (*Document, error)&lt;/code&gt;: 传入 &lt;code&gt;io.Reader&lt;/code&gt;，内部从 reader 中读取内容并解析。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NewDocumentFromResponse(res *http.Response) (*Document, error)&lt;/code&gt;: 传入 HTTP 响应，内部拿到 &lt;code&gt;res.Body&lt;/code&gt;(实现了 &lt;code&gt;io.Reader&lt;/code&gt;) 后的处理方式类似 &lt;code&gt;NewDocumentFromReader&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为知乎的页面需要登录才能访问（还需要伪造请求头），而且我们并不想手动解析 HTML 来获取 &lt;code&gt;*html.Node&lt;/code&gt;，最后用到了另外两个构造方法。大致的使用场景是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;请求 HTML 页面（如问题页面），调用 &lt;code&gt;NewDocumentFromResponse&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;请求 Ajax 接口，返回的 JSON 数据里是一些 HTML 片段，用 &lt;code&gt;NewDocumentFromReader&lt;/code&gt;，其中 &lt;code&gt;r = strings.NewReader(html)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了方便举例说明，下文采用这个定义: &lt;code&gt;var doc *goquery.Document&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;查找到指定节点&#34;&gt;查找到指定节点&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Selection&lt;/code&gt; 有一系列类似 jQuery 的方法，&lt;code&gt;Document&lt;/code&gt; 结构体内嵌了 &lt;code&gt;*Selection&lt;/code&gt;，因此也能直接调用这些方法。主要的方法是 &lt;code&gt;Selection.Find(selector string)&lt;/code&gt;，传入一个选择器，返回一个新的，匹配到的 &lt;code&gt;*Selection&lt;/code&gt;，所以能够链式调用。&lt;/p&gt;

&lt;p&gt;比如在用户主页（如 &lt;a href=&#34;https://www.zhihu.com/people/jixin&#34;&gt;黄继新&lt;/a&gt;），要获取用户的 BIO. 首先用 Chrome 定位到对应的 HTML：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;span class=&amp;quot;bio&amp;quot; title=&amp;quot;和知乎在一起&amp;quot;&amp;gt;和知乎在一起&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的 go 代码就是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;doc.Find(&amp;quot;span.bio&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一个选择器对应多个结果，可以使用 &lt;code&gt;First()&lt;/code&gt;, &lt;code&gt;Last()&lt;/code&gt;, &lt;code&gt;Eq(index int)&lt;/code&gt;, &lt;code&gt;Slice(start, end int)&lt;/code&gt; 这些方法进一步定位。&lt;/p&gt;

&lt;p&gt;还是在用户主页，在用户资料栏的底下，从左往右展示了提问数、回答数、文章数、收藏数和公共编辑的次数。查看 HTML 源码后发现这几项的 class 是一样的，所以只能通过下标索引来区分。&lt;/p&gt;

&lt;p&gt;先看 HTML 源码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;profile-navbar clearfix&amp;quot;&amp;gt;
&amp;lt;a class=&amp;quot;item &amp;quot; href=&amp;quot;/people/jixin/asks&amp;quot;&amp;gt;提问&amp;lt;span class=&amp;quot;num&amp;quot;&amp;gt;1336&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;a class=&amp;quot;item &amp;quot; href=&amp;quot;/people/jixin/answers&amp;quot;&amp;gt;回答&amp;lt;span class=&amp;quot;num&amp;quot;&amp;gt;785&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;a class=&amp;quot;item &amp;quot; href=&amp;quot;/people/jixin/posts&amp;quot;&amp;gt;文章&amp;lt;span class=&amp;quot;num&amp;quot;&amp;gt;91&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;a class=&amp;quot;item &amp;quot; href=&amp;quot;/people/jixin/collections&amp;quot;&amp;gt;收藏&amp;lt;span class=&amp;quot;num&amp;quot;&amp;gt;44&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;a class=&amp;quot;item &amp;quot; href=&amp;quot;/people/jixin/logs&amp;quot;&amp;gt;公共编辑&amp;lt;span class=&amp;quot;num&amp;quot;&amp;gt;51648&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要定位找到回答数，对应的 go 代码是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;doc.Find(&amp;quot;div.profile-navbar&amp;quot;).Find(&amp;quot;span.num&amp;quot;).Eq(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;属性操作&#34;&gt;属性操作&lt;/h3&gt;

&lt;p&gt;经常需要获取一个标签的内容和某些属性值，使用 goquery 可以很容易做到。&lt;/p&gt;

&lt;p&gt;继续上面获取回答数的例子，用 &lt;code&gt;Text() string&lt;/code&gt; 方法可以获取标签内的文本内容，其中包含所有子标签。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;text := doc.Find(&amp;quot;div.profile-navbar&amp;quot;).Find(&amp;quot;span.num&amp;quot;).Eq(1).Text()    // &amp;quot;785&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，&lt;code&gt;Text()&lt;/code&gt; 方法返回的字符串，可能前后有很多空白字符，可以视情况做清除。&lt;/p&gt;

&lt;p&gt;获取属性值也很容易，有两个方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Attr(attrName string) (val string, exists bool)&lt;/code&gt;: 返回属性值和该属性是否存在，类似从 &lt;code&gt;map&lt;/code&gt; 中取值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AttrOr(attrName, defaultValue string) string&lt;/code&gt;: 和上一个方法类似，区别在于如果属性不存在，则返回给定的默认值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;常见的使用场景就是获取一个 a 标签的链接。继续上面获取回答的例子，如果想要得到用户回答的主页，可以这么做：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;href, _ := doc.Find(&amp;quot;div.profile-navbar&amp;quot;).Find(&amp;quot;a.item&amp;quot;).Eq(1).Attr(&amp;quot;href&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有其他设置属性、操作 class 的方法，就不展开讨论了。&lt;/p&gt;

&lt;h3 id=&#34;迭代&#34;&gt;迭代&lt;/h3&gt;

&lt;p&gt;很多场景需要返回列表数据，比如问题的关注者列表、所有回答，某个答案的点赞的用户列表等。这种情况下一般需要用到迭代，遍历所有的同类节点，做某些操作。&lt;/p&gt;

&lt;p&gt;goquery 提供了三个用于迭代的方法，都接受一个匿名函数作为参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Each(f func(int, *Selection)) *Selection&lt;/code&gt;: 其中函数 &lt;code&gt;f&lt;/code&gt; 的第一个参数是当前的下标，第二个参数是当前的节点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EachWithBreak(f func(int, *Selection) bool) *Selection&lt;/code&gt;: 和 &lt;code&gt;Each&lt;/code&gt; 类似，增加了中途跳出循环的能力，当 &lt;code&gt;f&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 时结束迭代&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Map(f func(int, *Selection) string) (result []string)&lt;/code&gt;: &lt;code&gt;f&lt;/code&gt; 的参数与上面一样，返回一个 string 类型，最终返回 []string.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比如获取一个收藏夹（如 &lt;a href=&#34;https://www.zhihu.com/collection/19573315&#34;&gt;黄继新的收藏：关于知乎的思考&lt;/a&gt;）下所有的问题，可以这么做（见 &lt;a href=&#34;https://github.com/DeanThompson/zhihu-go/blob/master/collection.go&#34;&gt;zhihu-go/collections.go&lt;/a&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func getQuestionsFromDoc(doc *goquery.Document) []*Question {
	questions := make([]*Question, 0, pageSize)
	items := doc.Find(&amp;quot;div#zh-list-answer-wrap&amp;quot;).Find(&amp;quot;h2.zm-item-title&amp;quot;)
	items.Each(func(index int, sel *goquery.Selection) {
		a := sel.Find(&amp;quot;a&amp;quot;)
		qTitle := strip(a.Text())
		qHref, _ := a.Attr(&amp;quot;href&amp;quot;)
		thisQuestion := NewQuestion(makeZhihuLink(qHref), qTitle)
		questions = append(questions, thisQuestion)
	})
	return questions
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;EachWithBreak&lt;/code&gt; 在 zhihu-go 中也有用到，可以参见 &lt;code&gt;Answer.GetVotersN 方法&lt;/code&gt;：&lt;a href=&#34;https://github.com/DeanThompson/zhihu-go/blob/master/answer.go&#34;&gt;zhihu-go/answer.go&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;删除节点-插入-html-导出-html&#34;&gt;删除节点、插入 HTML、导出 HTML&lt;/h3&gt;

&lt;p&gt;有一个需求是把回答内容输出到 HTML，说白了其实就是修复和清洗 HTML，具体的细节可以看 &lt;a href=&#34;https://github.com/DeanThompson/zhihu-go/blob/master/answer.go#L222&#34;&gt;answer.go 里的 answerSelectionToHtml 函数&lt;/a&gt;. 其中用到了一些需要修改文档的操作。&lt;/p&gt;

&lt;p&gt;比如，调用 &lt;code&gt;Remove()&lt;/code&gt; 方法把一个节点删掉：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;sel.Find(&amp;quot;noscript&amp;quot;).Each(func(_ int, tag *goquery.Selection) {
    tag.Remove() // 把无用的 noscript 去掉
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在节点后插入一段 HTML:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;sel.Find(&amp;quot;img&amp;quot;).Each(func(_ int, tag *goquery.Selection) {
    var src string
    if tag.HasClass(&amp;quot;origin_image&amp;quot;) {
        src, _ = tag.Attr(&amp;quot;data-original&amp;quot;)
    } else {
        src, _ = tag.Attr(&amp;quot;data-actualsrc&amp;quot;)
    }
    tag.SetAttr(&amp;quot;src&amp;quot;, src)
    if tag.Next().Size() == 0 {
        tag.AfterHtml(&amp;quot;&amp;lt;br&amp;gt;&amp;quot;)   // 在 img 标签后插入一个换行
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在标签尾部 append 一段内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;wrapper := `&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;`
doc, _ := goquery.NewDocumentFromReader(strings.NewReader(wrapper))
doc.Find(&amp;quot;body&amp;quot;).AppendSelection(sel)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终输出为 html 文档：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;html, err := doc.Html()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;上面的例子基本涵盖了 zhihu-go 中关于 HTML 操作的场景，得益于 goquery 和 jQuery 的 API 风格，实现起来还是非常简单的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>zhihu-go: 知乎非官方 API库 with Go</title>
      <link>http://liyangliang.me/posts/2016/03/zhihu-go</link>
      <pubDate>Mon, 28 Mar 2016 23:35:58 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://liyangliang.me/posts/2016/03/zhihu-go</guid>
      <description>&lt;p&gt;我是知乎重度用户，每天都会花点时间在知乎上面看点东西。有段时间时间线里经常出现爬虫相关的话题，也看到不少直接爬知乎信息的项目；其中一个就是 &lt;a href=&#34;https://github.com/egrcc/zhihu-python&#34;&gt;zhihu-python&lt;/a&gt;. 实际上 zhihu-python 不是一个完整的爬虫，正如其文档说明的那样，是一个 API 库，可以基于这些 API 实现一个爬虫应用。zhihu-python 实现了用户、问题、答案、收藏夹相关的信息获取类 API，对于大多数信息获取的目的已经足够。这个项目很受欢迎，然而说实话，代码质量一般，不过思路值得借鉴。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;恰巧我也是一个 &lt;a href=&#34;http://golang.org/&#34;&gt;Go 语言&lt;/a&gt; 爱好者，在之前的工作中也用 Go 写过项目。语法简单，开发效率高，性能很好。GitHub 上搜了一下，zhihu-python 或同类项目，并没有一个 Go 实现的版本。于是就想动手造个轮子，把 zhihu-python 移植到 Go，所以就有了标题里提到的 &lt;a href=&#34;https://github.com/DeanThompson/zhihu-go&#34;&gt;zhihu-go&lt;/a&gt;. 主要是出于练手的目的，最近一年都在做 Python 开发，Go 还有点生疏了。因为是移植，最初的设计和实现思路很大程度上参考或模仿了 zhihu-python，后来在开发过程中，新增了一些 API，也删除了少数几个我认为没什么用的 API. 开发过程中又看到了一个 Python 3 版本的实现 &lt;a href=&#34;https://github.com/7sDream/zhihu-py3&#34;&gt;zhihu-py3&lt;/a&gt;，这个库也是受启发于 zhihu-python，代码质量也要更好，而且实现了更丰富的 API，尤其是关于操作类的，如点赞、收藏答案等。zhihu-go 也参考了 zhihu-py3 的一些 API 设计。截止到现在，zhihu-go 的完成度应该和 zhihu-python 差不多，还多了一些 API；比 zhihu-py3 少了活动、评论及操作类的 API，这些在 TODO list 都列了出来。&lt;/p&gt;

&lt;p&gt;前几天在 V2EX 发了一个 &lt;a href=&#34;http://v2ex.com/t/266372&#34;&gt;推广的帖子&lt;/a&gt;，没想到反响还不错，收到不少支持和鼓励，GitHub 也在一两天内收获了 50 来个 star （个人最高）. 其实在这之前，还在 StuduGolang 发了 &lt;a href=&#34;http://studygolang.com/topics/1528&#34;&gt;一个主题&lt;/a&gt;，然而并没有人回复，带到 GitHub 的流量也很少，好像只有 1 个 star. golangtc 也发了，流量就更少了，可以忽略不计。&lt;/p&gt;

&lt;p&gt;后续有时间简单分析一下源码，分享一下开发过程和心得。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
