<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Interface on 李林克斯 </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://deanthompson.github.io/tags/interface/</link>
    <language>zh-CN</language>
    <author>Yangliang Li</author>
    
    <updated>Tue, 03 Jun 2014 16:50:50 CST</updated>
    
    <item>
      <title>Golang 排序</title>
      <link>http://deanthompson.github.io/posts/2014/06/sort-in-golang</link>
      <pubDate>Tue, 03 Jun 2014 16:50:50 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2014/06/sort-in-golang</guid>
      <description>

&lt;h2 id=&#34;interface-接口&#34;&gt;Interface 接口&lt;/h2&gt;

&lt;p&gt;Go 语言标准库提供了排序的package sort，也实现了对 &lt;code&gt;int&lt;/code&gt;， &lt;code&gt;float64&lt;/code&gt; 和 &lt;code&gt;string&lt;/code&gt; 三种基础类型的排序接口。所有排序调用 &lt;code&gt;sort.Sort&lt;/code&gt;，内部根据排序数据个数自动切换排序算法（堆排、快排、插排）。下面这段代码出自 Go 标准库 sort/sort.go：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func quickSort(data Interface, a, b, maxDepth int) {
    for b-a &amp;gt; 7 {
        if maxDepth == 0 {
            heapSort(data, a, b)
            return
        }
        maxDepth--
        mlo, mhi := doPivot(data, a, b)
        // Avoiding recursion on the larger subproblem guarantees
        // a stack depth of at most lg(b-a).
        if mlo-a &amp;lt; b-mhi {
            quickSort(data, a, mlo, maxDepth)
            a = mhi // i.e., quickSort(data, mhi, b)
        } else {
            quickSort(data, mhi, b, maxDepth)
            b = mlo // i.e., quickSort(data, a, mlo)
        }
    }
    if b-a &amp;gt; 1 {
        insertionSort(data, a, b)
    }
}

// Sort sorts data.
// It makes one call to data.Len to determine n, and O(n*log(n)) calls to
// data.Less and data.Swap. The sort is not guaranteed to be stable.
func Sort(data Interface) {
    // Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
    n := data.Len()
    maxDepth := 0
    for i := n; i &amp;gt; 0; i &amp;gt;&amp;gt;= 1 {
        maxDepth++
    }
    maxDepth *= 2
    quickSort(data, 0, n, maxDepth)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里不详细探讨排序算法的实现和性能细节，主要写一下如何使用标准库对基础数据进行排序，以及如何实现对自定义类型的数据进行排序。&lt;/p&gt;

&lt;p&gt;标准库提供一个通用接口，只要实现了这个接口，就可以通过调用 &lt;code&gt;sort.Sort&lt;/code&gt; 来排序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Interface interface {
    // Len is the number of elements in the collection.
    Len() int
    // Less returns whether the element with index i should sort
    // before the element with index j.
    Less(i, j int) bool
    // Swap swaps the elements with indexes i and j.
    Swap(i, j int)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;基本数据类型的排序&#34;&gt;基本数据类型的排序&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Interface&lt;/code&gt; 接口的三个函数分别用于获取长度（&lt;code&gt;Len&lt;/code&gt;）、大小比较（&lt;code&gt;Less&lt;/code&gt;）和交换（&lt;code&gt;Swap&lt;/code&gt;）。对 &lt;code&gt;int&lt;/code&gt;、&lt;code&gt;float64&lt;/code&gt; 和 &lt;code&gt;string&lt;/code&gt; 的排序，标准库已经做好了封装，直接调用即可。以 &lt;code&gt;int&lt;/code&gt; 为例简单说明：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main                                                                                                                                                                                                 

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;sort&amp;quot;
)

func main() {
    a := []int{100, 5, 29, 3, 76}
    fmt.Println(a)     // [100 5 29 3 76]
    sort.Ints(a)       // sort.Sort(IntSlice(a)) 的封装
    fmt.Println(a)     // [3 5 29 76 100]，默认的 Less() 实现的是升序

    a = []int{100, 5, 29, 3, 76}
    fmt.Println(a)     // [100 5 29 3 76]
    sort.Sort(sort.Reverse(sort.IntSlice(a)))
    fmt.Println(a)     // [100 76 29 5 3]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对 &lt;code&gt;float64&lt;/code&gt; 和 &lt;code&gt;string&lt;/code&gt; 的排序，和上面类似。需要注意的是，默认的 &lt;code&gt;sort.Less&lt;/code&gt; 实现的是升序排列，如果想要让结果降序，可以先用 &lt;code&gt;sort.Reverse&lt;/code&gt; 包装一次。这个调用会得到一个 &lt;code&gt;reverse&lt;/code&gt; 的类型，包含一个 &lt;code&gt;Interface&lt;/code&gt; 的匿名字段，其 &lt;code&gt;Less&lt;/code&gt; 函数与 &lt;code&gt;Interface&lt;/code&gt; 里的相反，从而实现逆序。&lt;/p&gt;

&lt;h2 id=&#34;自定义数据类型的排序&#34;&gt;自定义数据类型的排序&lt;/h2&gt;

&lt;p&gt;如果要对自定义的数据类型进行排序，需要实现 &lt;code&gt;sort.Interface&lt;/code&gt; 接口，也就是实现 &lt;code&gt;Len&lt;/code&gt;、&lt;code&gt;Less&lt;/code&gt; 和 &lt;code&gt;Swap&lt;/code&gt; 三个函数。很多场景下 &lt;code&gt;Len&lt;/code&gt; 和 &lt;code&gt;Swap&lt;/code&gt; 基本上和数据类型无关，所以实际上只有 &lt;code&gt;Less&lt;/code&gt; 会有差别。&lt;/p&gt;

&lt;p&gt;例如有个游戏下载排行榜，知道游戏ID和对应的下载量，需要把数据根据下载量进行排序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;math/rand&amp;quot;
    &amp;quot;sort&amp;quot;
)

type GameDownloadItem struct {
    GameID        int // 游戏ID
    DownloadTimes int // 下载次数
}

func (self GameDownloadItem) String() string {
    return fmt.Sprintf(&amp;quot;&amp;lt;Item(%d, %d)&amp;gt;&amp;quot;, self.GameID, self.DownloadTimes)
}

type GameDownloadSlice []*GameDownloadItem

func (p GameDownloadSlice) Len() int {
    return len(p)
}

func (p GameDownloadSlice) Swap(i int, j int) {
    p[i], p[j] = p[j], p[i]
}

// 根据游戏下载量 降序 排列
func (p GameDownloadSlice) Less(i int, j int) bool {
    return p[i].DownloadTimes &amp;gt; p[j].DownloadTimes
}

func main() {
    a := make(GameDownloadSlice, 7)
    for i := 0; i &amp;lt; len(a); i++ {
        a[i] = &amp;amp;GameDownloadItem{i + 1, rand.Intn(1000)}
    }

    fmt.Println(a)
    sort.Sort(a)
    fmt.Println(a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一次输出结果是随机（每次运行结果都一样）生成的未排序的数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;lt;Item(1, 81)&amp;gt; &amp;lt;Item(2, 887)&amp;gt; &amp;lt;Item(3, 847)&amp;gt; &amp;lt;Item(4, 59)&amp;gt; &amp;lt;Item(5, 81)&amp;gt; &amp;lt;Item(6, 318)&amp;gt; &amp;lt;Item(7, 425)&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;排序后：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;lt;Item(2, 887)&amp;gt; &amp;lt;Item(3, 847)&amp;gt; &amp;lt;Item(7, 425)&amp;gt; &amp;lt;Item(6, 318)&amp;gt; &amp;lt;Item(1, 81)&amp;gt; &amp;lt;Item(5, 81)&amp;gt; &amp;lt;Item(4, 59)&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vs-python&#34;&gt;Vs. Python&lt;/h2&gt;

&lt;p&gt;相比之下，Python 里的排序就非常简单便捷了，直接调用 &lt;code&gt;list&lt;/code&gt; 的 &lt;code&gt;sort&lt;/code&gt; 方法（in-place）即可，还可以用 built-in 函数 &lt;code&gt;sorted&lt;/code&gt; （返回新列表）。对于自定义类型指定属性，或 tuple 指定列的排序也很简单，只需要重新定义一下 &lt;code&gt;sort&lt;/code&gt; 方法的 &lt;code&gt;key&lt;/code&gt; 参数。对于上面游戏下载量排序的例子，下面是 python 实现版本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python                                                                                                                                                                                        
# -*- coding: utf-8 -*-

import random

class GameDownloadItem(object):

    def __init__(self, game_id, download_times):
        self.game_id = game_id
        self.download_times = download_times

    def __str__(self):
        return &#39;&amp;lt;Item(%d, %d)&amp;gt;&#39; % (self.game_id, self.download_times)

def display(items):
    for item in items:
        print item,
    print &#39;\n&#39;


if __name__ == &amp;quot;__main__&amp;quot;:
    items = [GameDownloadItem(i+1, random.randrange(1000)) for i in range(7)]
    display(items)

    items.sort(key=lambda item: item.download_times, reverse=True)
    display(items)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;某一次的执行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Item(1, 819)&amp;gt; &amp;lt;Item(2, 959)&amp;gt; &amp;lt;Item(3, 812)&amp;gt; &amp;lt;Item(4, 193)&amp;gt; &amp;lt;Item(5, 408)&amp;gt; &amp;lt;Item(6, 884)&amp;gt; &amp;lt;Item(7, 849)&amp;gt;

&amp;lt;Item(2, 959)&amp;gt; &amp;lt;Item(6, 884)&amp;gt; &amp;lt;Item(7, 849)&amp;gt; &amp;lt;Item(1, 819)&amp;gt; &amp;lt;Item(3, 812)&amp;gt; &amp;lt;Item(5, 408)&amp;gt; &amp;lt;Item(4, 193)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
