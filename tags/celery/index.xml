<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Celery on 李林克斯 </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://deanthompson.github.io/tags/celery/</link>
    <language>zh-CN</language>
    <author>Yangliang Li</author>
    
    <updated>Sat, 14 Nov 2015 16:57:03 CST</updated>
    
    <item>
      <title>在 Flask 项目中使用 Celery</title>
      <link>http://deanthompson.github.io/posts/2015/11/using-celery-with-flask</link>
      <pubDate>Sat, 14 Nov 2015 16:57:03 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/11/using-celery-with-flask</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://deanthompson.github.io/posts/2015/11/a-introduction-to-celery/&#34;&gt;前一篇 Blog&lt;/a&gt; 简单介绍了 Celery 及其用法，现在我们看看在 Flask 项目中如何使用 Celery.&lt;/p&gt;

&lt;p&gt;注意，这篇 Blog 严重参考了这两篇文章：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.miguelgrinberg.com/post/using-celery-with-flask&#34;&gt;Using Celery With Flask&lt;/a&gt;: 写了一个完整而且有意义的例子来展示如何在 Flask 中使用 Celery.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.miguelgrinberg.com/post/celery-and-the-flask-application-factory-pattern&#34;&gt;Celery and the Flask Application Factory Pattern&lt;/a&gt;: 是上文的姊妹篇，描述的是更为真实的场景下，Celery 与 &lt;a href=&#34;http://flask.pocoo.org/docs/0.10/patterns/appfactories/&#34;&gt;Flask Application Factory&lt;/a&gt; 的结合使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;minimum-example:189b2b2b7ede750816eef2f2c404a30a&#34;&gt;Minimum Example&lt;/h2&gt;

&lt;p&gt;Celery 的一些设计和概念，与 Flask 很像，在 Flask 项目中集成 Celery 也很简单，不像 Django 或其他框架需要扩展插件。首先来看个最简单的例子 example.py：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import uuid

from flask import Flask, request, jsonify
from celery import Celery

app = Flask(__name__)
app.config[&#39;CELERY_BROKER_URL&#39;] = &#39;redis://localhost:6379/0&#39;
app.config[&#39;CELERY_RESULT_BACKEND&#39;] = &#39;redis://localhost:6379/0&#39;

celery = Celery(app.name, broker=app.config[&#39;CELERY_BROKER_URL&#39;])
celery.conf.update(app.config)


@celery.task
def send_email(to, subject, content):
    return do_send_email(to, subject, content)


@app.route(&#39;/password/forgot/&#39;, methods=[&#39;POST&#39;])
def reset_password():
    email = request.form[&#39;email&#39;]
    token = str(uuid.uuid4())
    content = u&#39;请点击链接重置密码：http://example.com/password/reset/?token=%s&#39; % token
    send_email.delay(email, content)
    return jsonify(code=0, message=u&#39;发送成功&#39;)


if __name__ == &#39;__main__&#39;:
    app.run()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动 Celery worker:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ celery worker -A example.celery -l INFO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动 Web server:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python example.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，实际应用在生产环境下，不能直接用 Flask 自带的 server，需要使用 Gunicorn 这样的 WSGI 容器，或 uWSGI. 而且 Celery worker 进程和 Web server 进程应该用 supervisord 管理起来。&lt;/p&gt;

&lt;h2 id=&#34;becoming-bigger:189b2b2b7ede750816eef2f2c404a30a&#34;&gt;Becoming Bigger&lt;/h2&gt;

&lt;p&gt;这是个最简单的例子，实际应用会比这个复杂很多：有很多模块，更复杂的配置，更多的 task 等。在这种情况下，Flask 推荐使用 &lt;a href=&#34;http://flask.pocoo.org/docs/0.10/patterns/appfactories/&#34;&gt;Application Factory Pattern&lt;/a&gt;，也就是定义一个 function，在这里创建 Flask app 对象，并且处理注册路由（blueprints）、配置 logging 等一系列初始化操作。&lt;/p&gt;

&lt;p&gt;下面我们看看在更大的 Flask 项目里，应该如何使用 Celery.&lt;/p&gt;

&lt;h3 id=&#34;项目结构:189b2b2b7ede750816eef2f2c404a30a&#34;&gt;项目结构&lt;/h3&gt;

&lt;p&gt;首先来看一下整个项目的结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;.
├── README.md
├── app
│   ├── __init__.py
│   ├── config.py
│   ├── forms
│   ├── models
│   ├── tasks
│   │   ├── __init__.py
│   │   └── email.py
│   └── views
│   │   ├── __init__.py
│   │   └── account.py
├── celery_worker.py
├── manage.py
└── wsgi.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个图里省略了很多细节，简单解释一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;项目的根目录下，有个 &lt;code&gt;celery_worker.py&lt;/code&gt; 的文件，这个文件的作用类似于 &lt;code&gt;wsgi.py&lt;/code&gt;，是启动 Celery worker 的入口。&lt;/li&gt;
&lt;li&gt;app 包里是主要业务代码，其中 tasks 里定义里一系列的 task，提供给其他模块调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;主要代码:189b2b2b7ede750816eef2f2c404a30a&#34;&gt;主要代码。&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;app/config.py&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class BaseConfig(object):
    CELERY_BROKER_URL = &#39;redis://localhost:6379/2&#39;
    CELERY_RESULT_BACKEND = &#39;redis://localhost:6379/2&#39;
    CELERY_TASK_SERIALIZER = &#39;json&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;BaseConfig&lt;/code&gt; 是整个项目用到的配置的基类，实际上还会派生出 &lt;code&gt;DevelopmentConfig&lt;/code&gt;, &lt;code&gt;StagingConfig&lt;/code&gt; 和 &lt;code&gt;ProductionConfig&lt;/code&gt; 等类。这里不讨论配置的细节，也只关心和 Celery 相关的配置项。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;app/__init__.py&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from celery import Celery
from flask import Flask

from app.config import BaseConfig

celery = Celery(__name__, broker=BaseConfig.CELERY_BROKER_URL)


def create_app():
    app = Flask(__name__)
    # ....
    celery.conf.update(app.config)	# 更新 celery 的配置
    # ...
    return app
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;app/tasks/email.py&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from flask import current_app
from celery.util.log import get_task_logger

from app import celery

logger = get_task_logger(__name__)


@celery.task
def send_email(to, subject, content):
    app = current_app._get_current_object()
    subject = app.config[&#39;EMAIL_SUBJECT_PREFIX&#39;] + subject
    logger.info(&#39;send message &amp;quot;%s&amp;quot; to %s&#39;, content, to)
    return do_send_email(to, subject, content)

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;app/views/account.py&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import uuid

from flask import Blueprint, request,jsonify

from app.tasks.email import send_email

bp_account = Blueprint(&#39;account&#39;, __name__)


@bp_account.route(&#39;/password/forgot/&#39;, methods=[&#39;POST&#39;])
def reset_password():
    email = request.form[&#39;email&#39;]
    token = str(uuid.uuid4())
    content = u&#39;请点击链接重置密码：http://example.com/password/reset/?token=%s&#39; % token
    send_email.delay(email, content)
    return jsonify(code=0, message=u&#39;发送成功&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ceelry_worker.py&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from app import create_app, celery

app = create_app()
app.app_context().push()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个 &lt;code&gt;celery_worker.py&lt;/code&gt; 文件有两个操作：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;创建一个 Flask 实例&lt;/li&gt;
&lt;li&gt;推入 Flask application context&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一个操作很简单，其实也是初始化了 celery 实例。&lt;/p&gt;

&lt;p&gt;第二个操作看起来有些奇怪，实际上也很好理解。如果用过 Flask 就应该知道 Flask 的 &lt;a href=&#34;http://flask.pocoo.org/docs/0.10/appcontext/&#34;&gt;Application Context&lt;/a&gt; 和 &lt;a href=&#34;http://flask.pocoo.org/docs/0.10/reqcontext/&#34;&gt;Request Context&lt;/a&gt;. Flask 一个很重要的设计理念是：在一个 Python 进程里可以运行多个应用（application），当存在多个 application 时可以通过 &lt;code&gt;current_app&lt;/code&gt; 获取当前请求所对应的 application. &lt;code&gt;current_app&lt;/code&gt; 绑定的是当前 request 的 application 的引用，在非 request-response 环境里，是没有 request context 的，所以调用 &lt;code&gt;current_app&lt;/code&gt; 就会抛出异常（&lt;code&gt;RuntimeError: working outside of application context&lt;/code&gt;）。创建一个 request context 没有必要，而且消耗资源，所以就引入了 application context.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;app.app_context().push()&lt;/code&gt; 会推入一个 application context，后续所有操作都会在这个环境里执行，直到进程退出。因此，如果在 tasks 里用到了 &lt;code&gt;current_app&lt;/code&gt; 或其它需要 application context 的东西，就一定需要这样做。（默认情况下 Celery 的 pool 是 prefork，也就是多进程，现在这种写法没有问题；但是如果指定使用 gevent，是没用的。这种情况下有别的解决方案，以后会写文章讨论。）&lt;/p&gt;

&lt;h3 id=&#34;运行:189b2b2b7ede750816eef2f2c404a30a&#34;&gt;运行&lt;/h3&gt;

&lt;p&gt;在项目的根路径下启动 Celery worker:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ celery worker -A celery_worker.celery -l INFO
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结:189b2b2b7ede750816eef2f2c404a30a&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;上面两个例子，实际上主要的差别就是初始化方式和模块化，还有需要注意 Flask 的 application context 问题。文章内容比较简单，文中的一些链接是很好的扩展和补充，值得一看。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Celery 使用简介</title>
      <link>http://deanthompson.github.io/posts/2015/11/a-introduction-to-celery</link>
      <pubDate>Sat, 14 Nov 2015 16:44:34 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/11/a-introduction-to-celery</guid>
      <description>

&lt;h2 id=&#34;introduction:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;Introduction&lt;/h2&gt;

&lt;h3 id=&#34;分布式任务队列:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;分布式任务队列&lt;/h3&gt;

&lt;p&gt;Celery 是一个分布式任务队列，下面是 &lt;a href=&#34;http://www.celeryproject.org/&#34;&gt;官网&lt;/a&gt; 的一段描述：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Celery is an asynchronous task queue/job queue based on distributed message passing.  It is focused on real-time operation, but supports scheduling as well.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Celery 简单、灵活、可靠，是一个专注于实时处理的任务队列，同时也支持任务调度。&lt;/p&gt;

&lt;h3 id=&#34;何为任务队列:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;何为任务队列？&lt;/h3&gt;

&lt;p&gt;摘自 Celery 官方文档的 &lt;a href=&#34;http://docs.jinkan.org/docs/celery/getting-started/introduction.html&#34;&gt;中文翻译&lt;/a&gt;：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;任务队列是一种在线程或机器间分发任务的机制。&lt;/p&gt;

&lt;p&gt;消息队列的输入是工作的一个单元，称为任务，独立的职程（Worker）进程持续监视队列中是否有需要处理的新任务。&lt;/p&gt;

&lt;p&gt;Celery 用消息通信，通常使用中间人（Broker）在客户端和职程间斡旋。这个过程从客户端向队列添加消息开始，之后中间人把消息派送给职程。&lt;/p&gt;

&lt;p&gt;Celery 系统可包含多个职程和中间人，以此获得高可用性和横向扩展能力。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;适用场景:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;适用场景&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;可以在 Request-Response 循环之外执行的操作：发送邮件、推送消息&lt;/li&gt;
&lt;li&gt;耗时的操作：调用第三方 API、视频处理（前端通过 AJAX 展示进度和结果）&lt;/li&gt;
&lt;li&gt;周期性任务：取代 crontab&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;simple-tutorial:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;Simple Tutorial&lt;/h2&gt;

&lt;p&gt;主要参考了官网文档：&lt;a href=&#34;http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html&#34;&gt;First Steps with Celery&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;选择-broker:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;选择 Broker&lt;/h3&gt;

&lt;p&gt;下图描述了 Celery 的基本架构和工作流程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;+------+      +--------+      +----------------+      +--------------+
| User | ---&amp;gt; | Broker | ---&amp;gt; | Workers (1..N) | ---&amp;gt; | Result Store |
+------+      +--------+      +----------------+      +--------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如前文所述，Celery 用消息通信。常用的 Broker 有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt;: RabbitMQ 功能完备、稳定，是一个非常可靠的选择，Celery 官网的评价是 &amp;ldquo;excellent choice for a production environment&amp;rdquo;. 缺点是使用起来毕竟有些复杂。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Redis&lt;/strong&gt;: Redis 同样功能完备，与 RabbitMQ 相比，缺点是可能因为掉电或异常退出导致数据丢失，优点是使用简单。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据库&lt;/strong&gt;: 能方便的集成 SQLAlchemy 和 Django ORM，缺点是性能差，但如果项目本来就用到了数据库，使用起来也非常便利，而且不需要再安装 RabbitMQ 或 Redis.&lt;/li&gt;
&lt;li&gt;其它: 比如 MongoDB, Amazon SQS 还有 IronMQ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们在这里选择使用 Reids.&lt;/p&gt;

&lt;h3 id=&#34;安装:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;安装&lt;/h3&gt;

&lt;p&gt;Celery 是一个 Python 的应用，而且已经上传到了 PyPi，所以可以使用 &lt;code&gt;pip&lt;/code&gt; 或 &lt;code&gt;easy_install&lt;/code&gt; 安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pip install celery
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成后会在 PATH （或 virtualenv 的 bin 目录）添加几个命令：celery, celerybeat, celeryd 和 celeryd-multi. 我们这里只使用 celery 命令。&lt;/p&gt;

&lt;h3 id=&#34;创建-application-和-task:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;创建 Application 和 Task&lt;/h3&gt;

&lt;p&gt;Celery 的使用方法和 Flask 很像，实例化一个 Celery 对象 &lt;code&gt;app&lt;/code&gt;，然后通过 &lt;code&gt;@app.task&lt;/code&gt; 装饰器注册一个 task. 下面是一个简单的例子 tasks.py：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from celery import Celery

app = Celery(__name__, broker=&#39;redis://localhost:6379/0&#39;)


@app.task
def add(x, y):
    return x + y
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;运行-worker:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;运行 worker&lt;/h3&gt;

&lt;p&gt;在 tasks.py 文件所在目录运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ celery worker -A tasks.app -l INFO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令会开启一个在前台运行的 worker，解释这个命令的意义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;worker: 运行 worker 模块&lt;/li&gt;
&lt;li&gt;-A: &amp;ndash;app=APP, 指定使用的 Celery 实例，类似 Gunicorn 的用法&lt;/li&gt;
&lt;li&gt;-l: &amp;ndash;loglevel=INFO, 指定日志级别，可选：DEBUG, INFO, WARNING, ERROR, CRITICAL, FATAL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其它常用的选项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-P: &amp;ndash;pool=prefork, 并发模型，可选：prefork (默认，multiprocessing), eventlet, gevent, threads.&lt;/li&gt;
&lt;li&gt;-c: &amp;ndash;concurrency=10, 并发级别，prefork 模型下就是子进程数量，默认等于 CPU 核心数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完整的命令行选项可以这样查看：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ celery worker --help
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;调用-task:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;调用 task&lt;/h3&gt;

&lt;p&gt;有些 Task 可以当作一个普通的函数同步调用，这里讨论异步的方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from tasks import add

add.delay(1, 2)
add.apply_async(1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面两种调用方式等价，&lt;code&gt;delay()&lt;/code&gt; 方法是 &lt;code&gt;apply_async()&lt;/code&gt; 方法的简写。这个调用会把 &lt;code&gt;add&lt;/code&gt; 操作放入到队列里，然后立即返回一个 &lt;code&gt;AsyncResult&lt;/code&gt; 对象。如果关心处理结果，需要给 &lt;code&gt;app&lt;/code&gt; 配置 &lt;code&gt;CELERY_RESULT_BACKEND&lt;/code&gt;，指定一个存储后端保存任务的返回值。&lt;/p&gt;

&lt;h3 id=&#34;配置:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;配置&lt;/h3&gt;

&lt;p&gt;前文说过 Celery 与 Flask 的使用很像，配置也是如此。一般情况下，使用 Celery 的默认配置就已经足够，但 Celery 也提供了很灵活的配置。下面是两种配置方式，&lt;a href=&#34;http://docs.celeryproject.org/en/latest/configuration.html&#34;&gt;官方文档&lt;/a&gt; 可以查看所有的配置项及默认值。&lt;/p&gt;

&lt;h4 id=&#34;直接修改配置:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;直接修改配置&lt;/h4&gt;

&lt;p&gt;单个：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;app.conf.CELERY_TASK_SERIALIZER = &#39;json&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或批量（支持 &lt;code&gt;dict&lt;/code&gt; 语法）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;app.conf.update(
    CELERY_TASK_SERIALIZER=&#39;json&#39;,
    CELERY_ACCEPT_CONTENT=[&#39;json&#39;],  # Ignore other content
    CELERY_RESULT_SERIALIZER=&#39;json&#39;,
    CELERY_TIMEZONE=&#39;Europe/Oslo&#39;,
    CELERY_ENABLE_UTC=True
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;配置模块:d2146fb3793abd4f6cbfeada8f10d4fd&#34;&gt;配置模块&lt;/h4&gt;

&lt;p&gt;类似 Flask，对于比较大的 Celery 项目，配置模块（configuration module）是更好的选择。Celery 对象有个 &lt;code&gt;config_from_object&lt;/code&gt; 方法，读取一个 object (py 文件或 class)来更新配置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;BROKER_URL = &#39;redis://localhost:6379/0&#39;

CELERY_TASK_SERIALIZER = &#39;json&#39;
CELERY_RESULT_SERIALIZER = &#39;json&#39;
CELERY_ACCEPT_CONTENT=[&#39;json&#39;]
CELERY_TIMEZONE = &#39;Europe/Oslo&#39;
CELERY_ENABLE_UTC = True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把上面的内容保存为 &lt;code&gt;celeryconfig.py&lt;/code&gt; 文件，然后：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;app.config_from_object(&#39;celeryconfig&#39;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
