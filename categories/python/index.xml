<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Python on 李林克斯 </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://deanthompson.github.io/categories/python/index.xml</link>
    <language>zh-CN</language>
    <author>Yangliang Li</author>
    
    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
    
    <item>
      <title>Python 多进程导入数据到 MySQL</title>
      <link>http://deanthompson.github.io/posts/2017/02/load-data-into-mysql-using-python-multiprocessing</link>
      <pubDate>Sat, 25 Feb 2017 16:16:14 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2017/02/load-data-into-mysql-using-python-multiprocessing</guid>
      <description>&lt;p&gt;前段时间帮同事处理了一个把 CSV 数据导入到 MySQL 的需求。两个很大的 CSV 文件，
分别有 3GB、2100 万条记录和 7GB、3500 万条记录。对于这个量级的数据，用简单的单进程／单线程导入
会耗时很久，最终用了多进程的方式来实现。具体过程不赘述，记录一下几个要点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;批量插入而不是逐条插入&lt;/li&gt;
&lt;li&gt;为了加快插入速度，先不要建索引&lt;/li&gt;
&lt;li&gt;生产者和消费者模型，主进程读文件，多个 worker 进程执行插入&lt;/li&gt;
&lt;li&gt;注意控制 worker 的数量，避免对 MySQL 造成太大的压力&lt;/li&gt;
&lt;li&gt;注意处理脏数据导致的异常&lt;/li&gt;
&lt;li&gt;原始数据是 GBK 编码，所以还要注意转换成 UTF-8&lt;/li&gt;
&lt;li&gt;用 &lt;a href=&#34;http://click.pocoo.org/5/&#34;&gt;click&lt;/a&gt; 封装命令行工具&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体的代码实现如下：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import codecs
import csv
import logging
import multiprocessing
import os
import warnings

import click
import MySQLdb
import sqlalchemy

warnings.filterwarnings(&#39;ignore&#39;, category=MySQLdb.Warning)

# 批量插入的记录数量
BATCH = 5000

DB_URI = &#39;mysql://root@localhost:3306/example?charset=utf8&#39;

engine = sqlalchemy.create_engine(DB_URI)


def get_table_cols(table):
    sql = &#39;SELECT * FROM `{table}` LIMIT 0&#39;.format(table=table)
    res = engine.execute(sql)
    return res.keys()


def insert_many(table, cols, rows, cursor):
    sql = &#39;INSERT INTO `{table}` ({cols}) VALUES ({marks})&#39;.format(
            table=table,
            cols=&#39;, &#39;.join(cols),
            marks=&#39;, &#39;.join([&#39;%s&#39;] * len(cols)))
    cursor.execute(sql, *rows)
    logging.info(&#39;process %s inserted %s rows into table %s&#39;, os.getpid(), len(rows), table)


def insert_worker(table, cols, queue):
    rows = []
    # 每个子进程创建自己的 engine 对象
    cursor = sqlalchemy.create_engine(DB_URI)
    while True:
        row = queue.get()
        if row is None:
            if rows:
                insert_many(table, cols, rows, cursor)
            break

        rows.append(row)
        if len(rows) == BATCH:
            insert_many(table, cols, rows, cursor)
            rows = []


def insert_parallel(table, reader, w=10):
    cols = get_table_cols(table)

    # 数据队列，主进程读文件并往里写数据，worker 进程从队列读数据
    # 注意一下控制队列的大小，避免消费太慢导致堆积太多数据，占用过多内存
    queue = multiprocessing.Queue(maxsize=w*BATCH*2)
    workers = []
    for i in range(w):
        p = multiprocessing.Process(target=insert_worker, args=(table, cols, queue))
        p.start()
        workers.append(p)
        logging.info(&#39;starting # %s worker process, pid: %s...&#39;, i + 1, p.pid)

    dirty_data_file = &#39;./{}_dirty_rows.csv&#39;.format(table)
    xf = open(dirty_data_file, &#39;w&#39;)
    writer = csv.writer(xf, delimiter=reader.dialect.delimiter)

    for line in reader:
        # 记录并跳过脏数据: 键值数量不一致
        if len(line) != len(cols):
            writer.writerow(line)
            continue

        # 把 None 值替换为 &#39;NULL&#39;
        clean_line = [None if x == &#39;NULL&#39; else x for x in line]

        # 往队列里写数据
        queue.put(tuple(clean_line))
        if reader.line_num % 500000 == 0:
            logging.info(&#39;put %s tasks into queue.&#39;, reader.line_num)

    xf.close()

    # 给每个 worker 发送任务结束的信号
    logging.info(&#39;send close signal to worker processes&#39;)
    for i in range(w):
        queue.put(None)

    for p in workers:
        p.join()


def convert_file_to_utf8(f, rv_file=None):
    if not rv_file:
        name, ext = os.path.splitext(f)
        if isinstance(name, unicode):
            name = name.encode(&#39;utf8&#39;)
        rv_file = &#39;{}_utf8{}&#39;.format(name, ext)
    logging.info(&#39;start to process file %s&#39;, f)
    with open(f) as infd:
        with open(rv_file, &#39;w&#39;) as outfd:
            lines = []
            loop = 0
            chunck = 200000
            first_line = infd.readline().strip(codecs.BOM_UTF8).strip() + &#39;\n&#39;
            lines.append(first_line)
            for line in infd:
                clean_line = line.decode(&#39;gb18030&#39;).encode(&#39;utf8&#39;)
                clean_line = clean_line.rstrip() + &#39;\n&#39;
                lines.append(clean_line)
                if len(lines) == chunck:
                    outfd.writelines(lines)
                    lines = []
                    loop += 1
                    logging.info(&#39;processed %s lines.&#39;, loop * chunck)

            outfd.writelines(lines)
            logging.info(&#39;processed %s lines.&#39;, loop * chunck + len(lines))


@click.group()
def cli():
    logging.basicConfig(level=logging.INFO,
                        format=&#39;%(asctime)s - %(levelname)s - %(name)s - %(message)s&#39;)


@cli.command(&#39;gbk_to_utf8&#39;)
@click.argument(&#39;f&#39;)
def convert_gbk_to_utf8(f):
    convert_file_to_utf8(f)


@cli.command(&#39;load&#39;)
@click.option(&#39;-t&#39;, &#39;--table&#39;, required=True, help=&#39;表名&#39;)
@click.option(&#39;-i&#39;, &#39;--filename&#39;, required=True, help=&#39;输入文件&#39;)
@click.option(&#39;-w&#39;, &#39;--workers&#39;, default=10, help=&#39;worker 数量，默认 10&#39;)
def load_fac_day_pro_nos_sal_table(table, filename, workers):
    with open(filename) as fd:
        fd.readline()   # skip header
        reader = csv.reader(fd)
        insert_parallel(table, reader, w=workers)


if __name__ == &#39;__main__&#39;:
    cli()
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>在 Flask 项目的 celery 中使用 gevent</title>
      <link>http://deanthompson.github.io/posts/2016/05/using-celery-with-flask-and-gevent</link>
      <pubDate>Tue, 17 May 2016 16:42:37 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2016/05/using-celery-with-flask-and-gevent</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://deanthompson.github.io/posts/2015/11/using-celery-with-flask/&#34;&gt;在 Flask 项目中使用 Celery&lt;/a&gt; 这篇文章谈到了如何在 Flask 项目中集成 Celery，也讲了在 celery 任务中引用 Flask 的 application context 的方法。一般情况下那样使用是没问题的，但是如果需要在 task 中使用 gevent，就需要一些额外的改进。至少有两点。&lt;/p&gt;

&lt;h2 id=&#34;1-使用-gevent-并发模型&#34;&gt;1. 使用 gevent 并发模型&lt;/h2&gt;

&lt;p&gt;如果在 task 中要使用 gevent，就必须使用 gevent 并发模型。这很好处理，只需要修改启动选项就行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ celery worker -A celery_worker.celery -P gevent -c 10 -l INFO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的命令，&lt;code&gt;-P&lt;/code&gt; 选项指定 pool，默认是 prefork，这里是 gevent; &lt;code&gt;-c&lt;/code&gt; 设置并发数。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-引用-flask-的-application-context&#34;&gt;2. 引用 Flask 的 application context&lt;/h2&gt;

&lt;p&gt;这个问题也是在 &lt;a href=&#34;http://deanthompson.github.io/posts/2015/11/using-celery-with-flask/&#34;&gt;在 Flask 项目中使用 Celery&lt;/a&gt; 中重点讨论的，在这种场景下，上文的解决方法起不到作用，仍然会报错（具体原因不太懂，知道的朋友请不吝赐教）。解决方案就是，把需要引用 Flask app 的地方（如 app.config），放到 Flask 的 application context 里执行，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with app.app_context():
    print app.config.get(&#39;SOME_CONFIG_KEY&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在实际应用中，我最后写了个装饰器来实现这个目的。简单介绍一下场景，项目用到了 Flask-Cache，项目启动时会创建全局单例 &lt;code&gt;cache&lt;/code&gt;，并在 &lt;code&gt;create_app&lt;/code&gt; 中进行初始化。在 Flask-Cache 初始化时，会把当前的 Flask app 对象绑定到实例 &lt;code&gt;cache&lt;/code&gt; 中，所以可以尝试从这里获取 app 对象。&lt;/p&gt;

&lt;p&gt;代码的目录结构与之前一样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── README.md
├── app
│   ├── __init__.py
│   ├── config.py
│   ├── forms
│   ├── models
│   ├── tasks
│   │   ├── __init__.py
│   │   └── email.py
│   └── views
│   │   ├── __init__.py
│   │   └── account.py
├── celery_worker.py
├── manage.py
└── wsgi.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;装饰器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def with_app_context(task):
    memo = {&#39;app&#39;: None}

    @functools.wraps(task)
    def _wrapper(*args, **kwargs):
        if not memo[&#39;app&#39;]:
            try:
                # 尝试从 cache 中获取 app 对象，如果得到的不是 None，就不需要重复创建了
                app = cache.app
                _ = app.name
            except Exception:
                from app import create_app

                app = create_app()
            memo[&#39;app&#39;] = app
        else:
            app = memo[&#39;app&#39;]

        # 把 task 放到 application context 环境中运行
        with app.app_context():
            return task(*args, **kwargs)

    return _wrapper
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@celery.task()
@with_app_context
def add(x, y):
    print app.config.get(&#39;SOME_CONFIG_KEY&#39;)
    return x + y
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>在 Flask 项目中使用 Celery</title>
      <link>http://deanthompson.github.io/posts/2015/11/using-celery-with-flask</link>
      <pubDate>Sat, 14 Nov 2015 16:57:03 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/11/using-celery-with-flask</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://deanthompson.github.io/posts/2015/11/a-introduction-to-celery/&#34;&gt;前一篇 Blog&lt;/a&gt; 简单介绍了 Celery 及其用法，现在我们看看在 Flask 项目中如何使用 Celery.&lt;/p&gt;

&lt;p&gt;注意，这篇 Blog 严重参考了这两篇文章：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.miguelgrinberg.com/post/using-celery-with-flask&#34;&gt;Using Celery With Flask&lt;/a&gt;: 写了一个完整而且有意义的例子来展示如何在 Flask 中使用 Celery.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.miguelgrinberg.com/post/celery-and-the-flask-application-factory-pattern&#34;&gt;Celery and the Flask Application Factory Pattern&lt;/a&gt;: 是上文的姊妹篇，描述的是更为真实的场景下，Celery 与 &lt;a href=&#34;http://flask.pocoo.org/docs/0.10/patterns/appfactories/&#34;&gt;Flask Application Factory&lt;/a&gt; 的结合使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;minimum-example&#34;&gt;Minimum Example&lt;/h2&gt;

&lt;p&gt;Celery 的一些设计和概念，与 Flask 很像，在 Flask 项目中集成 Celery 也很简单，不像 Django 或其他框架需要扩展插件。首先来看个最简单的例子 example.py：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import uuid

from flask import Flask, request, jsonify
from celery import Celery

app = Flask(__name__)
app.config[&#39;CELERY_BROKER_URL&#39;] = &#39;redis://localhost:6379/0&#39;
app.config[&#39;CELERY_RESULT_BACKEND&#39;] = &#39;redis://localhost:6379/0&#39;

celery = Celery(app.name, broker=app.config[&#39;CELERY_BROKER_URL&#39;])
celery.conf.update(app.config)


@celery.task
def send_email(to, subject, content):
    return do_send_email(to, subject, content)


@app.route(&#39;/password/forgot/&#39;, methods=[&#39;POST&#39;])
def reset_password():
    email = request.form[&#39;email&#39;]
    token = str(uuid.uuid4())
    content = u&#39;请点击链接重置密码：http://example.com/password/reset/?token=%s&#39; % token
    send_email.delay(email, content)
    return jsonify(code=0, message=u&#39;发送成功&#39;)


if __name__ == &#39;__main__&#39;:
    app.run()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动 Celery worker:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ celery worker -A example.celery -l INFO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动 Web server:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python example.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，实际应用在生产环境下，不能直接用 Flask 自带的 server，需要使用 Gunicorn 这样的 WSGI 容器，或 uWSGI. 而且 Celery worker 进程和 Web server 进程应该用 supervisord 管理起来。&lt;/p&gt;

&lt;h2 id=&#34;becoming-bigger&#34;&gt;Becoming Bigger&lt;/h2&gt;

&lt;p&gt;这是个最简单的例子，实际应用会比这个复杂很多：有很多模块，更复杂的配置，更多的 task 等。在这种情况下，Flask 推荐使用 &lt;a href=&#34;http://flask.pocoo.org/docs/0.10/patterns/appfactories/&#34;&gt;Application Factory Pattern&lt;/a&gt;，也就是定义一个 function，在这里创建 Flask app 对象，并且处理注册路由（blueprints）、配置 logging 等一系列初始化操作。&lt;/p&gt;

&lt;p&gt;下面我们看看在更大的 Flask 项目里，应该如何使用 Celery.&lt;/p&gt;

&lt;h3 id=&#34;项目结构&#34;&gt;项目结构&lt;/h3&gt;

&lt;p&gt;首先来看一下整个项目的结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── README.md
├── app
│   ├── __init__.py
│   ├── config.py
│   ├── forms
│   ├── models
│   ├── tasks
│   │   ├── __init__.py
│   │   └── email.py
│   └── views
│   │   ├── __init__.py
│   │   └── account.py
├── celery_worker.py
├── manage.py
└── wsgi.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个图里省略了很多细节，简单解释一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;项目的根目录下，有个 &lt;code&gt;celery_worker.py&lt;/code&gt; 的文件，这个文件的作用类似于 &lt;code&gt;wsgi.py&lt;/code&gt;，是启动 Celery worker 的入口。&lt;/li&gt;
&lt;li&gt;app 包里是主要业务代码，其中 tasks 里定义里一系列的 task，提供给其他模块调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;主要代码&#34;&gt;主要代码。&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;app/config.py&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class BaseConfig(object):
    CELERY_BROKER_URL = &#39;redis://localhost:6379/2&#39;
    CELERY_RESULT_BACKEND = &#39;redis://localhost:6379/2&#39;
    CELERY_TASK_SERIALIZER = &#39;json&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;BaseConfig&lt;/code&gt; 是整个项目用到的配置的基类，实际上还会派生出 &lt;code&gt;DevelopmentConfig&lt;/code&gt;, &lt;code&gt;StagingConfig&lt;/code&gt; 和 &lt;code&gt;ProductionConfig&lt;/code&gt; 等类。这里不讨论配置的细节，也只关心和 Celery 相关的配置项。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;app/__init__.py&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from celery import Celery
from flask import Flask

from app.config import BaseConfig

celery = Celery(__name__, broker=BaseConfig.CELERY_BROKER_URL)


def create_app():
    app = Flask(__name__)
    # ....
    celery.conf.update(app.config)	# 更新 celery 的配置
    # ...
    return app
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;app/tasks/email.py&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from flask import current_app
from celery.utils.log import get_task_logger

from app import celery

logger = get_task_logger(__name__)


@celery.task
def send_email(to, subject, content):
    app = current_app._get_current_object()
    subject = app.config[&#39;EMAIL_SUBJECT_PREFIX&#39;] + subject
    logger.info(&#39;send message &amp;quot;%s&amp;quot; to %s&#39;, content, to)
    return do_send_email(to, subject, content)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;app/views/account.py&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import uuid

from flask import Blueprint, request,jsonify

from app.tasks.email import send_email

bp_account = Blueprint(&#39;account&#39;, __name__)


@bp_account.route(&#39;/password/forgot/&#39;, methods=[&#39;POST&#39;])
def reset_password():
    email = request.form[&#39;email&#39;]
    token = str(uuid.uuid4())
    content = u&#39;请点击链接重置密码：http://example.com/password/reset/?token=%s&#39; % token
    send_email.delay(email, content)
    return jsonify(code=0, message=u&#39;发送成功&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ceelry_worker.py&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from app import create_app, celery

app = create_app()
app.app_context().push()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个 &lt;code&gt;celery_worker.py&lt;/code&gt; 文件有两个操作：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;创建一个 Flask 实例&lt;/li&gt;
&lt;li&gt;推入 Flask application context&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一个操作很简单，其实也是初始化了 celery 实例。&lt;/p&gt;

&lt;p&gt;第二个操作看起来有些奇怪，实际上也很好理解。如果用过 Flask 就应该知道 Flask 的 &lt;a href=&#34;http://flask.pocoo.org/docs/0.10/appcontext/&#34;&gt;Application Context&lt;/a&gt; 和 &lt;a href=&#34;http://flask.pocoo.org/docs/0.10/reqcontext/&#34;&gt;Request Context&lt;/a&gt;. Flask 一个很重要的设计理念是：在一个 Python 进程里可以运行多个应用（application），当存在多个 application 时可以通过 &lt;code&gt;current_app&lt;/code&gt; 获取当前请求所对应的 application. &lt;code&gt;current_app&lt;/code&gt; 绑定的是当前 request 的 application 的引用，在非 request-response 环境里，是没有 request context 的，所以调用 &lt;code&gt;current_app&lt;/code&gt; 就会抛出异常（&lt;code&gt;RuntimeError: working outside of application context&lt;/code&gt;）。创建一个 request context 没有必要，而且消耗资源，所以就引入了 application context.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;app.app_context().push()&lt;/code&gt; 会推入一个 application context，后续所有操作都会在这个环境里执行，直到进程退出。因此，如果在 tasks 里用到了 &lt;code&gt;current_app&lt;/code&gt; 或其它需要 application context 的东西，就一定需要这样做。（默认情况下 Celery 的 pool 是 prefork，也就是多进程，现在这种写法没有问题；但是如果指定使用 gevent，是没用的。这种情况下有别的解决方案，以后会写文章讨论。）&lt;/p&gt;

&lt;h3 id=&#34;运行&#34;&gt;运行&lt;/h3&gt;

&lt;p&gt;在项目的根路径下启动 Celery worker:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ celery worker -A celery_worker.celery -l INFO
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;上面两个例子，实际上主要的差别就是初始化方式和模块化，还有需要注意 Flask 的 application context 问题。文章内容比较简单，文中的一些链接是很好的扩展和补充，值得一看。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Celery 使用简介</title>
      <link>http://deanthompson.github.io/posts/2015/11/a-introduction-to-celery</link>
      <pubDate>Sat, 14 Nov 2015 16:44:34 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/11/a-introduction-to-celery</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;h3 id=&#34;分布式任务队列&#34;&gt;分布式任务队列&lt;/h3&gt;

&lt;p&gt;Celery 是一个分布式任务队列，下面是 &lt;a href=&#34;http://www.celeryproject.org/&#34;&gt;官网&lt;/a&gt; 的一段描述：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Celery is an asynchronous task queue/job queue based on distributed message passing.  It is focused on real-time operation, but supports scheduling as well.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Celery 简单、灵活、可靠，是一个专注于实时处理的任务队列，同时也支持任务调度。&lt;/p&gt;

&lt;h3 id=&#34;何为任务队列&#34;&gt;何为任务队列？&lt;/h3&gt;

&lt;p&gt;摘自 Celery 官方文档的 &lt;a href=&#34;http://docs.jinkan.org/docs/celery/getting-started/introduction.html&#34;&gt;中文翻译&lt;/a&gt;：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;任务队列是一种在线程或机器间分发任务的机制。&lt;/p&gt;

&lt;p&gt;消息队列的输入是工作的一个单元，称为任务，独立的职程（Worker）进程持续监视队列中是否有需要处理的新任务。&lt;/p&gt;

&lt;p&gt;Celery 用消息通信，通常使用中间人（Broker）在客户端和职程间斡旋。这个过程从客户端向队列添加消息开始，之后中间人把消息派送给职程。&lt;/p&gt;

&lt;p&gt;Celery 系统可包含多个职程和中间人，以此获得高可用性和横向扩展能力。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;适用场景&#34;&gt;适用场景&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;可以在 Request-Response 循环之外执行的操作：发送邮件、推送消息&lt;/li&gt;
&lt;li&gt;耗时的操作：调用第三方 API、视频处理（前端通过 AJAX 展示进度和结果）&lt;/li&gt;
&lt;li&gt;周期性任务：取代 crontab&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;simple-tutorial&#34;&gt;Simple Tutorial&lt;/h2&gt;

&lt;p&gt;主要参考了官网文档：&lt;a href=&#34;http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html&#34;&gt;First Steps with Celery&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;选择-broker&#34;&gt;选择 Broker&lt;/h3&gt;

&lt;p&gt;下图描述了 Celery 的基本架构和工作流程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+------+      +--------+      +----------------+      +--------------+
| User | ---&amp;gt; | Broker | ---&amp;gt; | Workers (1..N) | ---&amp;gt; | Result Store |
+------+      +--------+      +----------------+      +--------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如前文所述，Celery 用消息通信。常用的 Broker 有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt;: RabbitMQ 功能完备、稳定，是一个非常可靠的选择，Celery 官网的评价是 &amp;ldquo;excellent choice for a production environment&amp;rdquo;. 缺点是使用起来毕竟有些复杂。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Redis&lt;/strong&gt;: Redis 同样功能完备，与 RabbitMQ 相比，缺点是可能因为掉电或异常退出导致数据丢失，优点是使用简单。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据库&lt;/strong&gt;: 能方便的集成 SQLAlchemy 和 Django ORM，缺点是性能差，但如果项目本来就用到了数据库，使用起来也非常便利，而且不需要再安装 RabbitMQ 或 Redis.&lt;/li&gt;
&lt;li&gt;其它: 比如 MongoDB, Amazon SQS 还有 IronMQ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们在这里选择使用 Reids.&lt;/p&gt;

&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;

&lt;p&gt;Celery 是一个 Python 的应用，而且已经上传到了 PyPi，所以可以使用 &lt;code&gt;pip&lt;/code&gt; 或 &lt;code&gt;easy_install&lt;/code&gt; 安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pip install celery
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成后会在 PATH （或 virtualenv 的 bin 目录）添加几个命令：celery, celerybeat, celeryd 和 celeryd-multi. 我们这里只使用 celery 命令。&lt;/p&gt;

&lt;h3 id=&#34;创建-application-和-task&#34;&gt;创建 Application 和 Task&lt;/h3&gt;

&lt;p&gt;Celery 的使用方法和 Flask 很像，实例化一个 Celery 对象 &lt;code&gt;app&lt;/code&gt;，然后通过 &lt;code&gt;@app.task&lt;/code&gt; 装饰器注册一个 task. 下面是一个简单的例子 tasks.py：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from celery import Celery

app = Celery(__name__, broker=&#39;redis://localhost:6379/0&#39;)


@app.task
def add(x, y):
    return x + y
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;运行-worker&#34;&gt;运行 worker&lt;/h3&gt;

&lt;p&gt;在 tasks.py 文件所在目录运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ celery worker -A tasks.app -l INFO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令会开启一个在前台运行的 worker，解释这个命令的意义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;worker: 运行 worker 模块&lt;/li&gt;
&lt;li&gt;-A: &amp;ndash;app=APP, 指定使用的 Celery 实例，类似 Gunicorn 的用法&lt;/li&gt;
&lt;li&gt;-l: &amp;ndash;loglevel=INFO, 指定日志级别，可选：DEBUG, INFO, WARNING, ERROR, CRITICAL, FATAL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其它常用的选项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-P: &amp;ndash;pool=prefork, 并发模型，可选：prefork (默认，multiprocessing), eventlet, gevent, threads.&lt;/li&gt;
&lt;li&gt;-c: &amp;ndash;concurrency=10, 并发级别，prefork 模型下就是子进程数量，默认等于 CPU 核心数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完整的命令行选项可以这样查看：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ celery worker --help
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;调用-task&#34;&gt;调用 task&lt;/h3&gt;

&lt;p&gt;有些 Task 可以当作一个普通的函数同步调用，这里讨论异步的方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from tasks import add

add.delay(1, 2)
add.apply_async(args=(1, 2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面两种调用方式等价，&lt;code&gt;delay()&lt;/code&gt; 方法是 &lt;code&gt;apply_async()&lt;/code&gt; 方法的简写。这个调用会把 &lt;code&gt;add&lt;/code&gt; 操作放入到队列里，然后立即返回一个 &lt;code&gt;AsyncResult&lt;/code&gt; 对象。如果关心处理结果，需要给 &lt;code&gt;app&lt;/code&gt; 配置 &lt;code&gt;CELERY_RESULT_BACKEND&lt;/code&gt;，指定一个存储后端保存任务的返回值。&lt;/p&gt;

&lt;h3 id=&#34;配置&#34;&gt;配置&lt;/h3&gt;

&lt;p&gt;前文说过 Celery 与 Flask 的使用很像，配置也是如此。一般情况下，使用 Celery 的默认配置就已经足够，但 Celery 也提供了很灵活的配置。下面是两种配置方式，&lt;a href=&#34;http://docs.celeryproject.org/en/latest/configuration.html&#34;&gt;官方文档&lt;/a&gt; 可以查看所有的配置项及默认值。&lt;/p&gt;

&lt;h4 id=&#34;直接修改配置&#34;&gt;直接修改配置&lt;/h4&gt;

&lt;p&gt;单个：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;app.conf.CELERY_TASK_SERIALIZER = &#39;json&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或批量（支持 &lt;code&gt;dict&lt;/code&gt; 语法）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;app.conf.update(
    CELERY_TASK_SERIALIZER=&#39;json&#39;,
    CELERY_ACCEPT_CONTENT=[&#39;json&#39;],  # Ignore other content
    CELERY_RESULT_SERIALIZER=&#39;json&#39;,
    CELERY_TIMEZONE=&#39;Europe/Oslo&#39;,
    CELERY_ENABLE_UTC=True
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;配置模块&#34;&gt;配置模块&lt;/h4&gt;

&lt;p&gt;类似 Flask，对于比较大的 Celery 项目，配置模块（configuration module）是更好的选择。Celery 对象有个 &lt;code&gt;config_from_object&lt;/code&gt; 方法，读取一个 object (py 文件或 class)来更新配置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;BROKER_URL = &#39;redis://localhost:6379/0&#39;

CELERY_TASK_SERIALIZER = &#39;json&#39;
CELERY_RESULT_SERIALIZER = &#39;json&#39;
CELERY_ACCEPT_CONTENT=[&#39;json&#39;]
CELERY_TIMEZONE = &#39;Europe/Oslo&#39;
CELERY_ENABLE_UTC = True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把上面的内容保存为 &lt;code&gt;celeryconfig.py&lt;/code&gt; 文件，然后：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;app.config_from_object(&#39;celeryconfig&#39;)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Tornado 和 Flask 应用缓存响应结果</title>
      <link>http://deanthompson.github.io/posts/2015/11/cache-response-in-tornado-and-flask</link>
      <pubDate>Thu, 05 Nov 2015 16:52:12 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/11/cache-response-in-tornado-and-flask</guid>
      <description>&lt;p&gt;写 API 的时候，总是会想着如何能提升性能。在一般的 Web 应用里，基本上没什么 CPU 密集型的计算，大部分时间还是消耗在 IO 上面：查询数据库、读写文件、调用第三方 API 等。有些可以异步的操作，比如发送注册邮件、手机验证码等，可以用任务队列来处理。在 Python 的生态里，Celery 就是一个很成熟的解决方案。但是对于很多查询请求，还是需要同步返回的。&lt;/p&gt;

&lt;p&gt;如果真的遇到性能问题，正确的做法是先找出性能瓶颈，然后对症下药。比如优化数据库索引、优化数据库查询语句、优化算法和数据结构，加速查询和计算。但是最快的计算就是不算——或只计算一次，也就是把计算（查询）的结果缓存起来，以后相同条件的计算（查询）直接从缓存里获取，而不需要重新计算（查询）。&lt;/p&gt;

&lt;p&gt;对于耗时的计算，缓存是一种非常有效的优化手段。但缓存也不是万能的，引入缓存的同时，一些其他问题或需要注意的事情也随之而来，比如数据同步、缓存失效、命中率、分布式等。这里不深入探讨这些问题，仅针对下面这种场景，使用缓存来优化 API 性能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GET 查询&lt;/li&gt;
&lt;li&gt;查询很耗时&lt;/li&gt;
&lt;li&gt;相同条件、不同时间（或某段时间内）的查询结果是一致的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比如获取静态页面（也可以通过 Nginx 直接返回），查询某些元数据列表（如国家列表、产品分类等）。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;基本思想&#34;&gt;基本思想&lt;/h2&gt;

&lt;p&gt;“一码胜千言”，直接上代码描述一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def cachable_get(kwargs, on_cache_missing, timeout=300):
    key = make_key(kwargs)	# 计算出一个 key
    value = cache.get(key)	# 查询缓存
    if not value:
        value = on_cache_missing(kwargs)	# 缓存没有命中，计算一次
        cache.set(key, value, timeout)	# 把计算结果写入缓存
    return value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上也就是：先查缓存，如果有缓存没命中，再计算并把结果写入缓存。这种机制类似于中间件，或 Python 里的装饰器。&lt;/p&gt;

&lt;h2 id=&#34;tornado-的实现&#34;&gt;Tornado 的实现&lt;/h2&gt;

&lt;p&gt;Tornado 的 &lt;code&gt;tornado.web.RequestHandler&lt;/code&gt; 有两个方法：&lt;code&gt;prepare&lt;/code&gt; 和 &lt;code&gt;write&lt;/code&gt;。前者会在执行业务代码前执行，后者用于写入响应结果。所以可以在 &lt;code&gt;prepare&lt;/code&gt; 里查询缓存，如果命中就直接返回。没有命中的请求会执行业务代码，然后在 &lt;code&gt;write&lt;/code&gt; 里顺便写入缓存。&lt;/p&gt;

&lt;p&gt;在 Tornado 项目里，通常的做法是从 &lt;code&gt;tornado.web.RequestHandler&lt;/code&gt; 派生一个 &lt;code&gt;BaseHandler&lt;/code&gt; 用于项目内 Handler 的统一基类，方便在 &lt;code&gt;BaseHandler&lt;/code&gt; 里做一些统一的处理。如果在 &lt;code&gt;BaseHandler&lt;/code&gt; 的 &lt;code&gt;prepare&lt;/code&gt; 和 &lt;code&gt;write&lt;/code&gt; 方法实现缓存机制，会影响到所有子类的表现，这样可控性和扩展性就会差一点。推荐的做法是用 Mixin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# -*- coding: utf-8 -*-

try:
    import cPickle as pickle
except ImportError:
    import pickle

import functools
from hashlib import sha1


class CacheMixin(object):
    @property
    def cache(self):
        return self.application.cache

    def _generate_key(self):
        key = pickle.dumps((self.request.path, self.request.arguments))
        return self._with_prefix(sha1(key).hexdigest())

    def _with_prefix(self, key):
        return &#39;%s:%s&#39; % (self.request.path.strip(&#39;/&#39;), key)

    def write_cache(self, chunk):
        super(CacheMixin, self).write(chunk)

    def prepare(self):
        super(CacheMixin, self).prepare()
        key = self._generate_key()
        cached = self.cache.get(key)
        if cached is not None:
            self.write_cache(pickle.loads(cached))
            self.finish()

    def write(self, chunk):
        key = self._generate_key()
        expiration = getattr(self, &#39;expiration&#39;, 300)
        self.cache.set(key, pickle.dumps(chunk), expiration)
        super(CacheMixin, self).write(chunk)


def set_cache_timeout(expiration=300):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(handler, *args, **kwargs):
            handler.expiration = expiration
            return func(handler, *args, **kwargs)

        return wrapper

    return decorator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;CacheMixin&lt;/code&gt; 在定义 Handler 时作为基类传入，覆盖 &lt;code&gt;tornado.web.RequestHandler&lt;/code&gt; 的 &lt;code&gt;prepare&lt;/code&gt; 和 &lt;code&gt;write&lt;/code&gt;，实现缓存机制。&lt;code&gt;self.application.cache&lt;/code&gt; 意味着初始化 &lt;code&gt;tornado.web.Application&lt;/code&gt; 时需要配置一个 &lt;code&gt;cache&lt;/code&gt; 属性，至少需要实现 &lt;code&gt;get&lt;/code&gt; 和支持超时的 &lt;code&gt;set&lt;/code&gt; 方法。常见的是定义一个 &lt;code&gt;CacheBackend&lt;/code&gt; 和一套 &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt; 接口，然后封装不同的缓存实现，比如 Redis，Memcache 等。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;set_cache_timeout&lt;/code&gt; 提供了自定义缓存失效时间的能力，这个装饰器不是必须的，与之等价的方式是在 Handler 的 &lt;code&gt;get&lt;/code&gt; 方法的第一行（或第一个调用 &lt;code&gt;self.write&lt;/code&gt; 语句前）加上：&lt;code&gt;self.expiration = TIMEOUT_IN_SECONDS&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;一个没什么实际意义的使用示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Class HelloHandler(CacheMixin, tornado.web.RequestHandler):
    
    @set_cache_timeout(86400)
    def get(self):
        self.write(&amp;quot;Hello world!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;flask-的实现&#34;&gt;Flask 的实现&lt;/h2&gt;

&lt;p&gt;Flask 里可以用 &lt;code&gt;before_request&lt;/code&gt; 和 &lt;code&gt;after_request&lt;/code&gt; 这两个 hooks 实现 Tornado 里覆盖 &lt;code&gt;prepare&lt;/code&gt; 和 &lt;code&gt;write&lt;/code&gt; 来缓存所有请求，具体实现大同小异。也可以用装饰器来获得更好的灵活性。&lt;/p&gt;

&lt;p&gt;在看具体实现之前，先推荐一个 Flask 的缓存扩展：&lt;a href=&#34;https://pythonhosted.org/Flask-Cache/&#34;&gt;Flask-Cache&lt;/a&gt;. Flask-Cache 基于 &lt;code&gt;werkzeug.contrib.cache&lt;/code&gt;，后者定义了一套缓存接口和实现了多种不同 Backend 的缓存实现；Flask-Cache 在此基础上针对 Flask 做了一些应用性集成以及提供了一些其他的辅助函数。&lt;/p&gt;

&lt;p&gt;下面的例子用的是 Flask-Cache，后端用 Redis，具体的配置见 Flask-Cache 的官方文档。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;try:
    import cPickle as pickle
except ImportError:
    import pickle

import hashlib
import functools

from flask import g


class cached_response(object):
    def __init__(self, timeout=300):
        self.timeout = timeout or 300

    def _generate_key(self):
        data = pickle.dumps((request.path, request.values))
        key = hashlib.sha1(data).hexdigest()
        return self._with_prefix(key)

    @staticmethod
    def _with_prefix(key):
        return &#39;%s:%s&#39; % (request.path, key)

    def __call__(self, view_func):
        @functools.wraps(view_func)
        def decorator(*args, **kwargs):
            key = self._generate_key()
            response = cache.get(key)
            if response:
                return response

            response = view_func(*args, **kwargs)

            # 允许 view 函数通过设置 g.disable_cache = True 来控制不缓存本次请求的结果
            if getattr(g, &#39;disable_cache&#39;, False):
                return response
            
            # 只缓存 200 的请求结果
            if response.status_code == 200:
                cache.set(key, response, self.timeout)
        
            return response

        return decorator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;cached_response&lt;/code&gt; 是一个基于类的装饰器实现，接受 &lt;code&gt;timeout&lt;/code&gt; 参数指定缓存失效时间。用 &lt;code&gt;request.path&lt;/code&gt; 和 &lt;code&gt;request.values&lt;/code&gt; 序列化后的哈希值来标示相同的参数的请求（与 Tornado 版本类似）。上面的实现还展现出了一些可定制性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只缓存 StatusCode 为 200 的请求结果&lt;/li&gt;
&lt;li&gt;允许 endpoint 通过设置 &lt;code&gt;g.disable_cache = True&lt;/code&gt; 来控制不缓存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了这两点，还可以做其他定制，比如通过请求参数传入 &lt;code&gt;nocache=1&lt;/code&gt; 来控制获取实时结果，通过设置 &lt;code&gt;g.cache_timeout = 100&lt;/code&gt; 来覆盖默认的缓存失效时间。&lt;/p&gt;

&lt;p&gt;使用起来也很简单，只需要注册一个装饰器就可以：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@app.route(&#39;/hello/&#39;)
@cached_response(86400)
def hello():
    return &amp;quot;Hello, world!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;上面展示了在 Tornado 和 Flask 项目里缓存请求结果的实现方法，实际使用的时候，还是要结合具体情况做定制和调整。缓存也是一把双刃剑，在享受缓存带来性能提升的同时也要注意可能引入的问题。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用 WTForms 和装饰器做表单校验</title>
      <link>http://deanthompson.github.io/posts/2015/10/using-wtforms-and-decorator-to-validate-form-in-flask</link>
      <pubDate>Sat, 31 Oct 2015 01:46:10 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/10/using-wtforms-and-decorator-to-validate-form-in-flask</guid>
      <description>&lt;p&gt;在一个 Web 应用里，不管是为了业务逻辑的正确性，还是系统安全性，做好参数（querystring, form, json）验证都是非常必要的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/wtforms/wtforms&#34;&gt;WTForms&lt;/a&gt; 是一个非常好用而且强大的表单校验和渲染的库，提供 Form 基类用于定义表单结构（类似 ORM），内置了丰富的字段类型和校验方法，可以很方便的用来做校验。如果应用需要输出 HTML，集成到模板里也很容易。对于 JSON  API 应用，用不到渲染的功能，但是结构化的表单和校验功能依然非常有用。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;以一个注册的应用场景为例，用户输入用户名、邮箱、密码、确认密码，服务程序先检查参数然后处理登录逻辑。这几个字段都是必填的，此外还有一些额外的限制：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用户名：长度在 3-20 之间&lt;/li&gt;
&lt;li&gt;邮箱：合法的邮箱格式，比如 &amp;ldquo;abc&amp;rdquo; 就不合法&lt;/li&gt;
&lt;li&gt;密码：长度在 8-20 之间，必须同时包含大小写字母&lt;/li&gt;
&lt;li&gt;确认密码：必须与密码一致&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果参数不合法，返回 400；登录逻辑略去不表。&lt;/p&gt;

&lt;p&gt;最原始的做法，就是直接在注册的接口里取出每个参数，逐个手动校验。这种做法可能的代码是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@app.route(&#39;/user/signup/&#39;, methods=[&#39;POST&#39;])
def register():
    username = request.form.get(&#39;username&#39;)
    if not username or not (3 &amp;lt;= len(username) &amp;lt;= 20):
        abort(400)
    
    email = request.form.get(&#39;email&#39;)
    if not email or not re.match(EMAIL_REGEX, email):
        abort(400)
    
    password = request.form.get(&#39;password&#39;)
    if not password:
        abort(400)
    if password == password.lower() or password == password.upper():
        abort(400)
    
    confirm_password = request.form.get(&#39;confirm_password&#39;)
    if not confirm_password or confirm_password != password:
        abort(400)
    
    # 处理注册的逻辑
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有可能是我的写法不太对，但是这样检查参数的合法性，实在不够优雅。检查参数的代码行数甚至超出了注册的逻辑，也有些喧宾夺主的感觉。可以把这些代码移出来，使得业务逻辑代码更加清晰一点。下面先用 WTForms 来改造一下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from wtforms import Form
from wtforms.fields import StringField, PasswordField
from wtforms.validators import DataRequired, Email, Length, EqualTo, ValidationError


class SignupForm(Form):
    username = StringField(validators=[DataRequired(), Length(3, 20)])
    email = StringField(validators=[DataRequired(), Email()])
    password = PasswordField(validators=[DataRequired()])
    confirm_password = PasswordField(validators=[DataRequired(), EqualTo(&#39;password&#39;)])
    
    def validate_password(self, field):
        password = field.data
        if password == password.lower() or password == passowrd.upper():
            raise ValidationError(u&#39;必须同时包含大小写字母&#39;)


@app.route(&#39;/user/signup/&#39;, methods=[&#39;POST&#39;])
def register():
    form = SignupForm(formdata=request.form)
    if not form.validate():
        abort(400)
    
    # 处理注册逻辑，参数从 form 对象获取，比如
    username = form.username.data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个版本带来的好处很明显：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;参数更加结构化了，所有字段名和类型一目了然&lt;/li&gt;
&lt;li&gt;有内置的，语义清晰的校验方法，可以组合使用&lt;/li&gt;
&lt;li&gt;还能自定义额外的校验方法，方法签名是 &lt;code&gt;def validate_xx(self, field)&lt;/code&gt;，其中 &lt;code&gt;xx&lt;/code&gt; 是字段名，通过 &lt;code&gt;field.data&lt;/code&gt; 来获取输入的值&lt;/li&gt;
&lt;li&gt;还有没体现出来的，就是丰富的错误提示信息，既有内置的，也可以自定义&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;再看原来的 &lt;code&gt;register&lt;/code&gt; 方法，代码变得更加简洁和清晰，整体的编码质量也得到了提升。&lt;/p&gt;

&lt;p&gt;那么再考虑一下更复杂的场景，在一个返回 JSON 的 API 应用里，有很多 API，有不同的参数提交方式（GET 方法通过 query string，POST 方法可能有 form 和 JSON），一样的校验错误处理方式（abort(400) 或其他）。我们依然可以像上面那样处理，但如果再借助装饰器改进一下，又能少写几行“重复”的代码。&lt;/p&gt;

&lt;p&gt;需要注意的是，WTForms 的 formdata 支持的是类似 Werkzeug/Django/WebOb 中的 &lt;code&gt;MultiDict&lt;/code&gt; 的数据结构。Flask 中的 &lt;code&gt;request.json&lt;/code&gt; 是一个 &lt;code&gt;dict&lt;/code&gt; 类型，所以需要先包装一下。&lt;/p&gt;

&lt;p&gt;继续改造注册的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import functools

from werkzeug.datastructures import MultiDict


def validate_form(form_class):
    def decorator(view_func):
        @functools.wraps(view_func)
        def inner(*args, **kwargs):
            if request.method == &#39;GET&#39;:
                formdata = request.args
            else:
                if request.json:
                    formdata = MultiDict(request.json)
                else:
                    formdata = request.form
                    
            form = form_class(formdata=formdata)
            if not form.validate():
                return jsonify(code=400, message=form.errors), 400

            g.form = form
            return view_func(*args, **kwargs)

        return inner

    return decorator


@app.route(&#39;/user/signup/&#39;, methods=[&#39;POST&#39;])
@validate_form(form_class=SignupForm)
def register():
    form = g.form   # 运行到这里，说明表单是合法的

    # 处理注册逻辑，参数从 form 对象获取，比如
    username = form.username.data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实现了一个叫 &lt;code&gt;validate_form&lt;/code&gt; 的装饰器，指定一个 Form 类，处理统一的参数获取、校验和错误处理，如果一切正确，再把 Form 对象保存到全局变量 &lt;code&gt;g&lt;/code&gt; 里面，这样就可以在 view 函数里取出来用了。现在的 &lt;code&gt;register&lt;/code&gt; 方法变得更加简洁，甚至都看不到检查参数的那些代码，只需要关心具体的和注册相关的逻辑本身就好。&lt;/p&gt;

&lt;p&gt;这个装饰器的可重用性非常好，其他的接口只要定义一个 Form 类，然后调用一下装饰器，再从 &lt;code&gt;g&lt;/code&gt; 获取 Form 对象。不仅省了很多心思和体力劳动，代码也变得更加清晰优雅和 Pythonic.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python 编码规范</title>
      <link>http://deanthompson.github.io/posts/2015/08/simple-python-style-guide</link>
      <pubDate>Mon, 10 Aug 2015 22:36:42 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/08/simple-python-style-guide</guid>
      <description>&lt;p&gt;遵循良好的编码风格，可以有效的提高代码的可读性，降低出错几率和维护难度。在团队开发中，使用（尽量）统一的编码风格，还可以降低沟通成本。&lt;/p&gt;

&lt;p&gt;网上有很多版本的编码规范，基本上都是遵循 PEP8 的规范：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0008/&#34;&gt;PEP 0008 &amp;ndash; Style Guide for Python Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://zh-google-styleguide.readthedocs.org/en/latest/google-python-styleguide/contents/&#34;&gt;Google 的 Python 风格指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.python-guide.org/en/latest/writing/style/&#34;&gt;Python Guide - Code Style&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://flask.pocoo.org/docs/0.10/styleguide/&#34;&gt;Pocoo Styleguide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了在编码时主动遵循规范，还有很多有用的工具：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IntelliJ IDEA 和 PyCharm 的格式化代码功能&lt;/li&gt;
&lt;li&gt;Google 开源的 Python 文件格式化工具：&lt;a href=&#34;https://github.com/google/yapf&#34;&gt;github.com/google/yapf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;pyflakes, pylint 等工具及各种编辑器的插件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文的内容主要摘自互联网上各种版本的规范，因为公司有些小伙伴代码风格不太好，所以整理了一份算是团队的编码规范。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;缩进&#34;&gt;缩进&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;不要使用 tab 缩进&lt;/li&gt;
&lt;li&gt;使用任何编辑器写 Python，请把一个 tab 展开为 4 个空格&lt;/li&gt;
&lt;li&gt;绝对不要混用 tab 和空格，否则容易出现 &lt;code&gt;IndentationError&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;空格&#34;&gt;空格&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在 list, dict, tuple, set, 参数列表的 &lt;code&gt;,&lt;/code&gt; 后面加一个空格&lt;/li&gt;
&lt;li&gt;在 dict 的 &lt;code&gt;:&lt;/code&gt; 后面加一个空格&lt;/li&gt;
&lt;li&gt;在注释符号 &lt;code&gt;#&lt;/code&gt; 后面加一个空格，但是 &lt;code&gt;#!/usr/bin/python&lt;/code&gt; 的 &lt;code&gt;#&lt;/code&gt; 后不能有空格&lt;/li&gt;
&lt;li&gt;操作符两端加一个空格，如 &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;接上一条，在参数列表里的 &lt;code&gt;=&lt;/code&gt; 两端不需要空格&lt;/li&gt;
&lt;li&gt;括号（&lt;code&gt;()&lt;/code&gt;, &lt;code&gt;{}&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;）内的两端不需要空格&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;空行&#34;&gt;空行&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;function 和 class 顶上两个空行&lt;/li&gt;
&lt;li&gt;class 的 method 之间一个空行&lt;/li&gt;
&lt;li&gt;函数内逻辑无关的段落之间空一行，不要过度使用空行&lt;/li&gt;
&lt;li&gt;不要把多个语句写在一行，然后用 &lt;code&gt;;&lt;/code&gt; 隔开&lt;/li&gt;
&lt;li&gt;if/for/while 语句中，即使执行语句只有一句，也要另起一行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;换行&#34;&gt;换行&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;每一行代码控制在 80 字符以内&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;\&lt;/code&gt; 或 &lt;code&gt;()&lt;/code&gt; 控制换行，举例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def foo(first, second, third, fourth, fifth,
        sixth, and_some_other_very_long_param):
    user = User.objects.filter_by(first=first, second=second, third=third) \
        .skip(100).limit(100) \
        .all()

text = (&#39;Long strings can be made up &#39;
        &#39;of several shorter strings.&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;命名&#34;&gt;命名&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;使用有意义的，英文单词或词组，绝对不要使用汉语拼音&lt;/li&gt;
&lt;li&gt;package/module 名中不要出现 &lt;code&gt;-&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;各种类型的命名规范：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Public&lt;/th&gt;
&lt;th&gt;Internal&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Modules&lt;/td&gt;
&lt;td&gt;&lt;code&gt;lower_with_under&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;_lower_with_under&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Packages&lt;/td&gt;
&lt;td&gt;&lt;code&gt;lower_with_under&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Classes&lt;/td&gt;
&lt;td&gt;&lt;code&gt;CapWords&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;_CapWords&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Exceptions&lt;/td&gt;
&lt;td&gt;&lt;code&gt;CapWords&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Functions&lt;/td&gt;
&lt;td&gt;&lt;code&gt;lower_with_under()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;_lower_with_under()&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Global/Class Constants&lt;/td&gt;
&lt;td&gt;&lt;code&gt;CAPS_WITH_UNDER&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;_CAPS_WITH_UNDER&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Global/Class Variables&lt;/td&gt;
&lt;td&gt;&lt;code&gt;lower_with_under&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;_lower_with_under&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Instance Variables&lt;/td&gt;
&lt;td&gt;&lt;code&gt;lower_with_under&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;_lower_with_under&lt;/code&gt; (protected) or &lt;code&gt;__lower_with_under&lt;/code&gt; (private)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Method Names&lt;/td&gt;
&lt;td&gt;&lt;code&gt;lower_with_under()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;_lower_with_under()&lt;/code&gt; (protected) or &lt;code&gt;__lower_with_under()&lt;/code&gt; (private)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Function/Method Parameters&lt;/td&gt;
&lt;td&gt;&lt;code&gt;lower_with_under&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Local Variables&lt;/td&gt;
&lt;td&gt;&lt;code&gt;lower_with_under&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;import&#34;&gt;import&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;所有 import 尽量放在文件开头，在 docstring 下面，其他变量定义的上面&lt;/li&gt;
&lt;li&gt;不要使用 &lt;code&gt;from foo imort *&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;import 需要分组，每组之间一个空行，每个分组内的顺序尽量采用字典序，分组顺序是：

&lt;ol&gt;
&lt;li&gt;标准库&lt;/li&gt;
&lt;li&gt;第三方库&lt;/li&gt;
&lt;li&gt;本项目的 package 和 module&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;不要使用隐式的相对导入（implicit relative imports），可是使用显示的相对导入（explicit relative imports），如 &lt;code&gt;from ..utils import validator&lt;/code&gt;，最好使用全路径导入（absolute imports）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于不同的 package，一个 import 单独一行，同一个 package/module 下的内容可以写一起：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# bad
import sys, os, time

# good
import os
import sys
import time

# ok
from flask import Flask, render_template, jsonify
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为了避免可能出现的命名冲突，可以使用 &lt;code&gt;as&lt;/code&gt; 或导入上一级命名空间&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不要出现循环导入(cyclic import)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;注释&#34;&gt;注释&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;文档字符串 &lt;code&gt;docstring&lt;/code&gt;, 是 package, module, class, method, function 级别的注释，可以通过 &lt;code&gt;__doc__&lt;/code&gt; 成员访问到，注释内容在一对 &lt;code&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/code&gt; 符号之间&lt;/li&gt;
&lt;li&gt;function, method 的文档字符串应当描述其功能、输入参数、返回值，如果有复杂的算法和实现，也需要写清楚&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不要写错误的注释，不要无谓的注释&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# bad 无谓的注释
x = x + 1       # increase x by 1

# bad 错误的注释
x = x - 1       # increase x by 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;优先使用英文写注释，英文不好全部写中文，否则更加看不懂&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;异常&#34;&gt;异常&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;不要轻易使用 &lt;code&gt;try/except&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;except&lt;/code&gt; 后面需要指定捕捉的异常，裸露的 &lt;code&gt;except&lt;/code&gt; 会捕捉所有异常，意味着会隐藏潜在的问题&lt;/li&gt;
&lt;li&gt;可以有多个 &lt;code&gt;except&lt;/code&gt; 语句，捕捉多种异常，分别做异常处理&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;finally&lt;/code&gt; 子句来处理一些收尾操作&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;try/except&lt;/code&gt; 里的内容不要太多，只在可能抛出异常的地方使用，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# bad
try:
    user = User()
    user.name = &amp;quot;leon&amp;quot;
    user.age = int(age) # 可能抛出异常
    user.created_at = datetime.datetime.utcnow()

    db.session.add(user)
    db.session.commit() # 可能抛出异常
except:
    db.session.rollback()

# better
try:
    age = int(age)
except (TypeError, ValueError):
    return # 或别的操作

user = User()
user.name = &amp;quot;leon&amp;quot;
user.age = age
user.created_at = datetime.datetime.utcnow()
db.session.add(user)

try:
    db.session.commit()
except sqlalchemy.exc.SQLAlchemyError: # 或者更具体的异常
    db.session.rollback()
finally:
    db.session.close()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从 &lt;code&gt;Exception&lt;/code&gt; 而不是 &lt;code&gt;BaseException&lt;/code&gt; 继承自定义的异常类&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;class-类&#34;&gt;Class（类）&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;显示的写明父类，如果不是继承自别的类，就继承自 &lt;code&gt;object&lt;/code&gt; 类&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;super&lt;/code&gt; 调用父类的方法&lt;/li&gt;
&lt;li&gt;支持多继承，即同时有多个父类，建议使用 Mixin&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;编码建议&#34;&gt;编码建议&lt;/h2&gt;

&lt;h3 id=&#34;字符串&#34;&gt;字符串&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用字符串的 &lt;code&gt;join&lt;/code&gt; 方法拼接字符串&lt;/li&gt;
&lt;li&gt;使用字符串类型的方法，而不是 &lt;code&gt;string&lt;/code&gt; 模块的方法&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;startswith&lt;/code&gt; 和 &lt;code&gt;endswith&lt;/code&gt; 方法比较前缀和后缀&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;format&lt;/code&gt; 方法格式化字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;比较&#34;&gt;比较&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;空的 &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;str&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;dict&lt;/code&gt; 和 &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0.0&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; 都是 &lt;code&gt;False&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;if some_list&lt;/code&gt; 而不是 &lt;code&gt;if len(some_list)&lt;/code&gt; 判断某个 &lt;code&gt;list&lt;/code&gt; 是否为空，其他类型同理&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;is&lt;/code&gt; 和 &lt;code&gt;is not&lt;/code&gt; 与单例（如 &lt;code&gt;None&lt;/code&gt;）进行比较，而不是用 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;if a is not None&lt;/code&gt; 而不是 &lt;code&gt;if not a is None&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;isinstance&lt;/code&gt; 而不是 &lt;code&gt;type&lt;/code&gt; 判断类型&lt;/li&gt;
&lt;li&gt;不要用 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 与 &lt;code&gt;True&lt;/code&gt; 和 &lt;code&gt;False&lt;/code&gt; 比较（除非有特殊情况，如在 sqlalchemy 中可能用到）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;in&lt;/code&gt; 操作：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;用 &lt;code&gt;key in dict&lt;/code&gt; 而不是 &lt;code&gt;dict.has_key()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# bad
if d.has_key(k):
    do_something()

# good
if k in d:
    do_something()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用 &lt;code&gt;set&lt;/code&gt; 加速 “存在性” 检查，&lt;code&gt;list&lt;/code&gt; 的查找是线性的，复杂度 O(n)，&lt;code&gt;set&lt;/code&gt; 底层是 hash table, 复杂度 O(1)，但用 &lt;code&gt;set&lt;/code&gt; 需要比 &lt;code&gt;list&lt;/code&gt; 更多内存空间&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;其他&#34;&gt;其他&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用列表表达式（&lt;a href=&#34;https://www.python.org/dev/peps/pep-0202/&#34;&gt;list comprehension&lt;/a&gt;），字典表达式(&lt;a href=&#34;https://www.python.org/dev/peps/pep-0274/&#34;&gt;dict comprehension&lt;/a&gt;, Python 2.7+) 和生成器(generator)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dict&lt;/code&gt; 的 &lt;code&gt;get&lt;/code&gt; 方法可以指定默认值，但有些时候应该用 &lt;code&gt;[]&lt;/code&gt; 操作，使得可以抛出 &lt;code&gt;KeyError&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;for item in list&lt;/code&gt; 迭代 &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;for index, item in enumerate(list)&lt;/code&gt; 迭代 &lt;code&gt;list&lt;/code&gt; 并获取下标&lt;/li&gt;
&lt;li&gt;使用内建函数 &lt;code&gt;sorted&lt;/code&gt; 和 &lt;code&gt;list.sort&lt;/code&gt; 进行排序&lt;/li&gt;
&lt;li&gt;适量使用 &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt; 和 &lt;code&gt;lambda&lt;/code&gt;，使用内建的 &lt;code&gt;all&lt;/code&gt;, &lt;code&gt;any&lt;/code&gt; 处理多个条件的判断&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;defaultdict&lt;/code&gt; (Python 2.5+), &lt;code&gt;Counter&lt;/code&gt;(Python 2.7+) 等 “冷门” 但好用的标准库算法和数据结构&lt;/li&gt;
&lt;li&gt;使用装饰器(decorator)&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;with&lt;/code&gt; 语句处理上下文&lt;/li&gt;
&lt;li&gt;有些时候不要对类型做太过严格的限制，利用 Python 的鸭子类型（Duck Type）特性&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;logging&lt;/code&gt; 记录日志，配置好格式和级别&lt;/li&gt;
&lt;li&gt;了解 Python 的 Magic Method：&lt;a href=&#34;http://www.rafekettler.com/magicmethods.html&#34;&gt;A Guide to Python&amp;rsquo;s Magic Methods&lt;/a&gt;, &lt;a href=&#34;http://pycoders-weekly-chinese.readthedocs.org/en/latest/issue6/a-guide-to-pythons-magic-methods.html&#34;&gt;Python 魔术方法指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;阅读优秀的开源代码，如 &lt;a href=&#34;https://github.com/mitsuhiko/flask&#34;&gt;Flask 框架&lt;/a&gt;, &lt;a href=&#34;https://github.com/kennethreitz/requests&#34;&gt;Requests for Humans&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;不要重复造轮子，查看标准库、PyPi、Github、Google 等使用现有的优秀的解决方案&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>用 Fabric 实现自动化部署</title>
      <link>http://deanthompson.github.io/posts/2015/06/deploy-applications-using-fabric</link>
      <pubDate>Fri, 12 Jun 2015 14:00:13 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/06/deploy-applications-using-fabric</guid>
      <description>&lt;p&gt;写完代码测试通过之后，终于松一口气，然后可以愉快的部署上线了。但是问题随之而来：如何部署？或者如何能更自动化的部署？&lt;/p&gt;

&lt;p&gt;部署应用是一系列的操作，就环境而言，分为本地和远程服务器，就操作而言，大概包括提交代码、备份代码、更新代码、安装依赖、迁移数据库、重启服务等流程。其中除了提交代码这一步是在本地完成，其余操作都需要在服务器环境执行。&lt;/p&gt;

&lt;p&gt;上面的流程当中，有一个很重要的，就是如何同步代码（提交、备份、更新）。就我的经验，了解或用过这些方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rsync: rsync 是一个文件同步的工具，如果配置好使用起来体验也不错。但是有很多缺点：

&lt;ul&gt;
&lt;li&gt;配置复杂，命令行参数多&lt;/li&gt;
&lt;li&gt;需要在服务器上运行 rsyncd，默认监听 873 端口（可能会有防火墙）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;scp: scp 底层用的是 SSH 协议，所以只要服务器上运行了 sshd 就可以双向 copy 文件。对于文件传输来说，scp 比 rsync 体验差的地方有：

&lt;ul&gt;
&lt;li&gt;不能增量更新，每次都是全部传输&lt;/li&gt;
&lt;li&gt;不能配置忽略文件（.git 怎么办？）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;git: 就个人而言，git 是最方便的部署方式了，有版本控制，可以增量更新，可以配置忽略文件，使用简单。实际上只要有可能，都推荐用 git 来发布代码。但问题在于，很多公司的 git 服务器都是在内网的，所以在服务器上无法访问。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;很幸运的是，我们有一个公网可以访问的 git 服务器，所以可以用 git 来发布代码。发布完代码后就是后续的一系列操作了，最原始的方式，是登录到服务器，然后一步一步敲命令执行下来。但是如果要频繁部署的话（快速迭代时肯定要经常更新代码），这就变成了繁复的体力劳动，而且容易出错（漏了流程，看花眼了）。于是就想到了脚本，把这些操作写成 shell 脚本，然后执行脚本就好了。这是一个很大的进步，然而仍然存在一个问题：从本地环境到远程环境，需要登录，导致了流程上的阻断。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.fabfile.org/&#34;&gt;Fabric&lt;/a&gt; 是 Python 编写的一个可以实现自动化部署和系统维护的命令行工具，只需要写一些简单的 Python 代码就能轻松解决上面提到的所有问题。Fabric 底层用的是 SSH 协议，提供了一系列语义清晰的 API 来组合实现部署任务。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;Fabric 是 Python 编写的工具，所以可以用 pip 来安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo pip install fabric
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是 Ubuntu 系统，还可以用 apt-get 安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install fabric
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成后，会生成一个 &lt;code&gt;fab&lt;/code&gt; 命令，这个命令会读取当前路径在的 fabfile.py 并执行相应的任务。&lt;/p&gt;

&lt;h2 id=&#34;hello-world&#34;&gt;Hello, world!&lt;/h2&gt;

&lt;p&gt;先来看一个简单的例子，用 &lt;code&gt;fab&lt;/code&gt; 命令执行一个输出 &lt;code&gt;Hello, world!&lt;/code&gt; 的任务。&lt;/p&gt;

&lt;p&gt;新建一个文件，fabfile.py:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def hello():
	print &#39;Hello, world!&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 fabfile.py 所在的路径执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;fab hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到有这样的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hello, world!

Done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以给任务传递参数，修改 fabfile.py:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def hello(name=&amp;quot;world&amp;quot;):
    print &amp;quot;Hello, %s!&amp;quot; % name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用 &lt;code&gt;fab&lt;/code&gt; 命令执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ fab hello

Hello, world!

Done.

$ fab hello:name=leon

Hello, leon!

Done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子除了展示 fab 运行任务和传递参数之外，没有什么实际意义，接下来用一个接近真实的场景来展示如何用 Fabric 部署。&lt;/p&gt;

&lt;h2 id=&#34;部署应用&#34;&gt;部署应用&lt;/h2&gt;

&lt;p&gt;假设这样一个场景，有个 Python 项目取名 usercenter，用 git 做版本控制，用 supervisor 做进程管理。一次完整的部署过程可能包括这些流程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 本地
$ cd /path/to/userenter
$ git pull
$ git add -A
$ git commit -m &amp;quot;commit message&amp;quot;
$ git push

# 远程
$ cd /path/to/usercenter
$ workon usercenter		# virtualenv
$ git pull				# 更新代码
$ pip install -r requirements.txt		# 安装依赖
$ python manage.py db migrate			# 数据库迁移
$ supervisorctl restart usercenter	# 重启服务
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们现在用 Fabric 来一次性完成上面所有操作（假设第一次部署是手工执行的，现在只处理更新／升级的任务）。在 usercenter 项目的根目录下新建 fabfile.py 文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# -*- coding: utf-8 -*-

from fabric.api import env, local, cd, run
from fabric.context_managers import prefix


def production():
	&amp;quot;&amp;quot;&amp;quot; 设置 production 环境 &amp;quot;&amp;quot;&amp;quot;
	env.hosts = [&amp;quot;production@123.123.123.123:22&amp;quot;]
	env.key_filename = &amp;quot;/path/to/key_file&amp;quot;
	# env.password = &amp;quot;123456&amp;quot;	# password 和 keyfile 两者只需要一个就可以


def staging():
	&amp;quot;&amp;quot;&amp;quot; 设置 staging 环境 &amp;quot;&amp;quot;&amp;quot;
	env.hosts = [&amp;quot;staging@111.111.111.111:22&amp;quot;]
	env.password = &amp;quot;123456&amp;quot;		# 如果不写密码，会在 fab 执行时有交互提示输入密码


def prepare():
    &amp;quot;&amp;quot;&amp;quot; 本地提交代码，准备部署 &amp;quot;&amp;quot;&amp;quot;
	local(&amp;quot;git pull&amp;quot;)	# local 用于执行本地命令
	local(&amp;quot;pip freeze &amp;gt; requirements.txt&amp;quot;)
	local(&amp;quot;git add -p &amp;amp;&amp;amp; git commit&amp;quot;)	＃ 会有交互输入 commit message
	local(&amp;quot;git push&amp;quot;)


def update():
	&amp;quot;&amp;quot;&amp;quot; 服务器上更新代码、依赖和迁移 &amp;quot;&amp;quot;&amp;quot;
	# cd 用于在服务器上执行 cd 命令，本地环境对应的 api 是 lcd (local cd)
	with cd(&amp;quot;/path/to/usercenter&amp;quot;), prefix(&amp;quot;workon usercenter&amp;quot;):
		run(&amp;quot;git pull&amp;quot;)			# run 用于服务器上执行命令
		run(&amp;quot;pip install -r requirements.txt&amp;quot;)
		run(&amp;quot;python manage.py db migrate&amp;quot;)
		run(&amp;quot;supervisorctl restart usercenter&amp;quot;)

def deploy():
	prepare()
	update()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, 完成。具体的意义代码里面都有注释，不赘述。需要注意的是 &lt;code&gt;production&lt;/code&gt; 和 &lt;code&gt;staging&lt;/code&gt; 分别设置了两种不同的环境。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 部署到 production 环境
$ fab production deploy

# 部署到 staging 环境
$ fab staging deploy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行过程中可能会有些交互，按提示输入相应信息，然后等着执行完成就好了。如果一切顺利（应该是这样），就完成了 usercenter 的部署了，整个过程只需要敲一行命令，是不是非常方便？&lt;/p&gt;

&lt;h2 id=&#34;more&#34;&gt;More&amp;hellip;&lt;/h2&gt;

&lt;p&gt;上面的例子基本上是可以在实际环境中使用的，不过还是有很多内容没有覆盖到，比如错误处理，多服务器部署，并行等。Fabric 默认是串行执行的，如果有多个远程服务器，是一个一个顺序执行。执行过程中如果发生异常，任务会直接中断，所以可能需要有错误处理。&lt;/p&gt;

&lt;p&gt;上面这些（还有很多）内容都可以在 Fabric 的文档上（非常详细）找到相应的内容，下面给出一些参考链接，结合文档和自己的实际情况，多用几次就能定制出能满足自己需求的 Fabric 任务：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fabric 官网: &lt;a href=&#34;http://www.fabfile.org/&#34;&gt;http://www.fabfile.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Overview and Tutorial: &lt;a href=&#34;Overview and Tutorial&#34;&gt;http://docs.fabfile.org/en/1.10/tutorial.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Fabric 文档: &lt;a href=&#34;http://docs.fabfile.org/en/1.10/index.html&#34;&gt;http://docs.fabfile.org/en/1.10/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python fabric实现远程操作和部署（By wklken）: &lt;a href=&#34;http://wklken.me/posts/2013/03/25/python-tool-fabric.html&#34;&gt;http://wklken.me/posts/2013/03/25/python-tool-fabric.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>使用 supervisor 管理进程</title>
      <link>http://deanthompson.github.io/posts/2015/06/using-supervisor</link>
      <pubDate>Tue, 09 Jun 2015 17:30:20 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2015/06/using-supervisor</guid>
      <description>&lt;p&gt;Supervisor (&lt;a href=&#34;http://supervisord.org&#34;&gt;http://supervisord.org&lt;/a&gt;) 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;Supervisor 可以运行在 Linux、Mac OS X 上。如前所述，supervisor 是 Python 编写的，所以安装起来也很方便，可以直接用 pip :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo pip install supervisor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是 Ubuntu 系统，还可以使用 apt-get 安装。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;supervisord-配置&#34;&gt;supervisord 配置&lt;/h2&gt;

&lt;p&gt;Supervisor 相当强大，提供了很丰富的功能，不过我们可能只需要用到其中一小部分。安装完成之后，可以编写配置文件，来满足自己的需求。为了方便，我们把配置分成两部分：supervisord（supervisor 是一个 C/S 模型的程序，这是 server 端，对应的有 client 端：supervisorctl）和应用程序（即我们要管理的程序）。&lt;/p&gt;

&lt;p&gt;首先来看 supervisord 的配置文件。安装完 supervisor 之后，可以运行&lt;code&gt;echo_supervisord_conf&lt;/code&gt; 命令输出默认的配置项，也可以重定向到一个配置文件里：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo_supervisord_conf &amp;gt; /etc/supervisord.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;去除里面大部分注释和“不相关”的部分，我们可以先看这些配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[unix_http_server]
file=/tmp/supervisor.sock   ; UNIX socket 文件，supervisorctl 会使用
;chmod=0700                 ; socket 文件的 mode，默认是 0700
;chown=nobody:nogroup       ; socket 文件的 owner，格式： uid:gid

;[inet_http_server]         ; HTTP 服务器，提供 web 管理界面
;port=127.0.0.1:9001        ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性
;username=user              ; 登录管理后台的用户名
;password=123               ; 登录管理后台的密码

[supervisord]
logfile=/tmp/supervisord.log ; 日志文件，默认是 $CWD/supervisord.log
logfile_maxbytes=50MB        ; 日志文件大小，超出会 rotate，默认 50MB
logfile_backups=10           ; 日志文件保留备份数量默认 10
loglevel=info                ; 日志级别，默认 info，其它: debug,warn,trace
pidfile=/tmp/supervisord.pid ; pid 文件
nodaemon=false               ; 是否在前台启动，默认是 false，即以 daemon 的方式启动
minfds=1024                  ; 可以打开的文件描述符的最小值，默认 1024
minprocs=200                 ; 可以打开的进程数的最小值，默认 200

; the below section must remain in the config file for RPC
; (supervisorctl/web interface) to work, additional interfaces may be
; added by defining them in separate rpcinterface: sections
[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface

[supervisorctl]
serverurl=unix:///tmp/supervisor.sock ; 通过 UNIX socket 连接 supervisord，路径与 unix_http_server 部分的 file 一致
;serverurl=http://127.0.0.1:9001 ; 通过 HTTP 的方式连接 supervisord

; 包含其他的配置文件
[include]
files = relative/directory/*.ini    ; 可以是 *.conf 或 *.ini
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们把上面这部分配置保存到 /etc/supervisord.conf（或其他任意有权限访问的文件），然后启动 supervisord（通过 -c 选项指定配置文件路径，如果不指定会按照这个顺序查找配置文件：$CWD/supervisord.conf, $CWD/etc/supervisord.conf, /etc/supervisord.conf）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;supervisord -c /etc/supervisord.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看 supervisord 是否在运行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ps aux | grep supervisord
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;program-配置&#34;&gt;program 配置&lt;/h2&gt;

&lt;p&gt;上面我们已经把 supervisrod 运行起来了，现在可以添加我们要管理的进程的配置文件。可以把所有配置项都写到 supervisord.conf 文件里，但并不推荐这样做，而是通过 include 的方式把不同的程序（组）写到不同的配置文件里。&lt;/p&gt;

&lt;p&gt;为了举例，我们新建一个目录 /etc/supervisor/ 用于存放这些配置文件，相应的，把 /etc/supervisord.conf 里 include 部分的的配置修改一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[include]
files = /etc/supervisor/*.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设有个用 Python 和 Flask 框架编写的用户中心系统，取名 usercenter，用 gunicorn (&lt;a href=&#34;http://gunicorn.org/&#34;&gt;http://gunicorn.org/&lt;/a&gt;) 做 web 服务器。项目代码位于 &lt;code&gt;/home/leon/projects/usercenter&lt;/code&gt;，gunicorn 配置文件为 &lt;code&gt;gunicorn.py&lt;/code&gt;，WSGI callable 是 wsgi.py 里的 app 属性。所以直接在命令行启动的方式可能是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd /home/leon/projects/usercenter
gunicorn -c gunicorn.py wsgi:app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在编写一份配置文件来管理这个进程（&lt;strong&gt;需要注意：用 supervisord 管理时，gunicorn 的 daemon 选项需要设置为 False&lt;/strong&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[program:usercenter]
directory = /home/leon/projects/usercenter ; 程序的启动目录
command = gunicorn -c gunicorn.py wsgi:app  ; 启动命令，可以看出与手动在命令行启动的命令是一样的
autostart = true     ; 在 supervisord 启动的时候也自动启动
startsecs = 5        ; 启动 5 秒后没有异常退出，就当作已经正常启动了
autorestart = true   ; 程序异常退出后自动重启
startretries = 3     ; 启动失败自动重试次数，默认是 3
user = leon          ; 用哪个用户启动
redirect_stderr = true  ; 把 stderr 重定向到 stdout，默认 false
stdout_logfile_maxbytes = 20MB  ; stdout 日志文件大小，默认 50MB
stdout_logfile_backups = 20     ; stdout 日志文件备份数
; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）
stdout_logfile = /data/logs/usercenter_stdout.log

; 可以通过 environment 来添加需要的环境变量，一种常见的用法是修改 PYTHONPATH
; environment=PYTHONPATH=$PYTHONPATH:/path/to/somewhere
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一份配置文件至少需要一个 &lt;code&gt;[program:x]&lt;/code&gt; 部分的配置，来告诉 supervisord 需要管理那个进程。&lt;code&gt;[program:x]&lt;/code&gt; 语法中的 &lt;code&gt;x&lt;/code&gt; 表示 program name，会在客户端（supervisorctl 或 web 界面）显示，在 supervisorctl 中通过这个值来对程序进行 start、restart、stop 等操作。&lt;/p&gt;

&lt;h2 id=&#34;使用-supervisorctl&#34;&gt;使用 supervisorctl&lt;/h2&gt;

&lt;p&gt;Supervisorctl 是 supervisord 的一个命令行客户端工具，启动时需要指定与 supervisord 使用同一份配置文件，否则与 supervisord 一样按照顺序查找配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;supervisorctl -c /etc/supervisord.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个命令会进入 supervisorctl 的 shell 界面，然后可以执行不同的命令了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; status    # 查看程序状态
&amp;gt; stop usercenter   # 关闭 usercenter 程序
&amp;gt; start usercenter  # 启动 usercenter 程序
&amp;gt; restart usercenter    # 重启 usercenter 程序
&amp;gt; reread    ＃ 读取有更新（增加）的配置文件，不会启动新添加的程序
&amp;gt; update    ＃ 重启配置文件修改过的程序
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这些命令都有相应的输出，除了进入 supervisorctl 的 shell 界面，也可以直接在 bash 终端运行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ supervisorctl status
$ supervisorctl stop usercenter
$ supervisorctl start usercenter
$ supervisorctl restart usercenter
$ supervisorctl reread
$ supervisorctl update 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;其它&#34;&gt;其它&lt;/h2&gt;

&lt;p&gt;除了 supervisorctl 之外，还可以配置 supervisrod 启动 web 管理界面，这个 web 后台使用 Basic Auth 的方式进行身份认证。&lt;/p&gt;

&lt;p&gt;除了单个进程的控制，还可以配置 group，进行分组管理。&lt;/p&gt;

&lt;p&gt;经常查看日志文件，包括 supervisord 的日志和各个 pragram 的日志文件，程序 crash 或抛出异常的信息一半会输出到 stderr，可以查看相应的日志文件来查找问题。&lt;/p&gt;

&lt;p&gt;Supervisor 有很丰富的功能，还有其他很多项配置，可以在官方文档获取更多信息：&lt;a href=&#34;http://supervisord.org/index.html&#34;&gt;http://supervisord.org/index.html&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Flask 路由做范围限制</title>
      <link>http://deanthompson.github.io/posts/2014/02/range-validation-in-flask-routing</link>
      <pubDate>Wed, 26 Feb 2014 23:15:42 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2014/02/range-validation-in-flask-routing</guid>
      <description>&lt;p&gt;这其实是我之前在 StackOverflow 上回答过的一道题，令我感到意外的是，这个问题只有我一个人回答，而且我也获得了 8 个赞同。小小的成就感。&lt;/p&gt;

&lt;h1 id=&#34;1-what&#34;&gt;1. What&lt;/h1&gt;

&lt;p&gt;原题在这里：&lt;a href=&#34;http://stackoverflow.com/questions/19076226/how-to-validate-integer-range-in-flask-routing-werkzeug/&#34;&gt;How to validate integer range in Flask routing (Werkzeug)?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;简单翻译一下，大致如下：&lt;/p&gt;

&lt;p&gt;Flask 应用里面有一个这样的路由&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from foo import get_foo

@app.route(&amp;quot;/foo/&amp;lt;int:id&amp;gt;&amp;quot;)
def foo_id(id):
    return render_template(&#39;foo.html&#39;, foo = get_foo(id))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;id&lt;/code&gt; 的取值是 &lt;code&gt;1～300&lt;/code&gt;，如何在路由层级做这个验证？也就是一个类似于这样的东西 &lt;code&gt;@app.route(&amp;quot;/foo/&amp;lt;int:id(1-300)&amp;quot;)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;2-how&#34;&gt;2. How&lt;/h1&gt;

&lt;p&gt;这个问题其实对我很有启发，虽然平时都在用 Flask 做项目，但是没有考虑过在 router 层面做验证。虽然在应用场景中可能用处不大，但至少可能存在这个选项，在一些特殊的场景下可以很方便的处理非法请求。&lt;/p&gt;

&lt;p&gt;虽然没用过参数验证，但是对 Flask 的路由规则还是比较熟悉的，也用过转换器（converter）。整体而言，Flask 基于一个 &lt;a href=&#34;http://werkzeug.pocoo.org/&#34;&gt;WSGI Utility Library: Werkzeug&lt;/a&gt; 和 &lt;a href=&#34;http://jinja.pocoo.org&#34;&gt;模板引擎 Jinja2&lt;/a&gt;，其中路由规则就是基于 Werkzeug 的。Werkzeug 提供了几种 builtin converters 用于将 URL 里的参数转换成对应 python 的数据类型，而事实上这就已经进行了一次类型检查。&lt;/p&gt;

&lt;h2 id=&#34;2-1-builtin-converters&#34;&gt;2.1 Builtin Converters&lt;/h2&gt;

&lt;p&gt;如前所述，Werkzeug 提供了几种 &lt;a href=&#34;http://werkzeug.pocoo.org/docs/routing/#builtin-converters&#34;&gt;builtin converters&lt;/a&gt;，分别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;class werkzeug.routing.UnicodeConverter(map, minlength=1, maxlength=None, length=None)&lt;/code&gt;：字符串转换器，接受除了路径类型（含有 &lt;code&gt;/&lt;/code&gt;）的所有字符串，这也是默认的转换器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class werkzeug.routing.PathConverter(map)&lt;/code&gt;：路径类型转换器，一般用得不多吧。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class werkzeug.routing.IntegerConverter(map, fixed_digits=0, min=None, max=None)&lt;/code&gt;：整型转换器，接受并转换成 &lt;code&gt;int&lt;/code&gt; 类型，不支持负数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class werkzeug.routing.FloatConverter(map, min=None, max=None)&lt;/code&gt;：浮点型转换器，接受并转换成 &lt;code&gt;float&lt;/code&gt; 类型，不支持负数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class werkzeug.routing.AnyConverter(map, *items)&lt;/code&gt;：匹配任意一个给定的选项，这些选项可以是 python 标识符或字符串。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从文档里可以看到，有些转换器是支持一些简单的范围验证。如 UnicodeConverter 可以检查字符串的最小长度（&lt;code&gt;minlength&lt;/code&gt;）、最大长度（&lt;code&gt;maxlength&lt;/code&gt;）或者指定长度（&lt;code&gt;length&lt;/code&gt;）。IntergerConverter 和 FloatConverter 都可以指定最小值（&lt;code&gt;min&lt;/code&gt;）和最大值（&lt;code&gt;max&lt;/code&gt;）。所以看完这些，就可以解决最开始的问题了。&lt;/p&gt;

&lt;h2 id=&#34;2-2-solution&#34;&gt;2.2 Solution&lt;/h2&gt;

&lt;p&gt;回到原题，是需要对 &lt;code&gt;id&lt;/code&gt; 做范围限制（&lt;code&gt;1～300&lt;/code&gt;），因此路由就可以这样写了（&lt;a href=&#34;http://stackoverflow.com/a/19076418/1461780&#34;&gt;我的回答&lt;/a&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from foo import get_foo

@app.route(&amp;quot;/foo/&amp;lt;int(min=1, max=300):id&amp;gt;&amp;quot;)
def foo_id(id):
    return render_template(&#39;foo.html&#39;, foo = get_foo(id))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个路由就限定了 &lt;code&gt;id&lt;/code&gt; 的范围，对于超出范围的请求，如 &lt;code&gt;/foo/1024/&lt;/code&gt;，就会找不到对应的路由，因此会返回 &lt;code&gt;404&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&#34;3-end&#34;&gt;3. End&lt;/h1&gt;

&lt;p&gt;题外话，其实题主开始的时候是在函数内部做了参数检测（我也基本这么干），而且最后也没有采用在路由做限制的方法。原因上面已经说了，就是对于超出范围的请求，会直接返回 &lt;code&gt;404&lt;/code&gt;，某些情况下这是可以接受的，但另外的情况下最好能让用户知道他的请求到底哪里出了问题。用哪种方案取决于具体的应用场景，但对我来说至少多了一个选项，也对 converters 相关的内容更了解了一些。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【翻译】理解 Python 装饰器</title>
      <link>http://deanthompson.github.io/posts/2013/03/understand-python-decorators</link>
      <pubDate>Wed, 13 Mar 2013 00:26:58 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2013/03/understand-python-decorators</guid>
      <description>&lt;h2 id=&#34;note&#34;&gt;Note&lt;/h2&gt;

&lt;p&gt;前段时间在 stack overflow 上看到一个关于 python decorator（装饰器）的问题，有一个人很耐心的写了一篇很长的教程。我也很耐心的看完了，获益匪浅。现在尝试翻译过来，尽量追求准确和尊重原文。不明白的地方，或翻译不好的地方，请参照原文，地址：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/739654/understanding-python-decorators#answer-1594484&#34;&gt;Understanding Python decorators&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;1-python的函数是对象-python-s-functions-are-objects&#34;&gt;1. python的函数是对象（Python&amp;rsquo;s functions are objects）&lt;/h1&gt;

&lt;p&gt;要理解装饰器，就必须先知道，在python里，函数也是对象（functions are objects）。明白这一点非常重要，让我们通过一个例子来看看为什么。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def shout(word=&amp;quot;yes&amp;quot;):
    return word.capitalize()+&amp;quot;!&amp;quot;
 
print shout()
# outputs : &#39;Yes!&#39;
 
# 作为一个对象，你可以像其他对象一样把函数赋值给其他变量
 
scream = shout
 
# 注意我们没有用括号：我们不是在调用函数，
# 而是把函数&#39;shout&#39;的值绑定到&#39;scream&#39;这个变量上
# 这也意味着你可以通过&#39;scream&#39;这个变量来调用&#39;shout&#39;函数
 
print scream()
# outputs : &#39;Yes!&#39;
 
# 不仅如此，这也还意味着你可以把原来的名字&#39;shout&#39;删掉，
# 而这个函数仍然可以通过&#39;scream&#39;来访问
del shout
try:
    print shout()
except NameError, e:
    print e
    #outputs: &amp;quot;name &#39;shout&#39; is not defined&amp;quot;
 
print scream()
outputs: &#39;Yes!&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK，先记住这点，我们马上会用到。python 函数的另一个有趣的特性是，它们可以在另一个函数体内定义。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def talk():
 
    # 你可以在 &#39;talk&#39; 里动态的(on the fly)定义一个函数...
    def whisper(word=&amp;quot;yes&amp;quot;):
        return word.lower()+&amp;quot;...&amp;quot;
 
    # ... 然后马上调用它！
 
    print whisper()
 
# 每当调用&#39;talk&#39;，都会定义一次&#39;whisper&#39;，然后&#39;whisper&#39;在&#39;talk&#39;里被调用
talk()
# outputs:
# &amp;quot;yes...&amp;quot;
 
# 但是&amp;quot;whisper&amp;quot; 在 &amp;quot;talk&amp;quot;外并不存在:
 
try:
    print whisper()
except NameError, e:
    print e
    #outputs : &amp;quot;name &#39;whisper&#39; is not defined&amp;quot;*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;2-函数引用-functions-references&#34;&gt;2. 函数引用（Functions references）&lt;/h1&gt;

&lt;p&gt;OK，还在吧？！现在到了有趣的部分，你刚刚已经知道了，python的函数也是对象，因此：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以被赋值给变量&lt;/li&gt;
&lt;li&gt;可以在另一个函数体内定义&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么，这样就意味着一个函数可以返回另一个函数 :-)，来看个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def getTalk(type=&amp;quot;shout&amp;quot;):
 
    # 我们先动态定义一些函数
    def shout(word=&amp;quot;yes&amp;quot;):
        return word.capitalize()+&amp;quot;!&amp;quot;
 
    def whisper(word=&amp;quot;yes&amp;quot;) :
        return word.lower()+&amp;quot;...&amp;quot;;
 
    # 然后返回其中一个
    if type == &amp;quot;shout&amp;quot;:
        # 注意：我们是在返回函数对象，而不是调用函数，
        # 所以不要用到括号 &amp;quot;()&amp;quot;
        return shout 
    else:
        return whisper
 
# 那你改如何使用这个怪兽呢？(How do you use this strange beast?)
 
# 先把函数赋值给一个变量
talk = getTalk()     
 
# 你可以发现 &amp;quot;talk&amp;quot; 其实是一个函数对象:
print talk
#outputs : &amp;lt;function shout at 0xb7ea817c&amp;gt;
 
# 这个对象就是 getTalk 函数返回的:
print talk()
#outputs : Yes!
 
# 你甚至还可以直接这样使用(if you feel wild):
print getTalk(&amp;quot;whisper&amp;quot;)()
#outputs : yes...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是等等，还有呢。既然可以返回一个函数，那么也就可以像参数一样传递：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def doSomethingBefore(func):
    print &amp;quot;I do something before then I call the function you gave me&amp;quot;
    print func()
 
doSomethingBefore(scream)
#outputs:
#I do something before then I call the function you gave me
#Yes!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那好，你现在已经具备了理解装饰器的所有基础知识了。你看，装饰器也就是一种包装材料，&lt;strong&gt;它们可以让你在执行被装饰的函数之前或之后执行其他代码，而且不需要修改函数本身&lt;/strong&gt;。（原句比较长：You see, decorators are wrappers which means that they let you execute code before and after the function they decorate without the need to modify the function itself.）&lt;/p&gt;

&lt;h1 id=&#34;3-手工制作装饰器-handcrafted-decorators&#34;&gt;3. 手工制作装饰器（Handcrafted decorators）&lt;/h1&gt;

&lt;p&gt;你可以像这样来定制：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 一个装饰器是一个需要另一个函数作为参数的函数
def my_shiny_new_decorator(a_function_to_decorate):
 
    # 在装饰器内部动态定义一个函数：wrapper(原意：包装纸).
    # 这个函数将被包装在原始函数的四周
    # 因此就可以在原始函数之前和之后执行一些代码.
    def the_wrapper_around_the_original_function():
 
        # 把想要在调用原始函数前运行的代码放这里
        print &amp;quot;Before the function runs&amp;quot;
 
        # 调用原始函数（需要带括号）
        a_function_to_decorate()
 
        # 把想要在调用原始函数后运行的代码放这里
        print &amp;quot;After the function runs&amp;quot;
 
    # 直到现在，&amp;quot;a_function_to_decorate&amp;quot;还没有执行过 (HAS NEVER BEEN EXECUTED).
    # 我们把刚刚创建的 wrapper 函数返回.
    # wrapper 函数包含了这个函数，还有一些需要提前后之后执行的代码，
    # 可以直接使用了（It&#39;s ready to use!）
    return the_wrapper_around_the_original_function
 
# Now imagine you create a function you don&#39;t want to ever touch again.
def a_stand_alone_function():
    print &amp;quot;I am a stand alone function, don&#39;t you dare modify me&amp;quot;
 
a_stand_alone_function()
#outputs: I am a stand alone function, don&#39;t you dare modify me
 
# 现在，你可以装饰一下来修改它的行为.
# 只要简单的把它传递给装饰器，后者能用任何你想要的代码动态的包装
# 而且返回一个可以直接使用的新函数:
 
a_stand_alone_function_decorated = my_shiny_new_decorator(a_stand_alone_function)
a_stand_alone_function_decorated()
#outputs:
#Before the function runs
#I am a stand alone function, don&#39;t you dare modify me
#After the function runs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你大概希望，每次调用 &lt;code&gt;a_stand_alone_function&lt;/code&gt; 时，实际调用的是 &lt;code&gt;a_stand_alone_function_decorated&lt;/code&gt; 。这很容易，只要把 &lt;code&gt;my_shiny_new_decorator&lt;/code&gt; 返回的函数覆盖 &lt;code&gt;a_stand_alone_function&lt;/code&gt; 就可以了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a_stand_alone_function = my_shiny_new_decorator(a_stand_alone_function)
a_stand_alone_function()
#outputs:
#Before the function runs
#I am a stand alone function, don&#39;t you dare modify me
#After the function runs
 
# And guess what? That&#39;s EXACTLY what decorators do!
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;4-揭秘装饰器-decorators-demystified&#34;&gt;4. 揭秘装饰器(Decorators demystified)&lt;/h1&gt;

&lt;p&gt;我们用装饰器的语法来重写一下前面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@my_shiny_new_decorator
def another_stand_alone_function():
    print &amp;quot;Leave me alone&amp;quot;
 
another_stand_alone_function() 
#outputs: 
#Before the function runs
#Leave me alone
#After the function runs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是的，这就完了，就这么简单。&lt;code&gt;@decorator&lt;/code&gt; 只是下面这条语句的简写(shortcut)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;装饰器其实就是装饰器模式的一个python化的变体（pythonic variant）。为了方便开发，python已经内置了好几种经典的设计模式，比如迭代器（iterators）。
当然，你还可以堆积使用装饰器(you can cumulate decorators)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def bread(func):
    def wrapper():
        print &amp;quot;&amp;lt;/&#39;&#39;&#39;&#39;&#39;&#39;\&amp;gt;&amp;quot;
        func()
        print &amp;quot;&amp;lt;\______/&amp;gt;&amp;quot;
    return wrapper
 
def ingredients(func):
    def wrapper():
        print &amp;quot;#tomatoes#&amp;quot;
        func()
        print &amp;quot;~salad~&amp;quot;
    return wrapper
 
def sandwich(food=&amp;quot;--ham--&amp;quot;):
    print food
 
sandwich()
#outputs: --ham--
sandwich = bread(ingredients(sandwich))
sandwich()
#outputs:
#&amp;lt;/&#39;&#39;&#39;&#39;&#39;&#39;\&amp;gt;
# #tomatoes#
# --ham--
# ~salad~
#&amp;lt;\______/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用python的装饰器语法表示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@bread
@ingredients
def sandwich(food=&amp;quot;--ham--&amp;quot;):
    print food
 
sandwich()
#outputs:
#&amp;lt;/&#39;&#39;&#39;&#39;&#39;&#39;\&amp;gt;
# #tomatoes#
# --ham--
# ~salad~
#&amp;lt;\______/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;装饰器放置的顺序 &lt;strong&gt;很重要&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@ingredients
@bread
def strange_sandwich(food=&amp;quot;--ham--&amp;quot;):
    print food
 
strange_sandwich()
#outputs:
##tomatoes#
#&amp;lt;/&#39;&#39;&#39;&#39;&#39;&#39;\&amp;gt;
# --ham--
#&amp;lt;\______/&amp;gt;
# ~salad~
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;5-回答题主问题-略&#34;&gt;5. 回答题主问题，略&lt;/h1&gt;

&lt;h1 id=&#34;6-给装饰器函数传参-passing-arguments-to-the-decorated-function&#34;&gt;6. 给装饰器函数传参（Passing arguments to the decorated function）&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 这不是什么黑色魔法(black magic)，你只是必须让wrapper传递参数:
 
def a_decorator_passing_arguments(function_to_decorate):
    def a_wrapper_accepting_arguments(arg1, arg2):
        print &amp;quot;I got args! Look:&amp;quot;, arg1, arg2
        function_to_decorate(arg1, arg2)
    return a_wrapper_accepting_arguments
 
# 当你调用装饰器返回的函数式，你就在调用wrapper，而给wrapper的
# 参数传递将会让它把参数传递给要装饰的函数
 
@a_decorator_passing_arguments
def print_full_name(first_name, last_name):
    print &amp;quot;My name is&amp;quot;, first_name, last_name
 
print_full_name(&amp;quot;Peter&amp;quot;, &amp;quot;Venkman&amp;quot;)
# outputs:
#I got args! Look: Peter Venkman
#My name is Peter 
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;7-装饰方法-decorating-methods&#34;&gt;7. 装饰方法（Decorating methods）&lt;/h1&gt;

&lt;p&gt;Python的一个伟大之处在于：方法和函数几乎是一样的(methods and functions are really the same)，除了方法的第一个参数应该是当前对象的引用(也就是 self)。这也就意味着只要记住把 self 考虑在内，你就可以用同样的方法给方法创建装饰器了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def method_friendly_decorator(method_to_decorate):
    def wrapper(self, lie):
        lie = lie - 3 # very friendly, decrease age even more :-)
        return method_to_decorate(self, lie)
    return wrapper
 
 
class Lucy(object):
 
    def __init__(self):
        self.age = 32
 
    @method_friendly_decorator
    def sayYourAge(self, lie):
        print &amp;quot;I am %s, what did you think?&amp;quot; % (self.age + lie)
 
l = Lucy()
l.sayYourAge(-3)
#outputs: I am 26, what did you think?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，如果你想编写一个非常通用的装饰器，可以用来装饰任意函数和方法，你就可以无视具体参数了，直接使用 &lt;code&gt;*args&lt;/code&gt;, &lt;code&gt;**kwargs&lt;/code&gt; 就行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def a_decorator_passing_arbitrary_arguments(function_to_decorate):
    # The wrapper accepts any arguments
    def a_wrapper_accepting_arbitrary_arguments(*args, **kwargs):
        print &amp;quot;Do I have args?:&amp;quot;
        print args
        print kwargs
        # Then you unpack the arguments, here *args, **kwargs
        # If you are not familiar with unpacking, check:
        # http://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/
        function_to_decorate(*args, **kwargs)
    return a_wrapper_accepting_arbitrary_arguments
 
@a_decorator_passing_arbitrary_arguments
def function_with_no_argument():
    print &amp;quot;Python is cool, no argument here.&amp;quot;
 
function_with_no_argument()
#outputs
#Do I have args?:
#()
#{}
#Python is cool, no argument here.
 
@a_decorator_passing_arbitrary_arguments
def function_with_arguments(a, b, c):
    print a, b, c
 
function_with_arguments(1,2,3)
#outputs
#Do I have args?:
#(1, 2, 3)
#{}
#1 2 3
 
@a_decorator_passing_arbitrary_arguments
def function_with_named_arguments(a, b, c, platypus=&amp;quot;Why not ?&amp;quot;):
    print &amp;quot;Do %s, %s and %s like platypus? %s&amp;quot; %\
    (a, b, c, platypus)
 
function_with_named_arguments(&amp;quot;Bill&amp;quot;, &amp;quot;Linus&amp;quot;, &amp;quot;Steve&amp;quot;, platypus=&amp;quot;Indeed!&amp;quot;)
#outputs
#Do I have args ? :
#(&#39;Bill&#39;, &#39;Linus&#39;, &#39;Steve&#39;)
#{&#39;platypus&#39;: &#39;Indeed!&#39;}
#Do Bill, Linus and Steve like platypus? Indeed!
 
class Mary(object):
 
    def __init__(self):
        self.age = 31
 
    @a_decorator_passing_arbitrary_arguments
    def sayYourAge(self, lie=-3): # You can now add a default value
        print &amp;quot;I am %s, what did you think ?&amp;quot; % (self.age + lie)
 
m = Mary()
m.sayYourAge()
#outputs
# Do I have args?:
#(&amp;lt;__main__.Mary object at 0xb7d303ac&amp;gt;,)
#{}
#I am 28, what did you think?
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;8-给装饰器传参-passing-arguments-to-the-decorator&#34;&gt;8. 给装饰器传参（Passing arguments to the decorator）&lt;/h1&gt;

&lt;p&gt;太棒了，那么现在对于给装饰器本身传参数，你有什么看法呢？好吧，这样说有点绕，因为装饰器必须接受一个函数作为参数，所以就不能把被装饰的函数的参数，直接传给装饰器（you cannot pass the decorated function arguments directly to the decorator.）&lt;/p&gt;

&lt;p&gt;在直奔答案之前，我们先写一个小提示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Decorators are ORDINARY functions
def my_decorator(func):
    print &amp;quot;I am a ordinary function&amp;quot;
    def wrapper():
        print &amp;quot;I am function returned by the decorator&amp;quot;
        func()
    return wrapper
 
# Therefore, you can call it without any &amp;quot;@&amp;quot;
 
def lazy_function():
    print &amp;quot;zzzzzzzz&amp;quot;
 
decorated_function = my_decorator(lazy_function)
#outputs: I am a ordinary function
 
# It outputs &amp;quot;I am a ordinary function&amp;quot;, because that&#39;s just what you do:
# calling a function. Nothing magic.
 
@my_decorator
def lazy_function():
    print &amp;quot;zzzzzzzz&amp;quot;
 
#outputs: I am a ordinary function
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这完全一样，都是 &lt;code&gt;my_decorator&lt;/code&gt; 被调用。所以当你使用 &lt;code&gt;@my_decorator&lt;/code&gt; 时，你在告诉 python 去调用 “被变量 &lt;code&gt;my_decorator&lt;/code&gt; 标记的” 函数（the function &amp;lsquo;labeled by the variable &amp;ldquo;my_decorator&amp;rdquo;&amp;lsquo;）。这很重要，因为你给的这个标签能直接指向装饰器。。。或者其他！让我们开始变得邪恶！（Let&amp;rsquo;s start to be evil!）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def decorator_maker():
 
    print &amp;quot;I make decorators! I am executed only once: &amp;quot;+\
          &amp;quot;when you make me create a decorator.&amp;quot;
 
    def my_decorator(func):
 
        print &amp;quot;I am a decorator! I am executed only when you decorate a function.&amp;quot;
 
        def wrapped():
            print (&amp;quot;I am the wrapper around the decorated function. &amp;quot;
                  &amp;quot;I am called when you call the decorated function. &amp;quot;
                  &amp;quot;As the wrapper, I return the RESULT of the decorated function.&amp;quot;)
            return func()
 
        print &amp;quot;As the decorator, I return the wrapped function.&amp;quot;
 
        return wrapped
 
    print &amp;quot;As a decorator maker, I return a decorator&amp;quot;
    return my_decorator
 
# Let&#39;s create a decorator. It&#39;s just a new function after all.
new_decorator = decorator_maker()      
#outputs:
#I make decorators! I am executed only once: when you make me create a decorator.
#As a decorator maker, I return a decorator
 
# Then we decorate the function
 
def decorated_function():
    print &amp;quot;I am the decorated function.&amp;quot;
 
decorated_function = new_decorator(decorated_function)
#outputs:
#I am a decorator! I am executed only when you decorate a function.
#As the decorator, I return the wrapped function
 
# Let&#39;s call the function:
decorated_function()
#outputs:
#I am the wrapper around the decorated function. I am called when you call the decorated function.
#As the wrapper, I return the RESULT of the decorated function.
#I am the decorated function.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不要感到惊讶，让我们做一件完全一样的事情，只不过跳过了中间变量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def decorated_function():
    print &amp;quot;I am the decorated function.&amp;quot;
decorated_function = decorator_maker()(decorated_function)
#outputs:
#I make decorators! I am executed only once: when you make me create a decorator.
#As a decorator maker, I return a decorator
#I am a decorator! I am executed only when you decorate a function.
#As the decorator, I return the wrapped function.
 
# Finally:
decorated_function()   
#outputs:
#I am the wrapper around the decorated function. I am called when you call the decorated function.
#As the wrapper, I return the RESULT of the decorated function.
#I am the decorated function.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再做一次，代码甚至更短：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@decorator_maker()
def decorated_function():
    print &amp;quot;I am the decorated function.&amp;quot;
#outputs:
#I make decorators! I am executed only once: when you make me create a decorator.
#As a decorator maker, I return a decorator
#I am a decorator! I am executed only when you decorate a function.
#As the decorator, I return the wrapped function.
 
#Eventually:
decorated_function()   
#outputs:
#I am the wrapper around the decorated function. I am called when you call the decorated function.
#As the wrapper, I return the RESULT of the decorated function.
#I am the decorated function.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;嘿，看到了吗？我们在用 &lt;code&gt;@&lt;/code&gt; 语法调用了函数 ：-）
那么回到带参数的装饰器。如果我们能够使用一个函数动态（on the fly）的生成装饰器，那么我们就能把参数传递给那个函数，对吗？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def decorator_maker_with_arguments(decorator_arg1, decorator_arg2):
 
    print &amp;quot;I make decorators! And I accept arguments:&amp;quot;, decorator_arg1, decorator_arg2
 
    def my_decorator(func):
        # 在这里能传参数是一个来自闭包的馈赠.
        # 如果你对闭包感到不舒服，你可以直接忽略（you can assume it&#39;s ok）,
        # 或者看看这里: http://stackoverflow.com/questions/13857/can-you-explain-closures-as-they-relate-to-python
        print &amp;quot;I am the decorator. Somehow you passed me arguments:&amp;quot;, decorator_arg1, decorator_arg2
 
        # 不要把装饰器参数和函数参数搞混了！
        def wrapped(function_arg1, function_arg2) :
            print (&amp;quot;I am the wrapper around the decorated function.\n&amp;quot;
                  &amp;quot;I can access all the variables\n&amp;quot;
                  &amp;quot;\t- from the decorator: {0} {1}\n&amp;quot;
                  &amp;quot;\t- from the function call: {2} {3}\n&amp;quot;
                  &amp;quot;Then I can pass them to the decorated function&amp;quot;
                  .format(decorator_arg1, decorator_arg2,
                          function_arg1, function_arg2))
            return func(function_arg1, function_arg2)
 
        return wrapped
 
    return my_decorator
 
@decorator_maker_with_arguments(&amp;quot;Leonard&amp;quot;, &amp;quot;Sheldon&amp;quot;)
def decorated_function_with_arguments(function_arg1, function_arg2):
    print (&amp;quot;I am the decorated function and only knows about my arguments: {0}&amp;quot;
           &amp;quot; {1}&amp;quot;.format(function_arg1, function_arg2))
 
decorated_function_with_arguments(&amp;quot;Rajesh&amp;quot;, &amp;quot;Howard&amp;quot;)
#outputs:
#I make decorators! And I accept arguments: Leonard Sheldon
#I am the decorator. Somehow you passed me arguments: Leonard Sheldon
#I am the wrapper around the decorated function.
#I can access all the variables
#   - from the decorator: Leonard Sheldon
#   - from the function call: Rajesh Howard
#Then I can pass them to the decorated function
#I am the decorated function and only knows about my arguments: Rajesh Howard
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是了，带参数的装饰器。参数也可以设置为变量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;c1 = &amp;quot;Penny&amp;quot;
c2 = &amp;quot;Leslie&amp;quot;
 
@decorator_maker_with_arguments(&amp;quot;Leonard&amp;quot;, c1)
def decorated_function_with_arguments(function_arg1, function_arg2):
    print (&amp;quot;I am the decorated function and only knows about my arguments:&amp;quot;
           &amp;quot; {0} {1}&amp;quot;.format(function_arg1, function_arg2))
 
decorated_function_with_arguments(c2, &amp;quot;Howard&amp;quot;)
#outputs:
#I make decorators! And I accept arguments: Leonard Penny
#I am the decorator. Somehow you passed me arguments: Leonard Penny
#I am the wrapper around the decorated function.
#I can access all the variables
#   - from the decorator: Leonard Penny
#   - from the function call: Leslie Howard
#Then I can pass them to the decorated function
#I am the decorated function and only knows about my arguments: Leslie Howard
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如你所见，你可以给装饰器传递参数，就好像其他任意一个使用了这种把戏的函数一样（you can pass arguments to the decorator like any function using this trick. ）。如果你愿意，甚至可以使用 &lt;code&gt;*args&lt;/code&gt;, &lt;code&gt;**kwargs&lt;/code&gt;。但是，记住，装置器只调用一次，仅当python导入这个脚本时。你不能在之后动态的设置参数（You can&amp;rsquo;t dynamically set the arguments afterwards.）。当你执行 &lt;code&gt;import x&lt;/code&gt; 时，这个函数已经被装饰了，因此你不能修改任何东西。&lt;/p&gt;

&lt;h1 id=&#34;9-实践-装饰器装饰一个装饰器-let-s-practice-a-decorator-to-decorate-a-decorator&#34;&gt;9. 实践：装饰器装饰一个装饰器（Let&amp;rsquo;s practice: a decorator to decorate a decorator）&lt;/h1&gt;

&lt;p&gt;OK，作为一个福利，我将展示一段能用来创建能接受通用的任意参数的装饰器的代码（I&amp;rsquo;ll give you a snippet to make any decorator accept generically any argument. ）。毕竟，为了能接受参数，我们用了另一个函数来创建我们的装饰器。我们包装了装饰器。在我们刚刚看到的东西里，还有用来包装函数的吗？是的，就是装饰器。让我们给装饰器写一个装饰器来玩玩：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def decorator_with_args(decorator_to_enhance):
    &amp;quot;&amp;quot;&amp;quot;
    This function is supposed to be used as a decorator.
    It must decorate an other function, that is intended to be used as a decorator.
    Take a cup of coffee.
    It will allow any decorator to accept an arbitrary number of arguments,
    saving you the headache to remember how to do that every time.
    &amp;quot;&amp;quot;&amp;quot;
 
    # We use the same trick we did to pass arguments
    def decorator_maker(*args, **kwargs):
 
        # We create on the fly a decorator that accepts only a function
        # but keeps the passed arguments from the maker.
        def decorator_wrapper(func):
 
            # We return the result of the original decorator, which, after all,
            # IS JUST AN ORDINARY FUNCTION (which returns a function).
            # Only pitfall: the decorator must have this specific signature or it won&#39;t work:
            return decorator_to_enhance(func, *args, **kwargs)
 
        return decorator_wrapper
 
    return decorator_maker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它可以像这样使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# You create the function you will use as a decorator. And stick a decorator on it :-)
# Don&#39;t forget, the signature is &amp;quot;decorator(func, *args, **kwargs)&amp;quot;
@decorator_with_args
def decorated_decorator(func, *args, **kwargs):
    def wrapper(function_arg1, function_arg2):
        print &amp;quot;Decorated with&amp;quot;, args, kwargs
        return func(function_arg1, function_arg2)
    return wrapper
 
# Then you decorate the functions you wish with your brand new decorated decorator.
 
@decorated_decorator(42, 404, 1024)
def decorated_function(function_arg1, function_arg2):
    print &amp;quot;Hello&amp;quot;, function_arg1, function_arg2
 
decorated_function(&amp;quot;Universe and&amp;quot;, &amp;quot;everything&amp;quot;)
#outputs:
#Decorated with (42, 404, 1024) {}
#Hello Universe and everything
 
# Whoooot!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我知道，你上一次有这种感觉，是在听一个人说“在理解递归之前，你必须先理解递归”之后。但是现在，掌握之后，你不觉得很爽吗？&lt;/p&gt;

&lt;h1 id=&#34;10-装饰器最佳实践-best-practices-while-using-decorators&#34;&gt;10. 装饰器最佳实践（Best practices while using decorators）&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;装饰器是在 python 2.4 之后才有的，所以先确定你的代码运行时；&lt;/li&gt;
&lt;li&gt;记住这点：装饰器降低了函数调用效率；&lt;/li&gt;
&lt;li&gt;你不能“解装饰”一个函数（You can not un-decorate a function. ）。有一些能用来创建可以移除的装饰器的方法（There are hacks to create decorators that can be removed），但没人用它们。所以一个函数一旦被装饰了，就结束了（不能改变了）。&lt;strong&gt;For all the code.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;装饰器包装了函数，这使得会难以调试。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Python 2.5 通过提供了一个 &lt;code&gt;functools&lt;/code&gt; 模块解决了最后一个问题。&lt;code&gt;functools.wraps&lt;/code&gt; 把任意被包装函数的函数名、模块名和 docstring 拷贝给了 &lt;code&gt;wrapper&lt;/code&gt;. 有趣的事是，&lt;code&gt;functools.wraps&lt;/code&gt; 也是一个装饰器：-）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# For debugging, the stacktrace prints you the function __name__
def foo():
    print &amp;quot;foo&amp;quot;
 
print foo.__name__
#outputs: foo
 
# With a decorator, it gets messy   
def bar(func):
    def wrapper():
        print &amp;quot;bar&amp;quot;
        return func()
    return wrapper
 
@bar
def foo():
    print &amp;quot;foo&amp;quot;
 
print foo.__name__
#outputs: wrapper
 
# &amp;quot;functools&amp;quot; can help for that
 
import functools
 
def bar(func):
    # We say that &amp;quot;wrapper&amp;quot;, is wrapping &amp;quot;func&amp;quot;
    # and the magic begins
    @functools.wraps(func)
    def wrapper():
        print &amp;quot;bar&amp;quot;
        return func()
    return wrapper
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;11-装饰器如何才能有用-how-can-the-decorators-be-useful&#34;&gt;11. 装饰器如何才能有用（How can the decorators be useful?）&lt;/h1&gt;

&lt;p&gt;现在问题来了：我能用装饰器来干嘛？看起来很酷也很强大，但是来一个实际例子才更好。好吧，有1000中可能性（Well, there are 1000 possibilities.）。一个典型的用途是，用来扩展一个外部导入的函数（你不能修改）的行为，或者为了调试（你不想修改这个函数，因为只是暂时的）。你也可以用装饰器实现只用一段相同的代码来扩展成几个不同的函数，而且你不需要每次都重写这段代码。这样就是常说的 DRY。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def benchmark(func):
    &amp;quot;&amp;quot;&amp;quot;
    A decorator that prints the time a function takes
    to execute.
    &amp;quot;&amp;quot;&amp;quot;
    import time
    def wrapper(*args, **kwargs):
        t = time.clock()
        res = func(*args, **kwargs)
        print func.__name__, time.clock()-t
        return res
    return wrapper
 
 
def logging(func):
    &amp;quot;&amp;quot;&amp;quot;
    A decorator that logs the activity of the script.
    (it actually just prints it, but it could be logging!)
    &amp;quot;&amp;quot;&amp;quot;
    def wrapper(*args, **kwargs):
        res = func(*args, **kwargs)
        print func.__name__, args, kwargs
        return res
    return wrapper
 
 
def counter(func):
    &amp;quot;&amp;quot;&amp;quot;
    A decorator that counts and prints the number of times a function has been executed
    &amp;quot;&amp;quot;&amp;quot;
    def wrapper(*args, **kwargs):
        wrapper.count = wrapper.count + 1
        res = func(*args, **kwargs)
        print &amp;quot;{0} has been used: {1}x&amp;quot;.format(func.__name__, wrapper.count)
        return res
    wrapper.count = 0
    return wrapper
 
@counter
@benchmark
@logging
def reverse_string(string):
    return str(reversed(string))
 
print reverse_string(&amp;quot;Able was I ere I saw Elba&amp;quot;)
print reverse_string(&amp;quot;A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!&amp;quot;)
 
#outputs:
#reverse_string (&#39;Able was I ere I saw Elba&#39;,) {}
#wrapper 0.0
#wrapper has been used: 1x
#ablE was I ere I saw elbA
#reverse_string (&#39;A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!&#39;,) {}
#wrapper 0.0
#wrapper has been used: 2x
#!amanaP :lanac a ,noep a ,stah eros ,raj a ,hsac ,oloR a ,tur a ,mapS ,snip ,eperc a ,)lemac a ro( niaga gab ananab a ,gat a ,nat a ,gab ananab a ,gag a ,inoracam ,elacrep ,epins ,spam ,arutaroloc a ,shajar ,soreh ,atsap ,eonac a ,nalp a ,nam A

当然，装饰器的好处就是你可以几乎用来装饰所有东西，而且不要重写。也就是我说的 DRY：（Of course the good thing with decorators is that you can use them right away on almost anything without rewriting. DRY, I said:）

:::python
@counter
@benchmark
@logging
def get_random_futurama_quote():
    import httplib
    conn = httplib.HTTPConnection(&amp;quot;slashdot.org:80&amp;quot;)
    conn.request(&amp;quot;HEAD&amp;quot;, &amp;quot;/index.html&amp;quot;)
    for key, value in conn.getresponse().getheaders():
        if key.startswith(&amp;quot;x-b&amp;quot;) or key.startswith(&amp;quot;x-f&amp;quot;):
            return value
    return &amp;quot;No, I&#39;m ... doesn&#39;t!&amp;quot;
 
print get_random_furturama_quote()
print get_random_furturama_quote()
 
#outputs:
#get_random_futurama_quote () {}
#wrapper 0.02
#wrapper has been used: 1x
#The laws of science be a harsh mistress.
#get_random_futurama_quote () {}
#wrapper 0.01
#wrapper has been used: 2x
#Curse you, merciful Poseidon!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python 语言本身也提供了一些装饰器：&lt;code&gt;property&lt;/code&gt;、&lt;code&gt;staticmethod&lt;/code&gt; 等。Django 用装饰器来管理换成和视图权限。Twisted 用来伪装 内联异步函数调用（Twisted to fake inlining asynchronous functions calls. ）。这确实是一片广阔的天地。（This really is a large playground.）&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用 openpyxl 处理 xlsx 文件</title>
      <link>http://deanthompson.github.io/posts/2013/02/using-openpyxl-to-read-and-write-xlsx-files</link>
      <pubDate>Mon, 25 Feb 2013 16:39:55 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2013/02/using-openpyxl-to-read-and-write-xlsx-files</guid>
      <description>&lt;p&gt;久违的图书馆~~虽然刚开学，图书馆里已经有不少同学在看书自习了，学校的氛围就是不一样，在安静的环境和熟悉的书香中，很容易就静下心来。OK，下面进入正题。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;openpyxl&lt;/code&gt; 是一个用来处理 excel 文件的 python 代码库。Python 有一些内置的功能相似的代码库，不过我都没用过，而且好像都有不少局限性。&lt;code&gt;openpyxl&lt;/code&gt; 用起来还是挺简单的，对照文档就可以解决一些基本需求，比如常见的都写操作。不过有一个前提，它只能用来处理 Excel 2007 及以上版本的 excel 文件，也就是 &lt;code&gt;.xlsx/.xlsm&lt;/code&gt; 格式的表格文件。顺便提一下，&lt;code&gt;xls&lt;/code&gt; 和 &lt;code&gt;xlsx&lt;/code&gt; 是两种完全不同的格式，其本质的差别相比字面的区别要多很多。xls 的核心结构是复合文档类型的结构，而 xlsx 的核心结构是 XML 类型的结构，采用的是基于XML的压缩方式，使其占用的空间更小。&lt;code&gt;xlsx&lt;/code&gt; 中最后一个 &lt;code&gt;x&lt;/code&gt; 的意义就在于此。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;1-安装&#34;&gt;1. 安装&lt;/h1&gt;

&lt;p&gt;可以在这里下载openpyxl的代码包，然后从源代码安装即可。最新版本是 1.6.1.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://pypi.python.org/pypi/openpyxl&#34;&gt;https://pypi.python.org/pypi/openpyxl&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;2-读&#34;&gt;2. 读&lt;/h1&gt;

&lt;p&gt;用openpyxl读一个xlsx文件很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from openpyxl import load_workbook
 
wb = load_workbook(filename=r&#39;existing_file.xlsx&#39;)
 
sheets = wb.get_sheet_names()   # 获取所有表格(worksheet)的名字
sheet0 = sheets[0]  # 第一个表格的名称
ws = wb.get_sheet_by_name(&#39;sheet_name&#39;) # 获取特定的 worksheet
 
# 获取表格所有行和列，两者都是可迭代的
rows = ws.rows
columns = ws.columns
 
# 行迭代
content = []
for row in rows:
    line = [col.value for col in row]
    content.append(line)
 
# 通过坐标读取值
print ws.cell(&#39;B12&#39;).value    # B 表示列，12 表示行
print ws.cell(row=12, column=2).value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当调用 &lt;code&gt;get_sheet_by_name(&#39;sheet_name&#39;)&lt;/code&gt; 方法获取表格时，如果名字为 &lt;code&gt;sheet_name&lt;/code&gt; 的表格不存在，不会报错或抛出异常，而只是返回 &lt;code&gt;None&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;3-写&#34;&gt;3. 写&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from openpyxl import Workbook
 
# 在内存中创建一个workbook对象，而且会至少创建一个 worksheet
wb = Workbook()
 
ws = wb.get_active_sheet()
print ws.title
ws.title = &#39;New Title&#39;  # 设置worksheet的标题
 
# 设置单元格的值
ws.cell(&#39;D3&#39;).value = 4
ws.cell(row=3, column=1).value = 6
 
new_ws = wb.create_sheet(title=&#39;new_sheet&#39;)
for row in range(100):
    for col in range(10):
        new_ws.cell(row=row, column=col).value = row+col
 
# 最后一定要保存！
wb.save(filename=&#39;new_file.xlsx&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;4-文档&#34;&gt;4. 文档&lt;/h1&gt;

&lt;p&gt;对于常规的小文件的操作，以上的一些介绍基本是够了。有时候需要处理大文件，就需要用到更高级一些的方法。更详细的用法、教程和API文档请参考这里：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://pythonhosted.org/openpyxl/&#34;&gt;http://pythonhosted.org/openpyxl/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;5-references&#34;&gt;5. References&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;下载 openpyxl：&lt;a href=&#34;https://pypi.python.org/pypi/openpyxl&#34;&gt;https://pypi.python.org/pypi/openpyxl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;openpyxl 文档：&lt;a href=&#34;http://pythonhosted.org/openpyxl/&#34;&gt;http://pythonhosted.org/openpyxl/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Python字典切片</title>
      <link>http://deanthompson.github.io/posts/2012/12/python-dict-slice</link>
      <pubDate>Sat, 01 Dec 2012 15:09:08 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2012/12/python-dict-slice</guid>
      <description>&lt;p&gt;python 的 &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt; 都提供了切片操作，用起来非常方便。有时候会需要对字典进行截取，只需要其中一部分数据。然而 python 的 &lt;code&gt;dict&lt;/code&gt; 没有提供类似的切片操作，所以就得要自己实现。&lt;/p&gt;

&lt;p&gt;其实也很简单：先取出所有 keys，再对 keys 切片，然后用得到的键去字典里找值重新创建一个新的字典。示例代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def dict_slice(adict, start, end):
    keys = adict.keys()
    dict_slice = {}
    for k in keys[start:end]:
        dict_slice[k] = adict[k]
    return dict_slice
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;EDIT 2013-10-26 01:13&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;补充一个一行的版本（one-liner）:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dict_slice = lambda adict, start, end: dict((k, adict[k]) for k in adict.keys()[start:end])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这行代码主要是用了 &lt;code&gt;lambda&lt;/code&gt; 来创建一个匿名函数，再用 built-in 函数 &lt;code&gt;dict()&lt;/code&gt; 来生成新的字典。作用和上面的函数一模一样，调用方式也是一样的。如果是 python 2.7 及以上的版本，还可以用 dict comprehension 来替换 &lt;code&gt;dict()&lt;/code&gt; 函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dict_slice = lambda adict, start, end: { k:adict[k] for k in adict.keys()[start:end] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个看起来和 list comprehension 就很像了。非常优雅，且节省空间 ：）&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;简单验证：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; d = {}.fromkeys(range(10), 5)
&amp;gt;&amp;gt;&amp;gt; d
{0: 5, 1: 5, 2: 5, 3: 5, 4: 5, 5: 5, 6: 5, 7: 5, 8: 5, 9: 5}
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; slice = dict_slice(d, 3, 5)
&amp;gt;&amp;gt;&amp;gt; slice
{3: 5, 4: 5}
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; slice = dict_slice(d, 4, 8)
&amp;gt;&amp;gt;&amp;gt; slice
{4: 5, 5: 5, 6: 5, 7: 5}
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; slice = dict_slice(d, 5, -1)
&amp;gt;&amp;gt;&amp;gt; slice
{5: 5, 6: 5, 7: 5, 8: 5}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在某些场景下，如果需要对字典的切片有其他需求，如字典按键值排序等，还可以在创建新字典之前进行处理。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python 时间戳和日期相互转换</title>
      <link>http://deanthompson.github.io/posts/2012/10/python-timestamp-to-timestr</link>
      <pubDate>Sun, 21 Oct 2012 18:53:51 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2012/10/python-timestamp-to-timestr</guid>
      <description>&lt;p&gt;在写Python的时候经常会遇到时间格式的问题，每次都是上 google 搜索然后找别人的博客或网站来参考。现在自己简单总结一下，方便以后查询。&lt;/p&gt;

&lt;p&gt;首先就是最近用到的时间戳（timestamp）和时间字符串之间的转换。所谓时间戳，就是从 1970 年 1 月 1 日 00:00:00 到现在的秒数。那关于为什么是1970年这个特殊的日期，这篇文章有个简单明了的介绍：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://www.scriptlover.com/static/1071-%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4-%E7%BC%96%E7%A8%8B-%E6%95%B0%E6%8D%AE%E5%BA%93&#34;&gt;为什么计算机时间要从1970年1月1日开始算起？&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;在Python里，时间戳可以通过 &lt;code&gt;time&lt;/code&gt; 模块里的 &lt;code&gt;time()&lt;/code&gt; 方法获得，比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;In [1]: import time

In [2]: time.time()
Out[2]: 1350816710.8050799
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个值对人来说是不友好的，所以有时候需要转换为一定的格式方便人理解。我们可以调用 &lt;code&gt;time.strftime()&lt;/code&gt; 函数来达到这个目的。根据 &lt;code&gt;strftime()&lt;/code&gt; 函数的文档，我猜这个名称应该是 “string format time” 的简写，也就是字符串格式的时间。这个方法需要两个参数，其中一个是时间格式，一个是一个9元组，第二个参数可选，默认为 &lt;code&gt;time.localtime()&lt;/code&gt; 的返回值。而那个9元组其实是 &lt;code&gt;struct_time&lt;/code&gt;，由9个元素组成的元组(tuple)，也是一种时间表示的格式。比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;In [5]: import time

In [6]: time.localtime()
Out[6]: time.struct_time(tm_year=2012, tm_mon=10, tm_mday=21, tm_hour=19, tm_min=4, tm_sec=25, tm_wday=6, tm_yday=295, tm_isdst=0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体的含义，前6个应该很明显，那么后三个分别是：weekday(0-6)，在一年中的第几天(1-366)，是否是夏令时（默认-1）。现在再来看看如何把时间戳转换为指定格式的字符串形式。很简单，直接上代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;In [8]: import time

In [9]: st = time.localtime(1350816710.8050799)
 
In [10]: time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;, st)
Out[10]: &#39;2012-10-21 18:51:50&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先用 &lt;code&gt;localtime()&lt;/code&gt; 把时间戳转换为 &lt;code&gt;struct_time&lt;/code&gt;， 然后传给 &lt;code&gt;strftime&lt;/code&gt; 转换为指定格式的字符串。那么反过来呢？
同样需要先转换为 &lt;code&gt;struct_time&lt;/code&gt;，这个工作由 &lt;code&gt;time.strptime()&lt;/code&gt; 函数完成。&lt;code&gt;strptime&lt;/code&gt; 中的 &lt;code&gt;p&lt;/code&gt; 应该是 parse 的意思，原型是:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;strptime(string, format) -&amp;gt; struct_time
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把字符串形式的时间按照指定格式解析，转换为 &lt;code&gt;struct_time&lt;/code&gt;。然后传给&lt;code&gt;time.mktime()&lt;/code&gt; 完成最后的工作，整个过程是:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;In [12]: import time
 
In [13]: st = time.strptime(&#39;2012-10-21 18:51:50&#39;, &#39;%Y-%m-%d %H:%M:%S&#39;)
 
In [14]: time.mktime(st)
Out[14]: 1350816710.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，有两篇参考文章：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Python中时间戳与时间字符串互相转化: &lt;a href=&#34;http://www.coder4.com/archives/2239&#34;&gt;http://www.coder4.com/archives/2239&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python中time模块详解（很好）:&lt;a href=&#34;http://qinxuye.me/article/details-about-time-module-in-python/&#34;&gt;http://qinxuye.me/article/details-about-time-module-in-python/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>
