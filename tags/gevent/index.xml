<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Gevent on 李林克斯 </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://deanthompson.github.io/tags/gevent/index.xml</link>
    <language>zh-CN</language>
    <author>Yangliang Li</author>
    
    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
    
    <item>
      <title>在 Flask 项目的 celery 中使用 gevent</title>
      <link>http://deanthompson.github.io/posts/2016/05/using-celery-with-flask-and-gevent</link>
      <pubDate>Tue, 17 May 2016 16:42:37 CST</pubDate>
      <author>Yangliang Li</author>
      <guid>http://deanthompson.github.io/posts/2016/05/using-celery-with-flask-and-gevent</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://deanthompson.github.io/posts/2015/11/using-celery-with-flask/&#34;&gt;在 Flask 项目中使用 Celery&lt;/a&gt; 这篇文章谈到了如何在 Flask 项目中集成 Celery，也讲了在 celery 任务中引用 Flask 的 application context 的方法。一般情况下那样使用是没问题的，但是如果需要在 task 中使用 gevent，就需要一些额外的改进。至少有两点。&lt;/p&gt;

&lt;h2 id=&#34;1-使用-gevent-并发模型&#34;&gt;1. 使用 gevent 并发模型&lt;/h2&gt;

&lt;p&gt;如果在 task 中要使用 gevent，就必须使用 gevent 并发模型。这很好处理，只需要修改启动选项就行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ celery worker -A celery_worker.celery -P gevent -c 10 -l INFO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的命令，&lt;code&gt;-P&lt;/code&gt; 选项指定 pool，默认是 prefork，这里是 gevent; &lt;code&gt;-c&lt;/code&gt; 设置并发数。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-引用-flask-的-application-context&#34;&gt;2. 引用 Flask 的 application context&lt;/h2&gt;

&lt;p&gt;这个问题也是在 &lt;a href=&#34;http://deanthompson.github.io/posts/2015/11/using-celery-with-flask/&#34;&gt;在 Flask 项目中使用 Celery&lt;/a&gt; 中重点讨论的，在这种场景下，上文的解决方法起不到作用，仍然会报错（具体原因不太懂，知道的朋友请不吝赐教）。解决方案就是，把需要引用 Flask app 的地方（如 app.config），放到 Flask 的 application context 里执行，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with app.app_context():
    print app.config.get(&#39;SOME_CONFIG_KEY&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在实际应用中，我最后写了个装饰器来实现这个目的。简单介绍一下场景，项目用到了 Flask-Cache，项目启动时会创建全局单例 &lt;code&gt;cache&lt;/code&gt;，并在 &lt;code&gt;create_app&lt;/code&gt; 中进行初始化。在 Flask-Cache 初始化时，会把当前的 Flask app 对象绑定到实例 &lt;code&gt;cache&lt;/code&gt; 中，所以可以尝试从这里获取 app 对象。&lt;/p&gt;

&lt;p&gt;代码的目录结构与之前一样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── README.md
├── app
│   ├── __init__.py
│   ├── config.py
│   ├── forms
│   ├── models
│   ├── tasks
│   │   ├── __init__.py
│   │   └── email.py
│   └── views
│   │   ├── __init__.py
│   │   └── account.py
├── celery_worker.py
├── manage.py
└── wsgi.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;装饰器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def with_app_context(task):
    memo = {&#39;app&#39;: None}

    @functools.wraps(task)
    def _wrapper(*args, **kwargs):
        if not memo[&#39;app&#39;]:
            try:
                # 尝试从 cache 中获取 app 对象，如果得到的不是 None，就不需要重复创建了
                app = cache.app
                _ = app.name
            except Exception:
                from app import create_app

                app = create_app()
            memo[&#39;app&#39;] = app
        else:
            app = memo[&#39;app&#39;]

        # 把 task 放到 application context 环境中运行
        with app.app_context():
            return task(*args, **kwargs)

    return _wrapper
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@celery.task()
@with_app_context
def add(x, y):
    print app.config.get(&#39;SOME_CONFIG_KEY&#39;)
    return x + y
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>
